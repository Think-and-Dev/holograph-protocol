{
  "language": "Solidity",
  "sources": {
    "src/abstract/Admin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract Admin {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.admin')) - 1)\n   */\n  bytes32 constant _adminSlot = 0x3f106594dc74eeef980dae234cde8324dc2497b13d27a0c59e55bd2ca10a07c9;\n\n  modifier onlyAdmin() {\n    require(msg.sender == getAdmin(), \"HOLOGRAPH: admin only function\");\n    _;\n  }\n\n  constructor() {}\n\n  function admin() public view returns (address) {\n    return getAdmin();\n  }\n\n  function getAdmin() public view returns (address adminAddress) {\n    assembly {\n      adminAddress := sload(_adminSlot)\n    }\n  }\n\n  function setAdmin(address adminAddress) public onlyAdmin {\n    assembly {\n      sstore(_adminSlot, adminAddress)\n    }\n  }\n\n  function adminCall(address target, bytes calldata data) external payable onlyAdmin {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/ContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/IContractMetadata.sol\";\n\n/**\n *  @title   Contract Metadata\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *           for you contract.\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\nabstract contract ContractMetadata is IContractMetadata {\n  /// @notice Returns the contract metadata URI.\n  string public override contractURI;\n\n  /**\n   *  @notice         Lets a contract admin set the URI for contract-level metadata.\n   *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\n   *                  See {_canSetContractURI}.\n   *                  Emits {ContractURIUpdated Event}.\n   *\n   *  @param _uri     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n   */\n  function setContractURI(string memory _uri) external override {\n    if (!_canSetContractURI()) {\n      revert(\"Not authorized\");\n    }\n\n    _setupContractURI(_uri);\n  }\n\n  /// @dev Lets a contract admin set the URI for contract-level metadata.\n  function _setupContractURI(string memory _uri) internal {\n    string memory prevURI = contractURI;\n    contractURI = _uri;\n\n    emit ContractURIUpdated(prevURI, _uri);\n  }\n\n  /// @dev Returns whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view virtual returns (bool);\n}\n"
    },
    "src/abstract/DelayedReveal.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/IDelayedReveal.sol\";\n\n/**\n *  @title   Delayed Reveal\n *  @notice  Thirdweb's `DelayedReveal` is a contract extension for base NFT contracts. It lets you create batches of\n *           'delayed-reveal' NFTs. You can learn more about the usage of delayed reveal NFTs here - https://blog.thirdweb.com/delayed-reveal-nfts\n */\n\nabstract contract DelayedReveal is IDelayedReveal {\n  /// @dev The contract doesn't have any url to be delayed revealed\n  error DelayedRevealNothingToReveal();\n\n  /// @dev The result of the returned an incorrect hash\n  error DelayedRevealIncorrectResultHash(bytes32 expected, bytes32 actual);\n\n  /// @dev Mapping from tokenId of a batch of tokens => to delayed reveal data.\n  mapping(uint256 => bytes) public encryptedData;\n\n  /// @dev Sets the delayed reveal data for a batchId.\n  function _setEncryptedData(uint256 _batchId, bytes memory _encryptedData) internal {\n    encryptedData[_batchId] = _encryptedData;\n  }\n\n  /**\n   *  @notice             Returns revealed URI for a batch of NFTs.\n   *  @dev                Reveal encrypted base URI for `_batchId` with caller/admin's `_key` used for encryption.\n   *                      Reverts if there's no encrypted URI for `_batchId`.\n   *                      See {encryptDecrypt}.\n   *\n   *  @param _batchId     ID of the batch for which URI is being revealed.\n   *  @param _key         Secure key used by caller/admin for encryption of baseURI.\n   *\n   *  @return revealedURI Decrypted base URI.\n   */\n  function getRevealURI(uint256 _batchId, bytes calldata _key) public view returns (string memory revealedURI) {\n    bytes memory data = encryptedData[_batchId];\n    if (data.length == 0) {\n      revert DelayedRevealNothingToReveal();\n    }\n\n    (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(data, (bytes, bytes32));\n\n    revealedURI = string(encryptDecrypt(encryptedURI, _key));\n\n    if (keccak256(abi.encodePacked(revealedURI, _key, block.chainid)) != provenanceHash) {\n      revert DelayedRevealIncorrectResultHash(\n        provenanceHash,\n        keccak256(abi.encodePacked(revealedURI, _key, block.chainid))\n      );\n    }\n  }\n\n  /**\n   *  @notice         Encrypt/decrypt data on chain.\n   *  @dev            Encrypt/decrypt given `data` with `key`. Uses inline assembly.\n   *                  See: https://ethereum.stackexchange.com/questions/69825/decrypt-message-on-chain\n   *\n   *  @param data     Bytes of data to encrypt/decrypt.\n   *  @param key      Secure key used by caller for encryption/decryption.\n   *\n   *  @return result  Output after encryption/decryption of given data.\n   */\n  function encryptDecrypt(bytes memory data, bytes calldata key) public pure override returns (bytes memory result) {\n    // Store data length on stack for later use\n    uint256 length = data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Set result to free memory pointer\n      result := mload(0x40)\n      // Increase free memory pointer by lenght + 32\n      mstore(0x40, add(add(result, length), 32))\n      // Set result length\n      mstore(result, length)\n    }\n\n    // Iterate over the data stepping by 32 bytes\n    for (uint256 i = 0; i < length; i += 32) {\n      // Generate hash of the key and offset\n      bytes32 hash = keccak256(abi.encodePacked(key, i));\n\n      bytes32 chunk;\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        // Read 32-bytes data chunk\n        chunk := mload(add(data, add(i, 32)))\n      }\n      // XOR the chunk with hash\n      chunk ^= hash;\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        // Write 32-byte encrypted chunk\n        mstore(add(result, add(i, 32)), chunk)\n      }\n    }\n  }\n\n  /**\n   *  @notice         Returns whether the relvant batch of NFTs is subject to a delayed reveal.\n   *  @dev            Returns `true` if `_batchId`'s base URI is encrypted.\n   *  @param _batchId ID of a batch of NFTs.\n   */\n  function isEncryptedBatch(uint256 _batchId) public view returns (bool) {\n    return encryptedData[_batchId].length > 0;\n  }\n}\n"
    },
    "src/abstract/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity 0.8.13;\n\nimport \"../library/ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n  /* solhint-disable var-name-mixedcase */\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  // WE CANNOT USE immutable VALUES SINCE IT BREAKS OUT CREATE2 COMPUTATIONS ON DEPLOYER SCRIPTS\n  // AFTER MAKING NECESARRY CHANGES, WE CAN ADD IT BACK IN\n  bytes32 private _CACHED_DOMAIN_SEPARATOR;\n  uint256 private _CACHED_CHAIN_ID;\n  address private _CACHED_THIS;\n\n  bytes32 private _HASHED_NAME;\n  bytes32 private _HASHED_VERSION;\n  bytes32 private _TYPE_HASH;\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n   *\n   * The meaning of `name` and `version` is specified in\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n   *\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n   * - `version`: the current major version of the signing domain.\n   *\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n   * contract upgrade].\n   */\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  function _eip712_init(string memory name, string memory version) internal {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n    _CACHED_THIS = address(this);\n    _TYPE_HASH = typeHash;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "src/abstract/ERC1155H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC1155H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC1155: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC1155: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC1155: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC1155 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/ERC20H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC20H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC20: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC20: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC20 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the token contract.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/ERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/GenericH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract GenericH is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"GENERIC: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"GENERIC: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"GENERIC: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph GENERIC standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the contract.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/HLGERC20H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract HLGERC20H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC20: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == holographer()) {\n      require(msgSender() == _getOwner(), \"ERC20: owner only function\");\n    } else {\n      require(msg.sender == _getOwner(), \"ERC20: owner only function\");\n    }\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal pure returns (address sender) {\n    assembly {\n      sender := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC20 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the token contract.\n   */\n  function owner() external view returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    if (msg.sender == holographer()) {\n      return msgSender() == _getOwner();\n    } else {\n      return msg.sender == _getOwner();\n    }\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  /**\n   * @dev This function is unreachable unless custom contract address is called directly.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable {\n    revert(\"ERC20: unreachable code\");\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/Initializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/InitializableInterface.sol\";\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need for a constructor\n */\nabstract contract Initializable is InitializableInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.initialized')) - 1)\n   */\n  bytes32 constant _initializedSlot = 0x4e5f991bca30eca2d4643aaefa807e88f96a4a97398933d572a3c0d973004a01;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual returns (bytes4);\n\n  function _isInitialized() internal view returns (bool initialized) {\n    assembly {\n      initialized := sload(_initializedSlot)\n    }\n  }\n\n  function _setInitialized() internal {\n    assembly {\n      sstore(_initializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "src/abstract/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract NonReentrant {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.reentrant')) - 1)\n   */\n  bytes32 constant _reentrantSlot = 0x04b524dd539523930d3901481aa9455d7752b49add99e1647adb8b09a3137279;\n\n  modifier nonReentrant() {\n    require(getStatus() != 2, \"HOLOGRAPH: reentrant call\");\n    setStatus(2);\n    _;\n    setStatus(1);\n  }\n\n  constructor() {}\n\n  function getStatus() internal view returns (uint256 status) {\n    assembly {\n      status := sload(_reentrantSlot)\n    }\n  }\n\n  function setStatus(uint256 status) internal {\n    assembly {\n      sstore(_reentrantSlot, status)\n    }\n  }\n}\n"
    },
    "src/abstract/Owner.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract Owner {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  /**\n   * @dev Event emitted when contract owner is changed.\n   */\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  modifier onlyOwner() virtual {\n    require(msg.sender == getOwner(), \"HOLOGRAPH: owner only function\");\n    _;\n  }\n\n  function owner() external view virtual returns (address) {\n    return getOwner();\n  }\n\n  constructor() {}\n\n  function getOwner() public view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function setOwner(address ownerAddress) public virtual onlyOwner {\n    address previousOwner = getOwner();\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n    emit OwnershipTransferred(previousOwner, ownerAddress);\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0), \"HOLOGRAPH: zero address\");\n    assembly {\n      sstore(_ownerSlot, newOwner)\n    }\n  }\n\n  function ownerCall(address target, bytes calldata data) external payable onlyOwner {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/StrictERC1155H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC1155.sol\";\n\nimport \"./ERC1155H.sol\";\n\nabstract contract StrictERC1155H is ERC1155H, HolographedERC1155 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    _success = true;\n    _data = abi.encode(holographer());\n  }\n\n  function afterApprove(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterApprovalAll(\n    address /* _to*/,\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprovalAll(\n    address /* _to*/,\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address /* _owner*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address /* _owner*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address /* _owner*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address /* _owner*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC1155Received(\n    address /* _operator*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC1155Received(\n    address /* _operator*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n}\n"
    },
    "src/abstract/StrictERC20H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC20.sol\";\n\nimport \"./ERC20H.sol\";\n\nabstract contract StrictERC20H is ERC20H, HolographedERC20 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    /**\n     * @dev This is just here to suppress unused parameter warning\n     */\n    _data = abi.encodePacked(holographer());\n    _success = true;\n  }\n\n  function afterApprove(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC20Received(\n    address /* _token*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC20Received(\n    address /* _token*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address /* _owner*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address /* _owner*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address /* _owner*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address /* _owner*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function onAllowance(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = false;\n    return _success;\n  }\n}\n"
    },
    "src/abstract/StrictERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC721.sol\";\n\nimport \"./ERC721H.sol\";\n\nabstract contract StrictERC721H is ERC721H, HolographedERC721 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    _success = true;\n    _data = abi.encode(holographer());\n  }\n\n  function afterApprove(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address /* _owner*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterApprovalAll(\n    address /* _sender*/,\n    address /* _to*/,\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprovalAll(\n    address /* _sender*/,\n    address /* _to*/,\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address /* _owner*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address /* _owner*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address /* _owner*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address /* _owner*/,\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC721Received(\n    address /* _operator*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC721Received(\n    address /* _operator*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function onIsApprovedForAll(\n    address /* _wallet*/,\n    address /* _operator*/\n  ) external view virtual onlyHolographer returns (bool approved) {\n    approved = _success;\n    return false;\n  }\n\n  function contractURI() external view virtual onlyHolographer returns (string memory contractJSON) {\n    contractJSON = _success ? \"\" : \"\";\n  }\n}\n"
    },
    "src/drops/interface/IDropsPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IDropsPriceOracle {\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount);\n}\n"
    },
    "src/drops/interface/IHolographDropERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IMetadataRenderer} from \"./IMetadataRenderer.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface IHolographDropERC721 {\n  // Access errors\n\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  /// @notice Thrown when the operator for the contract is not allowed\n  /// @dev Used when strict enforcement of marketplaces for creator royalties is desired.\n  error OperatorNotAllowed(address operator);\n\n  /// @notice Thrown when there is no active market filter DAO address supported for the current chain\n  /// @dev Used for enabling and disabling filter for the given chain.\n  error MarketFilterDAOAddressNotSupportedForChain();\n\n  /// @notice Used when the operator filter registry external call fails\n  /// @dev Used for bubbling error up to clients.\n  error RemoteOperatorFilterRegistryCallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Presale is inactive\n  error Presale_Inactive();\n  /// @notice Presale merkle root is invalid\n  error Presale_MerkleNotApproved();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Too many presale for address\n  error Presale_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when metadata renderer is updated.\n  /// @param sender address of the updater\n  /// @param renderer new metadata renderer address\n  event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  /// @param publicSaleStart unix timestamp when the public sale starts\n  /// @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n  /// @param presaleStart unix timestamp when the presale starts\n  /// @param presaleEnd unix timestamp when the presale ends\n  /// @param presaleMerkleRoot merkle root for the presale information\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n  /// @param quantity to purchase\n  /// @param maxQuantity can purchase (verified by merkle root)\n  /// @param pricePerToken price per token allowed (verified by merkle root)\n  /// @param merkleProof input for merkle proof leaf verified by merkle root\n  /// @return first minted token ID\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] memory merkleProof\n  ) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (SaleDetails memory);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @notice Update the metadata renderer\n  /// @param newRenderer new address for renderer\n  /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external;\n\n  /// @notice This is an admin mint function to mint a quantity to a specific address\n  /// @param to address to mint to\n  /// @param quantity quantity to mint\n  /// @return the id of the first minted NFT\n  function adminMint(address to, uint256 quantity) external returns (uint256);\n\n  /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n  /// @param to list of addresses to mint an NFT each to\n  /// @return the id of the first minted NFT\n  function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/drops/interface/IHolographDropERC721V2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IMetadataRenderer} from \"./IMetadataRenderer.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface IHolographDropERC721V2 {\n  // Access errors\n\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Presale is inactive\n  error Presale_Inactive();\n  /// @notice Presale merkle root is invalid\n  error Presale_MerkleNotApproved();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Too many presale for address\n  error Presale_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when metadata renderer is updated.\n  /// @param sender address of the updater\n  /// @param renderer new metadata renderer address\n  event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n  /// @notice Event emitted when an nfs is minted\n  /// @param recipient address that the nft was minted to\n  /// @param tokenId id of the minted nft\n  /// @param id id of the minted nft with chain id prefix\n  event NFTMinted(address indexed recipient, uint256 indexed tokenId, uint256 id);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  /// @param publicSaleStart unix timestamp when the public sale starts\n  /// @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n  /// @param presaleStart unix timestamp when the presale starts\n  /// @param presaleEnd unix timestamp when the presale ends\n  /// @param presaleMerkleRoot merkle root for the presale information\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n  /// @param quantity to purchase\n  /// @param maxQuantity can purchase (verified by merkle root)\n  /// @param pricePerToken price per token allowed (verified by merkle root)\n  /// @param merkleProof input for merkle proof leaf verified by merkle root\n  /// @return first minted token ID\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] memory merkleProof\n  ) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (SaleDetails memory);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @notice Update the metadata renderer\n  /// @param newRenderer new address for renderer\n  /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external;\n\n  /// @notice This is an admin mint function to mint a quantity to a specific address\n  /// @param to address to mint to\n  /// @param quantity quantity to mint\n  /// @return the id of the first minted NFT\n  function adminMint(address to, uint256 quantity) external returns (uint256);\n\n  /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n  /// @param to list of addresses to mint an NFT each to\n  /// @return the id of the first minted NFT\n  function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/drops/interface/IMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IMetadataRenderer {\n  function tokenURI(uint256) external view returns (string memory);\n\n  function contractURI() external view returns (string memory);\n\n  function initializeWithData(bytes memory initData) external;\n}\n"
    },
    "src/drops/interface/IOperatorFilterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IOperatorFilterRegistry {\n  function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n  function register(address registrant) external;\n\n  function registerAndSubscribe(address registrant, address subscription) external;\n\n  function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n  function updateOperator(address registrant, address operator, bool filtered) external;\n\n  function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n\n  function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n\n  function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n\n  function subscribe(address registrant, address registrantToSubscribe) external;\n\n  function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n  function subscriptionOf(address addr) external returns (address registrant);\n\n  function subscribers(address registrant) external returns (address[] memory);\n\n  function subscriberAt(address registrant, uint256 index) external returns (address);\n\n  function copyEntriesOf(address registrant, address registrantToCopy) external;\n\n  function isOperatorFiltered(address registrant, address operator) external returns (bool);\n\n  function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n\n  function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n\n  function filteredOperators(address addr) external returns (address[] memory);\n\n  function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n\n  function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n\n  function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n\n  function isRegistered(address addr) external returns (bool);\n\n  function codeHashOf(address addr) external returns (bytes32);\n\n  function unregister(address registrant) external;\n}\n"
    },
    "src/drops/library/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "src/drops/library/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary MerkleProof {\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n   * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n   * hash matches the root of the tree. When processing the proof, the pairs\n   * of leafs & pre-images are assumed to be sorted.\n   *\n   * _Available since v4.4._\n   */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n      if (computedHash <= proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = _efficientHash(computedHash, proofElement);\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = _efficientHash(proofElement, computedHash);\n      }\n    }\n    return computedHash;\n  }\n\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "src/drops/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"
    },
    "src/drops/metadata/DropsMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\n\nimport {Strings} from \"../library/Strings.sol\";\n\nimport {MetadataRenderAdminCheck} from \"./MetadataRenderAdminCheck.sol\";\n\n/// @notice Drops metadata system\ncontract DropsMetadataRenderer is Initializable, IMetadataRenderer, MetadataRenderAdminCheck {\n  error MetadataFrozen();\n\n  /// Event to mark updated metadata information\n  event MetadataUpdated(\n    address indexed target,\n    string metadataBase,\n    string metadataExtension,\n    string contractURI,\n    uint256 freezeAt\n  );\n\n  /// @notice Hash to mark updated provenance hash\n  event ProvenanceHashUpdated(address indexed target, bytes32 provenanceHash);\n\n  /// @notice Struct to store metadata info and update data\n  struct MetadataURIInfo {\n    string base;\n    string extension;\n    string contractURI;\n    uint256 freezeAt;\n  }\n\n  /// @notice NFT metadata by contract\n  mapping(address => MetadataURIInfo) public metadataBaseByContract;\n\n  /// @notice Optional provenance hashes for NFT metadata by contract\n  mapping(address => bytes32) public provenanceHashes;\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @dev A blank init function is required to be able to call genesisDeriveFutureAddress to get the deterministic address\n   * @dev Since no data is required to be intialized the selector is just returned and _setInitialized() does not need to be called\n   */\n  function init(bytes memory /* initPayload */) external pure override returns (bytes4) {\n    return Initializable.init.selector;\n  }\n\n  /// @notice Standard init for drop metadata from root drop contract\n  /// @param data passed in for initialization\n  function initializeWithData(bytes memory data) external {\n    // data format: string baseURI, string newContractURI\n    (string memory initialBaseURI, string memory initialContractURI) = abi.decode(data, (string, string));\n    _updateMetadataDetails(msg.sender, initialBaseURI, \"\", initialContractURI, 0);\n  }\n\n  /// @notice Update the provenance hash (optional) for a given nft\n  /// @param target target address to update\n  /// @param provenanceHash provenance hash to set\n  function updateProvenanceHash(address target, bytes32 provenanceHash) external requireSenderAdmin(target) {\n    provenanceHashes[target] = provenanceHash;\n    emit ProvenanceHashUpdated(target, provenanceHash);\n  }\n\n  /// @notice Update metadata base URI and contract URI\n  /// @param baseUri new base URI\n  /// @param newContractUri new contract URI (can be an empty string)\n  function updateMetadataBase(\n    address target,\n    string memory baseUri,\n    string memory newContractUri\n  ) external requireSenderAdmin(target) {\n    _updateMetadataDetails(target, baseUri, \"\", newContractUri, 0);\n  }\n\n  /// @notice Update metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing details\n  /// @param target target contract to update metadata for\n  /// @param metadataBase new base URI to update metadata with\n  /// @param metadataExtension new extension to append to base metadata URI\n  /// @param freezeAt time to freeze the contract metadata at (set to 0 to disable)\n  function updateMetadataBaseWithDetails(\n    address target,\n    string memory metadataBase,\n    string memory metadataExtension,\n    string memory newContractURI,\n    uint256 freezeAt\n  ) external requireSenderAdmin(target) {\n    _updateMetadataDetails(target, metadataBase, metadataExtension, newContractURI, freezeAt);\n  }\n\n  /// @notice Internal metadata update function\n  /// @param metadataBase Base URI to update metadata for\n  /// @param metadataExtension Extension URI to update metadata for\n  /// @param freezeAt timestamp to freeze metadata (set to 0 to disable freezing)\n  function _updateMetadataDetails(\n    address target,\n    string memory metadataBase,\n    string memory metadataExtension,\n    string memory newContractURI,\n    uint256 freezeAt\n  ) internal {\n    if (freezeAt != 0 && freezeAt > block.timestamp) {\n      revert MetadataFrozen();\n    }\n\n    metadataBaseByContract[target] = MetadataURIInfo({\n      base: metadataBase,\n      extension: metadataExtension,\n      contractURI: newContractURI,\n      freezeAt: freezeAt\n    });\n    emit MetadataUpdated({\n      target: target,\n      metadataBase: metadataBase,\n      metadataExtension: metadataExtension,\n      contractURI: newContractURI,\n      freezeAt: freezeAt\n    });\n  }\n\n  /// @notice A contract URI for the given drop contract\n  /// @dev reverts if a contract uri is not provided\n  /// @return contract uri for the contract metadata\n  function contractURI() external view override returns (string memory) {\n    string memory uri = metadataBaseByContract[msg.sender].contractURI;\n    if (bytes(uri).length == 0) revert();\n    return uri;\n  }\n\n  /// @notice A token URI for the given drops contract\n  /// @dev reverts if a contract uri is not set\n  /// @return token URI for the given token ID and contract (set by msg.sender)\n  function tokenURI(uint256 tokenId) external view override returns (string memory) {\n    MetadataURIInfo memory info = metadataBaseByContract[msg.sender];\n\n    if (bytes(info.base).length == 0) revert();\n\n    return string(abi.encodePacked(info.base, Strings.toString(tokenId), info.extension));\n  }\n}\n"
    },
    "src/drops/metadata/EditionsMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"../../abstract/Initializable.sol\";\n\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\nimport {IHolographDropERC721} from \"../interface/IHolographDropERC721.sol\";\nimport {ERC721Metadata} from \"../../interface/ERC721Metadata.sol\";\nimport {NFTMetadataRenderer} from \"../utils/NFTMetadataRenderer.sol\";\nimport {MetadataRenderAdminCheck} from \"./MetadataRenderAdminCheck.sol\";\n\nimport {Configuration} from \"../struct/Configuration.sol\";\n\ninterface DropConfigGetter {\n  function config() external view returns (Configuration memory config);\n}\n\n/// @notice EditionsMetadataRenderer for editions support\ncontract EditionsMetadataRenderer is Initializable, IMetadataRenderer, MetadataRenderAdminCheck {\n  /// @notice Storage for token edition information\n  struct TokenEditionInfo {\n    string description;\n    string imageURI;\n    string animationURI;\n  }\n\n  /// @notice Event for updated Media URIs\n  event MediaURIsUpdated(address indexed target, address sender, string imageURI, string animationURI);\n\n  /// @notice Event for a new edition initialized\n  /// @dev admin function indexer feedback\n  event EditionInitialized(address indexed target, string description, string imageURI, string animationURI);\n\n  /// @notice Description updated for this edition\n  /// @dev admin function indexer feedback\n  event DescriptionUpdated(address indexed target, address sender, string newDescription);\n\n  /// @notice Token information mapping storage\n  mapping(address => TokenEditionInfo) public tokenInfos;\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @dev A blank init function is required to be able to call genesisDeriveFutureAddress to get the deterministic address\n   * @dev Since no data is required to be intialized the selector is just returned and _setInitialized() does not need to be called\n   */\n  function init(bytes memory /* initPayload */) external pure override returns (bytes4) {\n    return InitializableInterface.init.selector;\n  }\n\n  /// @notice Update media URIs\n  /// @param target target for contract to update metadata for\n  /// @param imageURI new image uri address\n  /// @param animationURI new animation uri address\n  function updateMediaURIs(\n    address target,\n    string memory imageURI,\n    string memory animationURI\n  ) external requireSenderAdmin(target) {\n    tokenInfos[target].imageURI = imageURI;\n    tokenInfos[target].animationURI = animationURI;\n    emit MediaURIsUpdated({target: target, sender: msg.sender, imageURI: imageURI, animationURI: animationURI});\n  }\n\n  /// @notice Admin function to update description\n  /// @param target target description\n  /// @param newDescription new description\n  function updateDescription(address target, string memory newDescription) external requireSenderAdmin(target) {\n    tokenInfos[target].description = newDescription;\n\n    emit DescriptionUpdated({target: target, sender: msg.sender, newDescription: newDescription});\n  }\n\n  /// @notice Default initializer for edition data from a specific contract\n  /// @param data data to init with\n  function initializeWithData(bytes memory data) external {\n    // data format: description, imageURI, animationURI\n    (string memory description, string memory imageURI, string memory animationURI) = abi.decode(\n      data,\n      (string, string, string)\n    );\n\n    tokenInfos[msg.sender] = TokenEditionInfo({\n      description: description,\n      imageURI: imageURI,\n      animationURI: animationURI\n    });\n    emit EditionInitialized({\n      target: msg.sender,\n      description: description,\n      imageURI: imageURI,\n      animationURI: animationURI\n    });\n  }\n\n  /// @notice Contract URI information getter\n  /// @return contract uri (if set)\n  function contractURI() external view override returns (string memory) {\n    address target = msg.sender;\n    TokenEditionInfo storage editionInfo = tokenInfos[target];\n    Configuration memory config = DropConfigGetter(target).config();\n\n    return\n      NFTMetadataRenderer.encodeContractURIJSON({\n        name: ERC721Metadata(target).name(),\n        description: editionInfo.description,\n        imageURI: editionInfo.imageURI,\n        animationURI: editionInfo.animationURI,\n        royaltyBPS: uint256(config.royaltyBPS),\n        royaltyRecipient: config.fundsRecipient\n      });\n  }\n\n  /// @notice Token URI information getter\n  /// @param tokenId to get uri for\n  /// @return contract uri (if set)\n  function tokenURI(uint256 tokenId) external view override returns (string memory) {\n    address target = msg.sender;\n\n    TokenEditionInfo memory info = tokenInfos[target];\n    IHolographDropERC721 media = IHolographDropERC721(target);\n\n    uint256 maxSupply = media.saleDetails().maxSupply;\n\n    // For open editions, set max supply to 0 for renderer to remove the edition max number\n    // This will be added back on once the open edition is \"finalized\"\n    if (maxSupply == type(uint64).max) {\n      maxSupply = 0;\n    }\n\n    return\n      NFTMetadataRenderer.createMetadataEdition({\n        name: ERC721Metadata(target).name(),\n        description: info.description,\n        imageURI: info.imageURI,\n        animationURI: info.animationURI,\n        tokenOfEdition: tokenId,\n        editionSize: maxSupply\n      });\n  }\n}\n"
    },
    "src/drops/metadata/MetadataRenderAdminCheck.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IHolographDropERC721} from \"../interface/IHolographDropERC721.sol\";\n\ncontract MetadataRenderAdminCheck {\n  error Access_OnlyAdmin();\n\n  /// @notice Modifier to require the sender to be an admin\n  /// @param target address that the user wants to modify\n  modifier requireSenderAdmin(address target) {\n    if (target != msg.sender && !IHolographDropERC721(target).isAdmin(msg.sender)) {\n      revert Access_OnlyAdmin();\n    }\n\n    _;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleArbitrumNova.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleArbitrumNova is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0x0000000000000000000000000000000000000000; // 18 decimals\n  address constant USDC = 0x0000000000000000000000000000000000000000; // 6 decimals\n  address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdcPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdtPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = UniV2UsdcPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = UniV2UsdtPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleArbitrumOne.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleArbitrumOne is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1; // 18 decimals\n  address constant USDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8; // 6 decimals\n  address constant USDT = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x905dfCD5649217c42684f23958568e533C711Aa3);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0xCB0E5bFa72bBb4d16AB5aA0c60601c438F04b4ad);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    weiAmount = (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount)) / 2;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdcPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdtPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleArbitrumTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleArbitrumTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n  // TODO: add correct addresses for Sepolia. These might not all be available at the moment so they're hardcoded values from Goerli\n  //   address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n  //   address constant USDC = 0x8267cF9254734C6Eb452a7bb9AAF97B392258b21; // 6 decimals\n  //   address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  //   IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  //   IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  //   IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  //   IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleAvalanche.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {ILBPair} from \"./interface/ILBPair.sol\";\nimport {ILBRouter} from \"./interface/ILBRouter.sol\";\n\ncontract DropsPriceOracleAvalanche is Admin, Initializable, IDropsPriceOracle {\n  address constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7; // 18 decimals\n  address constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E; // 6 decimals\n  address constant USDT = 0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7; // 6 decimals\n\n  ILBRouter constant TraderJoeRouter = ILBRouter(0xb4315e873dBcf96Ffd0acd8EA43f689D8c20fB30);\n  ILBPair constant TraderJoeUsdcPool = ILBPair(0xD446eb1660F766d533BeCeEf890Df7A69d26f7d1);\n  ILBPair constant TraderJoeUsdtPool = ILBPair(0x87EB2F90d7D0034571f343fb7429AE22C1Bd9F72);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    if (usdAmount == 0) {\n      weiAmount = 0;\n      return weiAmount;\n    }\n    weiAmount = (_getTraderJoeUSDC(usdAmount) + _getTraderJoeUSDT(usdAmount)) / 2;\n  }\n\n  function _getTraderJoeUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint128 amountIn, uint128 amountOutLeft, uint128 fee) = TraderJoeRouter.getSwapIn(\n      TraderJoeUsdcPool,\n      uint128(usdAmount),\n      true\n    );\n    weiAmount = amountIn + fee;\n  }\n\n  function _getTraderJoeUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint128 amountIn, uint128 amountOutLeft, uint128 fee) = TraderJoeRouter.getSwapIn(\n      TraderJoeUsdtPool,\n      uint128(usdAmount),\n      true\n    );\n    weiAmount = amountIn + fee;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleAvalancheTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleAvalancheTestnet is Admin, Initializable, IDropsPriceOracle {\n  address constant WAVAX = 0xd00ae08403B9bbb9124bB305C09058E32C39A48c;\n  address constant USDC = 0x5425890298aed601595a70AB815c96711a31Bc65; // 6 decimals\n  address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x1B92bf7394d317A758d953F6428445A8977e195C);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount)) / 2;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 133224784402692878349;\n    uint112 _reserve1 = 2205199060;\n    // x is always native token / WAVAX\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 2205199060;\n    uint112 _reserve1 = 133224784402692878349;\n    // x is always native token / WAVAX\n    uint256 x = _reserve1;\n    // y is always USD token / USDT\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\nimport {IQuoterV2} from \"../../interface/IQuoterV2.sol\";\n\ncontract DropsPriceOracleBase is Admin, Initializable {\n  IQuoterV2 public quoterV2; // Immutable reference to the Quoter V2 interface\n\n  address public constant WETH9 = 0x4200000000000000000000000000000000000006; // WETH address on Base mainnet\n  address public constant USDC = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913; // USDC address on Base mainnet\n\n  // Set the pool fee to 0.3% (the lowest option)\n  uint24 public constant poolFee = 3000;\n\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function setQuoter(IQuoterV2 _quoterV2) public onlyAdmin {\n    quoterV2 = _quoterV2;\n  }\n\n  /**\n   * @notice Converts USDC value to native gas token value in wei\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount in USDC (6 decimal places)\n   */\n  function convertUsdToWei(uint256 usdAmount) external returns (uint256 weiAmount) {\n    require(address(quoterV2) != address(0), \"Quoter not set\");\n    IQuoterV2.QuoteExactOutputSingleParams memory params = IQuoterV2.QuoteExactOutputSingleParams({\n      tokenIn: WETH9, // WETH address\n      tokenOut: USDC, // USDC address\n      fee: poolFee, // Representing 0.3% pool fee\n      amount: usdAmount, // USDC (USDC has 6 decimals)\n      sqrtPriceLimitX96: 0 // No specific price limit\n    });\n\n    (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate) = quoterV2\n      .quoteExactOutputSingle(params);\n\n    return amountIn; // this is the amount in wei to convert to the USDC value\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBaseTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\nimport {IQuoterV2} from \"../../interface/IQuoterV2.sol\";\n\ncontract DropsPriceOracleBaseTestnetSepolia is Admin, Initializable {\n  IQuoterV2 public quoterV2; // Immutable reference to the Quoter V2 interface\n\n  address public constant WETH9 = 0x4200000000000000000000000000000000000006; // WETH address on Base Sepolia testnet\n  address public constant USDC = 0x036CbD53842c5426634e7929541eC2318f3dCF7e; // USDC address on Base Sepolia testnet\n\n  // Set the pool fee to 0.05% (the lowest option)\n  uint24 public constant poolFee = 500;\n\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function setQuoter(address _quoterV2Address) public onlyAdmin {\n    quoterV2 = IQuoterV2(_quoterV2Address);\n  }\n\n  /**\n   * @notice Converts USDC value to native gas token value in wei\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount in USDC (6 decimal places)\n   */\n  function convertUsdToWei(uint256 usdAmount) external returns (uint256 weiAmount) {\n    // NOTE: The following code is commented out because the QuoterV2 contract is not properly wired up to a functional Uniswap V3 pool on the Sepolia testnet\n    // require(address(quoterV2) != address(0), \"Quoter not set\");\n    // IQuoterV2.QuoteExactOutputSingleParams memory params = IQuoterV2.QuoteExactOutputSingleParams({\n    //   tokenIn: WETH9, // WETH address\n    //   tokenOut: USDC, // USDC address\n    //   fee: poolFee, // Representing 0.05% pool fee\n    //   amount: usdAmount, // USDC (USDC has 6 decimals)\n    //   sqrtPriceLimitX96: 0 // No specific price limit\n    // });\n    // (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate) = quoterV2\n    //   .quoteExactOutputSingle(params);\n    // return amountIn; // this is the amount in wei to convert to the USDC value\n    weiAmount = 3097578139223040;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBinanceSmartChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleBinanceSmartChain is Admin, Initializable, IDropsPriceOracle {\n  address constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n  address constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d; // 18 decimals\n  address constant USDT = 0x55d398326f99059fF775485246999027B3197955; // 18 decimals\n  address constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // 18 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0xc7632B7b2d768bbb30a404E13E1dE48d1439ec21);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x2905817b020fD35D9d09672946362b62766f0d69);\n  IUniswapV2Pair constant SushiV2BusdPool = IUniswapV2Pair(0xDc558D64c29721d74C4456CfB4363a6e6660A9Bb);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    weiAmount = (_getUSDC(usdAmount) + _getUSDT(usdAmount) + _getBUSD(usdAmount)) / 3;\n  }\n\n  function _getUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdcPool.getReserves();\n    // x is always native token / WBNB\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdtPool.getReserves();\n    // x is always native token / WBNB\n    uint256 x = _reserve1;\n    // y is always USD token / USDT\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getBUSD(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2BusdPool.getReserves();\n    // x is always native token / WBNB\n    uint256 x = _reserve0;\n    // y is always USD token / BUSD\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBinanceSmartChainTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleBinanceSmartChainTestnet is Admin, Initializable, IDropsPriceOracle {\n  address constant WBNB = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\n  address constant USDC = 0x0000000000000000000000000000000000000000; // 18 decimals\n  address constant USDT = 0x337610d27c682E347C9cD60BD4b3b107C9d34dDd; // 18 decimals\n  address constant BUSD = 0xeD24FC36d5Ee211Ea25A80239Fb8C4Cfd80f12Ee; // 18 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x622A814A1c842D34F9828370d9015Dc9d4c5b6F1);\n  IUniswapV2Pair constant SushiV2BusdPool = IUniswapV2Pair(0x9A0eeceDA5c0203924484F5467cEE4321cf6A189);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = (_getUSDC(usdAmount) + _getUSDT(usdAmount) + _getBUSD(usdAmount)) / 3;\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 13021882855694508203763;\n    uint112 _reserve1 = 40694382259814793835;\n    // x is always native token / WBNB\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 27194218672878436248359;\n    uint112 _reserve1 = 85236077287017749564;\n    // x is always native token / WBNB\n    uint256 x = _reserve1;\n    // y is always USD token / USDT\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getBUSD(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2BusdPool.getReserves();\n    uint112 _reserve0 = 18888866298338593382;\n    uint112 _reserve1 = 6055244885106491861952;\n    // x is always native token / WBNB\n    uint256 x = _reserve0;\n    // y is always USD token / BUSD\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleEthereum.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleEthereum is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // 18 decimals\n  address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // 6 decimals\n  address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n  IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdcPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdtPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = UniV2UsdcPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = UniV2UsdtPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleEthereumTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleEthereumTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n  // TODO: add correct addresses for Sepolia. These might not all be available at the moment so they're hardcoded values from Goerli\n  //   address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n  //   address constant USDC = 0x8267cF9254734C6Eb452a7bb9AAF97B392258b21; // 6 decimals\n  //   address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  //   IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  //   IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  //   IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  //   IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleLinea.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleLinea is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   */\n  // NOTE: Temporararily return a static value while a USDC / WETH pool is not available on Linea\n  //       Keep the usdAmount parameter to match the interface\n  // solhint-disable-next-line no-unused-vars\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = _returnStaticUSDC();\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 185186616552407552407157;\n    uint112 _reserve1 = 207981749778;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 13799757434002573084810;\n    uint112 _reserve1 = 15484391886;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _returnStaticUSDC() internal pure returns (uint256 weiAmount) {\n    weiAmount = 300000000000000;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleLineaTestnetGoerli.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleLineaTestnetGoerli is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   */\n  // NOTE: Temporararily return a static value while a USDC / WETH pool is not available on Linea\n  //       Keep the usdAmount parameter to match the interface\n  // solhint-disable-next-line no-unused-vars\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = _returnStaticUSDC();\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 185186616552407552407157;\n    uint112 _reserve1 = 207981749778;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 13799757434002573084810;\n    uint112 _reserve1 = 15484391886;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _returnStaticUSDC() internal pure returns (uint256 weiAmount) {\n    weiAmount = 300000000000000;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleLineaTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleLineaTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   */\n  // NOTE: Temporararily return a static value while a USDC / WETH pool is not available on Linea\n  //       Keep the usdAmount parameter to match the interface\n  // solhint-disable-next-line no-unused-vars\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = _returnStaticUSDC();\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 185186616552407552407157;\n    uint112 _reserve1 = 207981749778;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 13799757434002573084810;\n    uint112 _reserve1 = 15484391886;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _returnStaticUSDC() internal pure returns (uint256 weiAmount) {\n    weiAmount = 300000000000000;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleMantle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleMantle is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.tokenPriceRatio')) - 1)\n   */\n  bytes32 constant _tokenPriceRatioSlot = 0x562ce994878444f1ca8bcf3afcea513b950965abed659462312e8fdd38c020a1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_tokenPriceRatioSlot, 0x00000000000000000000000000000000000000000000000009B6E64A8EC60000)\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    // USD is with 6 decimal places\n    // MNT is with 18 decimal places\n    // we add decimal places for USD to match MNT decimals\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // x is always native token / WMNT\n    // we use precision of 21\n    uint256 x = 1000000000000000000 * (10 ** 21);\n    // y is always USD token / USDC\n    // load token price ratio\n    uint256 tokenPriceRatio;\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n    // in our case, we use ratio for defining USD cost of 1 MNT\n    // we use precision of 21\n    uint256 y = tokenPriceRatio * (10 ** 21);\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 1000;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function getTokenPriceRatio() external view returns (uint256 tokenPriceRatio) {\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n  }\n\n  function setTokenPriceRatio(uint256 tokenPriceRatio) external onlyAdmin {\n    assembly {\n      sstore(_tokenPriceRatioSlot, tokenPriceRatio)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleMantleTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleMantleTestnet is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.tokenPriceRatio')) - 1)\n   */\n  bytes32 constant _tokenPriceRatioSlot = 0x562ce994878444f1ca8bcf3afcea513b950965abed659462312e8fdd38c020a1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_tokenPriceRatioSlot, 0x0000000000000000000000000000000000000000000000000de0b6b3a7640000)\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    // USD is with 6 decimal places\n    // MNT is with 18 decimal places\n    // we add decimal places for USD to match MNT decimals\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // x is always native token / WMNT\n    // we use precision of 21\n    uint256 x = 1000000000000000000 * (10 ** 21);\n    // y is always USD token / USDC\n    // load token price ratio\n    uint256 tokenPriceRatio;\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n    // in our case, we use ratio for defining USD cost of 1 MNT\n    // we use precision of 21\n    uint256 y = tokenPriceRatio * (10 ** 21);\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 1000;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function getTokenPriceRatio() external view returns (uint256 tokenPriceRatio) {\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n  }\n\n  function setTokenPriceRatio(uint256 tokenPriceRatio) external onlyAdmin {\n    assembly {\n      sstore(_tokenPriceRatioSlot, tokenPriceRatio)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleOptimism.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleOptimism is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0x4200000000000000000000000000000000000006; // 18 decimals\n  address constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x7086622E6Db990385B102D79CB1218947fb549a9);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    weiAmount = _getSushiUSDC(usdAmount);\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdcPool.getReserves();\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleOptimismTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleOptimismTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n  // TODO: add correct addresses for Sepolia. These might not all be available at the moment so they're hardcoded values from Goerli\n  //   address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n  //   address constant USDC = 0x8267cF9254734C6Eb452a7bb9AAF97B392258b21; // 6 decimals\n  //   address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  //   IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  //   IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  //   IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  //   IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOraclePolygon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOraclePolygon is Admin, Initializable, IDropsPriceOracle {\n  address constant WMATIC = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270; // 18 decimals\n  address constant USDC = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174; // 6 decimals\n  address constant USDT = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0xcd353F79d9FADe311fC3119B841e1f456b54e858);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x55FF76BFFC3Cdd9D5FdbBC2ece4528ECcE45047e);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    weiAmount = (_getUSDC(usdAmount) + _getUSDT(usdAmount)) / 2;\n  }\n\n  function _getUSDC(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdcPool.getReserves();\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal view returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    (uint112 _reserve0, uint112 _reserve1, ) = SushiV2UsdtPool.getReserves();\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOraclePolygonTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOraclePolygonTestnet is Admin, Initializable, IDropsPriceOracle {\n  address constant WMATIC = 0x5B67676a984807a212b1c59eBFc9B3568a474F0a; // 18 decimals\n  address constant USDC = 0x742DfA5Aa70a8212857966D491D67B09Ce7D6ec7; // 6 decimals\n  address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x412D4b3C56836ff78F1C8197c6718A6DFf3702F5);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = (_getUSDC(usdAmount) + _getUSDT(usdAmount)) / 2;\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 185186616552407552407159;\n    uint112 _reserve1 = 207981749778;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 13799757434002573084812;\n    uint112 _reserve1 = 15484391886;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleZora.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleZora is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.tokenPriceRatio')) - 1)\n   */\n  bytes32 constant _tokenPriceRatioSlot = 0x562ce994878444f1ca8bcf3afcea513b950965abed659462312e8fdd38c020a1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_tokenPriceRatioSlot, 0x0000000000000000000000000000000000000000000000878678326eac900000)\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    // USD is with 6 decimal places\n    // WETH  is with 18 decimal places\n    // we add decimal places for USD to match WETH  decimals\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // x is always native token / WETH\n    // we use precision of 21\n    uint256 x = 1000000000000000000 * (10 ** 21);\n    // y is always USD token / USDC\n    // load token price ratio\n    uint256 tokenPriceRatio;\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n    // in our case, we use ratio for defining USD cost of 1 WETH\n    // we use precision of 21\n    uint256 y = tokenPriceRatio * (10 ** 21);\n\n    uint256 numerator = x * usdAmount;\n    uint256 denominator = y - usdAmount;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function getTokenPriceRatio() external view returns (uint256 tokenPriceRatio) {\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n  }\n\n  function setTokenPriceRatio(uint256 tokenPriceRatio) external onlyAdmin {\n    assembly {\n      sstore(_tokenPriceRatioSlot, tokenPriceRatio)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleZoraTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleZoraTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = (_getUSDC(usdAmount) + _getUSDT(usdAmount)) / 2;\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 185186616552407552407157;\n    uint112 _reserve1 = 207981749778;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 13799757434002573084810;\n    uint112 _reserve1 = 15484391886;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DummyDropsPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DummyDropsPriceOracle is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    uint112 _reserve0 = 8237558200010903232972;\n    uint112 _reserve1 = 14248413024234;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/interface/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface ILBPair {\n  function tokenX() external view returns (address);\n\n  function tokenY() external view returns (address);\n\n  function getReservesAndId() external view returns (uint256 reserveX, uint256 reserveY, uint256 activeId);\n}\n"
    },
    "src/drops/oracle/interface/ILBRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {ILBPair} from \"./ILBPair.sol\";\n\ninterface ILBRouter {\n  function getSwapIn(\n    ILBPair LBPair,\n    uint128 amountOut,\n    bool swapForY\n  ) external view returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n}\n"
    },
    "src/drops/oracle/interface/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "src/drops/oracle/interface/IUniswapV3Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n\ninterface IUniswapV3PoolState {\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n  /// boundary.\n  /// observationIndex The index of the last oracle observation that was written,\n  /// observationCardinality The current maximum number of observations stored in the pool,\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// feeProtocol The protocol fee for both tokens of the pool.\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n  /// unlocked Whether the pool is currently locked to reentrancy\n  function slot0()\n    external\n    view\n    returns (\n      uint160 sqrtPriceX96,\n      int24 tick,\n      uint16 observationIndex,\n      uint16 observationCardinality,\n      uint16 observationCardinalityNext,\n      uint8 feeProtocol,\n      bool unlocked\n    );\n\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal0X128() external view returns (uint256);\n\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal1X128() external view returns (uint256);\n\n  /// @notice The amounts of token0 and token1 that are owed to the protocol\n  /// @dev Protocol fees will never exceed uint128 max in either token\n  function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n  /// @notice The currently in range liquidity available to the pool\n  /// @dev This value has no relationship to the total liquidity across all ticks\n  function liquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n  /// tick upper,\n  /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n  /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n  /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n  /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n  /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n  /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n  /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n  /// a specific position.\n  function ticks(\n    int24 tick\n  )\n    external\n    view\n    returns (\n      uint128 liquidityGross,\n      int128 liquidityNet,\n      uint256 feeGrowthOutside0X128,\n      uint256 feeGrowthOutside1X128,\n      int56 tickCumulativeOutside,\n      uint160 secondsPerLiquidityOutsideX128,\n      uint32 secondsOutside,\n      bool initialized\n    );\n\n  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n  /// @return _liquidity The amount of liquidity in the position,\n  /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n  /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n  /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n  /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n  function positions(\n    bytes32 key\n  )\n    external\n    view\n    returns (\n      uint128 _liquidity,\n      uint256 feeGrowthInside0LastX128,\n      uint256 feeGrowthInside1LastX128,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    );\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function observations(\n    uint256 index\n  )\n    external\n    view\n    returns (uint32 blockTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, bool initialized);\n}\n\ninterface IUniswapV3PoolDerivedState {\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(\n    uint32[] calldata secondsAgos\n  ) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n  /// snapshot is taken and the second snapshot is taken.\n  /// @param tickLower The lower tick of the range\n  /// @param tickUpper The upper tick of the range\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\n  function snapshotCumulativesInside(\n    int24 tickLower,\n    int24 tickUpper\n  ) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside);\n}\n\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n\ninterface IUniswapV3PoolOwnerActions {\n  /// @notice Set the denominator of the protocol's % share of the fees\n  /// @param feeProtocol0 new protocol fee for token0 of the pool\n  /// @param feeProtocol1 new protocol fee for token1 of the pool\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n  /// @notice Collect the protocol fee accrued to the pool\n  /// @param recipient The address to which collected protocol fees should be sent\n  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n  /// @return amount0 The protocol fee collected in token0\n  /// @return amount1 The protocol fee collected in token1\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n}\n\ninterface IUniswapV3PoolEvents {\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @param sender The address that minted the liquidity\n  /// @param owner The owner of the position and recipient of any minted liquidity\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity minted to the position range\n  /// @param amount0 How much token0 was required for the minted liquidity\n  /// @param amount1 How much token1 was required for the minted liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when fees are collected by the owner of a position\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n  /// @param owner The owner of the position for which fees are collected\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount0 The amount of token0 fees collected\n  /// @param amount1 The amount of token1 fees collected\n  event Collect(\n    address indexed owner,\n    address recipient,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount0,\n    uint128 amount1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n  /// @param owner The owner of the position for which liquidity is removed\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity to remove\n  /// @param amount0 The amount of token0 withdrawn\n  /// @param amount1 The amount of token1 withdrawn\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted by the pool for any swaps between token0 and token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the output of the swap\n  /// @param amount0 The delta of the token0 balance of the pool\n  /// @param amount1 The delta of the token1 balance of the pool\n  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param liquidity The liquidity of the pool after the swap\n  /// @param tick The log base 1.0001 of price of the pool after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 amount0,\n    int256 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick\n  );\n\n  /// @notice Emitted by the pool for any flashes of token0/token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the tokens from flash\n  /// @param amount0 The amount of token0 that was flashed\n  /// @param amount1 The amount of token1 that was flashed\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 paid0,\n    uint256 paid1\n  );\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew);\n\n  /// @notice Emitted when the protocol fee is changed by the pool\n  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n  /// @param feeProtocol0New The updated value of the token0 protocol fee\n  /// @param feeProtocol1New The updated value of the token1 protocol fee\n  event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n  /// @param sender The address that collects the protocol fees\n  /// @param recipient The address that receives the collected protocol fees\n  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n  event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n\ninterface IUniswapV3Pool is\n  IUniswapV3PoolImmutables,\n  IUniswapV3PoolState,\n  IUniswapV3PoolDerivedState,\n  IUniswapV3PoolActions,\n  IUniswapV3PoolOwnerActions,\n  IUniswapV3PoolEvents\n{}\n\ninterface IUniswapV3Pair is IUniswapV3Pool {}\n"
    },
    "src/drops/oracle/interface/IUniswapV3Quoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IUniswapV3Quoter {\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\n  /// @param amountIn The amount of the first token to swap\n  /// @return amountOut The amount of the last token that would be received\n  function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n  /// @param tokenIn The token being swapped in\n  /// @param tokenOut The token being swapped out\n  /// @param fee The fee of the token pool to consider for the pair\n  /// @param amountIn The desired input amount\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  /// @return amountOut The amount of `tokenOut` that would be received\n  function quoteExactInputSingle(\n    address tokenIn,\n    address tokenOut,\n    uint24 fee,\n    uint256 amountIn,\n    uint160 sqrtPriceLimitX96\n  ) external returns (uint256 amountOut);\n\n  /// @notice Returns the amount in required for a given exact output swap without executing the swap\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\n  /// @param amountOut The amount of the last token to receive\n  /// @return amountIn The amount of first token required to be paid\n  function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n  /// @param tokenIn The token being swapped in\n  /// @param tokenOut The token being swapped out\n  /// @param fee The fee of the token pool to consider for the pair\n  /// @param amountOut The desired output amount\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n  function quoteExactOutputSingle(\n    address tokenIn,\n    address tokenOut,\n    uint24 fee,\n    uint256 amountOut,\n    uint160 sqrtPriceLimitX96\n  ) external returns (uint256 amountIn);\n}\n"
    },
    "src/drops/proxy/DropsMetadataRendererProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../../abstract/Admin.sol\";\nimport \"../../abstract/Initializable.sol\";\n\ncontract DropsMetadataRendererProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.dropsMetadataRenderer')) - 1)\n   */\n  bytes32 constant _dropsMetadataRendererSlot = 0xe1d18664c68b1eedd4e2fc65b2d42097f2cd8cd4c2f1a9a6418986c9f5da3817;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address dropsMetadataRenderer, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_dropsMetadataRendererSlot, dropsMetadataRenderer)\n    }\n    (bool success, bytes memory returnData) = dropsMetadataRenderer.delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getDropsMetadataRenderer() external view returns (address dropsMetadataRenderer) {\n    assembly {\n      dropsMetadataRenderer := sload(_dropsMetadataRendererSlot)\n    }\n  }\n\n  function setDropsMetadataRenderer(address dropsMetadataRenderer) external onlyAdmin {\n    assembly {\n      sstore(_dropsMetadataRendererSlot, dropsMetadataRenderer)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let dropsMetadataRenderer := sload(_dropsMetadataRendererSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), dropsMetadataRenderer, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/drops/proxy/DropsPriceOracleProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../../abstract/Admin.sol\";\nimport \"../../abstract/Initializable.sol\";\n\ncontract DropsPriceOracleProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.dropsPriceOracle')) - 1)\n   */\n  bytes32 constant _dropsPriceOracleSlot = 0x26600f0171e5a2b86874be26285c66444b2a6fa5f62114757214d5e732aded36;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address dropsPriceOracle, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_dropsPriceOracleSlot, dropsPriceOracle)\n    }\n    (bool success, bytes memory returnData) = dropsPriceOracle.delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getDropsPriceOracle() external view returns (address dropsPriceOracle) {\n    assembly {\n      dropsPriceOracle := sload(_dropsPriceOracleSlot)\n    }\n  }\n\n  function setDropsPriceOracle(address dropsPriceOracle) external onlyAdmin {\n    assembly {\n      sstore(_dropsPriceOracleSlot, dropsPriceOracle)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let dropsPriceOracle := sload(_dropsPriceOracleSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), dropsPriceOracle, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/drops/proxy/EditionsMetadataRendererProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../../abstract/Admin.sol\";\nimport \"../../abstract/Initializable.sol\";\n\ncontract EditionsMetadataRendererProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.editionsMetadataRenderer')) - 1)\n   */\n  bytes32 constant _editionsMetadataRendererSlot = 0x747f2428bc473d14fd9642872693b7bc7ad3f58057c4c084ce1f541a26e4bcb1;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address editionsMetadataRenderer, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_editionsMetadataRendererSlot, editionsMetadataRenderer)\n    }\n    (bool success, bytes memory returnData) = editionsMetadataRenderer.delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getEditionsMetadataRenderer() external view returns (address editionsMetadataRenderer) {\n    assembly {\n      editionsMetadataRenderer := sload(_editionsMetadataRendererSlot)\n    }\n  }\n\n  function setEditionsMetadataRenderer(address editionsMetadataRenderer) external onlyAdmin {\n    assembly {\n      sstore(_editionsMetadataRendererSlot, editionsMetadataRenderer)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let editionsMetadataRenderer := sload(_editionsMetadataRendererSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), editionsMetadataRenderer, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/drops/proxy/HolographDropERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../../abstract/Admin.sol\";\nimport \"../../abstract/Initializable.sol\";\n\nimport \"../../interface/HolographRegistryInterface.sol\";\n\ncontract HolographDropERC721Proxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (bytes32 contractType, address registry, bytes memory initCode) = abi.decode(data, (bytes32, address, bytes));\n    assembly {\n      sstore(_contractTypeSlot, contractType)\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = getHolographDropERC721Source().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getHolographDropERC721Source() public view returns (address) {\n    HolographRegistryInterface registry;\n    bytes32 contractType;\n    assembly {\n      registry := sload(_registrySlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return registry.getContractTypeAddress(contractType);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    address HolographDropERC721Source = getHolographDropERC721Source();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), HolographDropERC721Source, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/drops/struct/AddressMintDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return type of specific mint counts and details per address\nstruct AddressMintDetails {\n  /// Number of total mints from the given address\n  uint256 totalMints;\n  /// Number of presale mints from the given address\n  uint256 presaleMints;\n  /// Number of public mints from the given address\n  uint256 publicMints;\n}\n"
    },
    "src/drops/struct/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\n\n/// @notice General configuration for NFT Minting and bookkeeping\nstruct Configuration {\n  /// @dev Metadata renderer (uint160)\n  IMetadataRenderer metadataRenderer;\n  /// @dev Total size of edition that can be minted (uint160+64 = 224)\n  uint64 editionSize;\n  /// @dev Royalty amount in bps (uint224+16 = 240)\n  uint16 royaltyBPS;\n  /// @dev Funds recipient for sale (new slot, uint160)\n  address payable fundsRecipient;\n}\n"
    },
    "src/drops/struct/DropsInitializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {SalesConfiguration} from \"./SalesConfiguration.sol\";\n\n/// @param erc721TransferHelper Transfer helper contract\n/// @param marketFilterAddress Market filter address - Manage subscription to the for marketplace filtering based off royalty payouts.\n/// @param initialOwner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\n/// @param fundsRecipient Wallet/user that receives funds from sale\n/// @param editionSize Number of editions that can be minted in total. If type(uint64).max, unlimited editions can be minted as an open edition.\n/// @param royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\n/// @param salesConfiguration The initial SalesConfiguration\n/// @param metadataRenderer Renderer contract to use\n/// @param metadataRendererInit Renderer data initial contract\nstruct DropsInitializer {\n  address erc721TransferHelper;\n  address marketFilterAddress;\n  address initialOwner;\n  address payable fundsRecipient;\n  uint64 editionSize;\n  uint16 royaltyBPS;\n  bool enableOpenSeaRoyaltyRegistry;\n  SalesConfiguration salesConfiguration;\n  address metadataRenderer;\n  bytes metadataRendererInit;\n}\n"
    },
    "src/drops/struct/DropsInitializerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {SalesConfiguration} from \"./SalesConfiguration.sol\";\n\n/// @param initialOwner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\n/// @param fundsRecipient Wallet/user that receives funds from sale\n/// @param editionSize Number of editions that can be minted in total. If type(uint64).max, unlimited editions can be minted as an open edition.\n/// @param royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\n/// @param salesConfiguration The initial SalesConfiguration\n/// @param metadataRenderer Renderer contract to use\n/// @param metadataRendererInit Renderer data initial contract\nstruct DropsInitializerV2 {\n  address initialOwner;\n  address payable fundsRecipient;\n  uint64 editionSize;\n  uint16 royaltyBPS;\n  SalesConfiguration salesConfiguration;\n  address metadataRenderer;\n  bytes metadataRendererInit;\n}\n"
    },
    "src/drops/struct/SaleDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return value for sales details to use with front-ends\nstruct SaleDetails {\n  // Synthesized status variables for sale and presale\n  bool publicSaleActive;\n  bool presaleActive;\n  // Price for public sale\n  uint256 publicSalePrice;\n  // Timed sale actions for public sale\n  uint64 publicSaleStart;\n  uint64 publicSaleEnd;\n  // Timed sale actions for presale\n  uint64 presaleStart;\n  uint64 presaleEnd;\n  // Merkle root (includes address, quantity, and price data for each entry)\n  bytes32 presaleMerkleRoot;\n  // Limit public sale to a specific number of mints per wallet\n  uint256 maxSalePurchasePerAddress;\n  // Information about the rest of the supply\n  // Total that have been minted\n  uint256 totalMinted;\n  // The total supply available\n  uint256 maxSupply;\n}\n"
    },
    "src/drops/struct/SalesConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Sales states and configuration (Can be set by the owner)\n/// @dev Uses 3 storage slots\nstruct SalesConfiguration {\n  /// @dev Public sale price (max ether value > 1000 ether with this value)\n  uint104 publicSalePrice;\n  /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n  /// @dev Max purchase number per txn (90+32 = 122)\n  uint32 maxSalePurchasePerAddress;\n  /// @dev uint64 type allows for dates into 292 billion years\n  /// @notice Public sale start timestamp (136+64 = 186)\n  uint64 publicSaleStart;\n  /// @notice Public sale end timestamp (186+64 = 250)\n  uint64 publicSaleEnd;\n  /// @notice Presale start timestamp\n  /// @dev new storage slot\n  uint64 presaleStart;\n  /// @notice Presale end timestamp\n  uint64 presaleEnd;\n  /// @notice Presale merkle root\n  bytes32 presaleMerkleRoot;\n}\n"
    },
    "src/drops/token/HolographDropERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../../abstract/NonReentrant.sol\";\n\nimport {HolographERC721Interface} from \"../../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../../interface/HolographInterface.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {Configuration} from \"../struct/Configuration.sol\";\nimport {DropsInitializer} from \"../struct/DropsInitializer.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\nimport {SalesConfiguration} from \"../struct/SalesConfiguration.sol\";\n\nimport {Address} from \"../library/Address.sol\";\nimport {MerkleProof} from \"../library/MerkleProof.sol\";\n\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\nimport {IOperatorFilterRegistry} from \"../interface/IOperatorFilterRegistry.sol\";\nimport {IHolographDropERC721} from \"../interface/IHolographDropERC721.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - beforeSafeTransfer\n *       - beforeTransfer\n *       - onIsApprovedForAll\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified your source code for them.\n */\ncontract HolographDropERC721 is NonReentrant, ERC721H, IHolographDropERC721 {\n  /**\n   * CONTRACT VARIABLES\n   * all variables, without custom storage slots, are defined here\n   */\n\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.osRegistryEnabled')) - 1)\n   */\n  bytes32 constant _osRegistryEnabledSlot = 0x5c835f3b6bd322d9a084ffdeac746df2b96cce308e7f0612f4ff4f9c490734cc;\n\n  /**\n   * @dev Address of the operator filter registry\n   */\n  IOperatorFilterRegistry public constant openseaOperatorFilterRegistry =\n    IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev HOLOGRAPH transfer helper address for auto-approval\n   */\n  address public erc721TransferHelper;\n\n  /**\n   * @dev Address of the market filter registry\n   */\n  address public marketFilterAddress;\n\n  /// @notice Holograph Mint Fee\n  uint256 public constant HOLOGRAPH_MINT_FEE = 1000000; // $1.00 USD (6 decimal places)\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Configuration for NFT minting contract storage\n   */\n  Configuration public config;\n\n  /**\n   * @notice Sales configuration\n   */\n  SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public presaleMintsByAddress;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /**\n   * CUSTOM ERRORS\n   */\n\n  /**\n   * @notice Thrown when there is no active market filter address supported for the current chain\n   * @dev Used for enabling and disabling filter for the given chain.\n   */\n  error MarketFilterAddressNotSupportedForChain();\n\n  /**\n   * MODIFIERS\n   */\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    if (config.editionSize != 0 && quantity + _currentTokenId > config.editionSize) {\n      revert Mint_SoldOut();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Presale active\n   */\n  modifier onlyPresaleActive() {\n    if (!_presaleActive()) {\n      revert Presale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * CONTRACT INITIALIZERS\n   * init function is used instead of constructor\n   */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    DropsInitializer memory initializer = abi.decode(initPayload, (DropsInitializer));\n\n    erc721TransferHelper = initializer.erc721TransferHelper;\n    if (initializer.marketFilterAddress != address(0)) {\n      marketFilterAddress = initializer.marketFilterAddress;\n    }\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // to enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Setup config variables\n    config = Configuration({\n      metadataRenderer: IMetadataRenderer(initializer.metadataRenderer),\n      editionSize: initializer.editionSize,\n      royaltyBPS: initializer.royaltyBPS,\n      fundsRecipient: initializer.fundsRecipient\n    });\n\n    salesConfig = initializer.salesConfiguration;\n\n    // TODO: Need to make sure to initialize the metadata renderer\n    if (initializer.metadataRenderer != address(0)) {\n      IMetadataRenderer(initializer.metadataRenderer).initializeWithData(initializer.metadataRendererInit);\n    }\n\n    if (initializer.enableOpenSeaRoyaltyRegistry && Address.isContract(address(openseaOperatorFilterRegistry))) {\n      if (marketFilterAddress == address(0)) {\n        // this is a default filter that can be used for OS royalty filtering\n        // marketFilterAddress = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\n        // we just register to OS royalties and let OS handle it for us with their default filter contract\n        HolographERC721Interface(holographer()).sourceExternalCall(\n          address(openseaOperatorFilterRegistry),\n          abi.encodeWithSelector(IOperatorFilterRegistry.register.selector, holographer())\n        );\n      } else {\n        // allow user to specify custom filtering contract address\n        HolographERC721Interface(holographer()).sourceExternalCall(\n          address(openseaOperatorFilterRegistry),\n          abi.encodeWithSelector(\n            IOperatorFilterRegistry.registerAndSubscribe.selector,\n            holographer(),\n            marketFilterAddress\n          )\n        );\n      }\n      assembly {\n        sstore(_osRegistryEnabledSlot, true)\n      }\n    }\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * static\n   */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version string representing the version of the contract\n   */\n  function version() external pure returns (string memory) {\n    return \"1.0.0\";\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(IHolographDropERC721).interfaceId;\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * dynamic\n   */\n\n  function owner() external view override(ERC721H, IHolographDropERC721) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  function beforeSafeTransfer(\n    address _from,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external view returns (bool) {\n    if (\n      _from != address(0) && // skip on mints\n      _from != msgSender() // skip on transfers from sender\n    ) {\n      bool osRegistryEnabled;\n      assembly {\n        osRegistryEnabled := sload(_osRegistryEnabledSlot)\n      }\n      if (osRegistryEnabled) {\n        try openseaOperatorFilterRegistry.isOperatorAllowed(address(this), msgSender()) returns (bool allowed) {\n          return allowed;\n        } catch {\n          revert OperatorNotAllowed(msgSender());\n        }\n      }\n    }\n    return true;\n  }\n\n  function beforeTransfer(\n    address _from,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external view returns (bool) {\n    if (\n      _from != address(0) && // skip on mints\n      _from != msgSender() // skip on transfers from sender\n    ) {\n      bool osRegistryEnabled;\n      assembly {\n        osRegistryEnabled := sload(_osRegistryEnabledSlot)\n      }\n      if (osRegistryEnabled) {\n        try openseaOperatorFilterRegistry.isOperatorAllowed(address(this), msgSender()) returns (bool allowed) {\n          return allowed;\n        } catch {\n          revert OperatorNotAllowed(msgSender());\n        }\n      }\n    }\n    return true;\n  }\n\n  function onIsApprovedForAll(address /* _wallet*/, address _operator) external view returns (bool approved) {\n    approved = (erc721TransferHelper != address(0) && _operator == erc721TransferHelper);\n  }\n\n  /**\n   * @notice Sale details\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (SaleDetails memory) {\n    return\n      SaleDetails({\n        publicSaleActive: _publicSaleActive(),\n        presaleActive: _presaleActive(),\n        publicSalePrice: salesConfig.publicSalePrice,\n        publicSaleStart: salesConfig.publicSaleStart,\n        publicSaleEnd: salesConfig.publicSaleEnd,\n        presaleStart: salesConfig.presaleStart,\n        presaleEnd: salesConfig.presaleEnd,\n        presaleMerkleRoot: salesConfig.presaleMerkleRoot,\n        totalMinted: _currentTokenId,\n        maxSupply: config.editionSize,\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress\n      });\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD\n  /// @dev Gets the Holograph protocol fee for amount of mints in USD\n  function getHolographFeeUsd(uint256 quantity) public view returns (uint256 fee) {\n    fee = HOLOGRAPH_MINT_FEE * quantity;\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in wei after conversion\n  /// @dev Gets the Holograph protocol fee for amount of mints in wei\n  function getHolographFeeWei(uint256 quantity) public view returns (uint256) {\n    return _usdToWei(HOLOGRAPH_MINT_FEE * quantity);\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: presaleMintsByAddress[minter],\n        publicMints: totalMintsByAddress[minter] - presaleMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @notice Contract URI Getter, proxies to metadataRenderer\n   * @return Contract URI\n   */\n  function contractURI() external view returns (string memory) {\n    return config.metadataRenderer.contractURI();\n  }\n\n  /**\n   * @notice Getter for metadataRenderer contract\n   */\n  function metadataRenderer() external view returns (IMetadataRenderer) {\n    return IMetadataRenderer(config.metadataRenderer);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /**\n   * @notice Token URI Getter, proxies to metadataRenderer\n   * @param tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    require(H721.exists(tokenId), \"ERC721: token does not exist\");\n\n    return config.metadataRenderer.tokenURI(tokenId);\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * available to all\n   */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n    uint256 holographMintFeeInWei = _usdToWei(HOLOGRAPH_MINT_FEE);\n\n    if (msg.value < (salePrice + holographMintFeeInWei) * quantity) {\n      // The error will display the wrong price that was sent in USD\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice + HOLOGRAPH_MINT_FEE) * quantity);\n    }\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity - presaleMintsByAddress[msgSender()] >\n      salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * @notice Merkle-tree based presale purchase function\n   * @param quantity quantity to purchase\n   * @param maxQuantity max quantity that can be purchased via merkle proof #\n   * @param pricePerToken price that each token is purchased at\n   * @param merkleProof proof for presale mint\n   */\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] calldata merkleProof\n  ) external payable nonReentrant canMintTokens(quantity) onlyPresaleActive returns (uint256) {\n    if (\n      !MerkleProof.verify(\n        merkleProof,\n        salesConfig.presaleMerkleRoot,\n        keccak256(\n          // address, uint256, uint256\n          abi.encode(msgSender(), maxQuantity, pricePerToken)\n        )\n      )\n    ) {\n      revert Presale_MerkleNotApproved();\n    }\n\n    uint256 weiPricePerToken = _usdToWei(pricePerToken);\n    if (msg.value < weiPricePerToken * quantity) {\n      revert Purchase_WrongPrice(pricePerToken * quantity);\n    }\n    uint256 remainder = msg.value - (weiPricePerToken * quantity);\n\n    presaleMintsByAddress[msgSender()] += quantity;\n    if (presaleMintsByAddress[msgSender()] > maxQuantity) {\n      revert Presale_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: weiPricePerToken,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * admin only\n   */\n\n  /**\n   * @notice Proxy to update market filter settings in the main registry contracts\n   * @notice Requires admin permissions\n   * @param args Calldata args to pass to the registry\n   */\n  function updateMarketFilterSettings(bytes calldata args) external onlyOwner {\n    HolographERC721Interface(holographer()).sourceExternalCall(address(openseaOperatorFilterRegistry), args);\n    bool osRegistryEnabled = openseaOperatorFilterRegistry.isRegistered(holographer());\n    assembly {\n      sstore(_osRegistryEnabledSlot, osRegistryEnabled)\n    }\n  }\n\n  /**\n   * @notice Manage subscription for marketplace filtering based off royalty payouts.\n   * @param enable Enable filtering to non-royalty payout marketplaces\n   */\n  function manageMarketFilterSubscription(bool enable) external onlyOwner {\n    address self = holographer();\n    if (marketFilterAddress == address(0)) {\n      revert MarketFilterAddressNotSupportedForChain();\n    }\n    if (!openseaOperatorFilterRegistry.isRegistered(self) && enable) {\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.registerAndSubscribe.selector, self, marketFilterAddress)\n      );\n    } else if (enable) {\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.subscribe.selector, self, marketFilterAddress)\n      );\n    } else {\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.unsubscribe.selector, self, false)\n      );\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.unregister.selector, self)\n      );\n    }\n    bool osRegistryEnabled = openseaOperatorFilterRegistry.isRegistered(self);\n    assembly {\n      sstore(_osRegistryEnabledSlot, osRegistryEnabled)\n    }\n  }\n\n  function modifyMarketFilterAddress(address newMarketFilterAddress) external onlyOwner {\n    marketFilterAddress = newMarketFilterAddress;\n  }\n\n  /**\n   * @notice Admin mint tokens to a recipient for free\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function adminMint(address recipient, uint256 quantity) external onlyOwner canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev Mints multiple editions to the given list of addresses.\n   * @param recipients list of addresses to send the newly minted editions to\n   */\n  function adminMintAirdrop(\n    address[] calldata recipients\n  ) external onlyOwner canMintTokens(recipients.length) returns (uint256) {\n    unchecked {\n      for (uint256 i = 0; i < recipients.length; i++) {\n        _mintNFTs(recipients[i], 1);\n      }\n    }\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @notice Set a new metadata renderer\n   * @param newRenderer new renderer address to use\n   * @param setupRenderer data to setup new renderer with\n   */\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external onlyOwner {\n    config.metadataRenderer = newRenderer;\n\n    if (setupRenderer.length > 0) {\n      newRenderer.initializeWithData(setupRenderer);\n    }\n\n    emit UpdatedMetadataRenderer({sender: msgSender(), renderer: newRenderer});\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   * @param publicSaleStart unix timestamp when the public sale starts\n   * @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n   * @param presaleStart unix timestamp when the presale starts\n   * @param presaleEnd unix timestamp when the presale ends\n   * @param presaleMerkleRoot merkle root for the presale information\n   */\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n    salesConfig.publicSaleStart = publicSaleStart;\n    salesConfig.publicSaleEnd = publicSaleEnd;\n    salesConfig.presaleStart = presaleStart;\n    salesConfig.presaleEnd = presaleEnd;\n    salesConfig.presaleMerkleRoot = presaleMerkleRoot;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    config.fundsRecipient = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (config.fundsRecipient == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != config.fundsRecipient && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = config.fundsRecipient.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, config.fundsRecipient, funds);\n  }\n\n  /**\n   * @notice Admin function to finalize and open edition sale\n   */\n  function finalizeOpenEdition() external onlyOwner {\n    if (config.editionSize != type(uint64).max) {\n      revert Admin_UnableToFinalizeNotOpenEdition();\n    }\n\n    config.editionSize = uint64(_currentTokenId);\n    emit OpenMintFinalized(msgSender(), config.editionSize);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * non state changing\n   */\n\n  function _presaleActive() internal view returns (bool) {\n    return salesConfig.presaleStart <= block.timestamp && salesConfig.presaleEnd > block.timestamp;\n  }\n\n  function _publicSaleActive() internal view returns (bool) {\n    return salesConfig.publicSaleStart <= block.timestamp && salesConfig.publicSaleEnd > block.timestamp;\n  }\n\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * state changing\n   */\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n    for (uint256 i = 0; i < quantity; i++) {\n      _currentTokenId += 1;\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n      // uint256 id = chainPrepend + uint256(tokenId);\n    }\n  }\n\n  function _payoutHolographFee(uint256 quantity) internal {\n    // Transfer protocol mint fee to recipient address\n    uint256 holographMintFeeWei = getHolographFeeWei(quantity);\n\n    // Payout Holograph fee\n    address payable holographFeeRecipient = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    (bool success, ) = holographFeeRecipient.call{value: holographMintFeeWei, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!success) {\n      revert FeePaymentFailed();\n    }\n    emit MintFeePayout(holographMintFeeWei, holographFeeRecipient, success);\n  }\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    },
    "src/drops/token/HolographDropERC721V2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../../abstract/NonReentrant.sol\";\n\nimport {HolographERC721Interface} from \"../../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../../interface/HolographInterface.sol\";\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\nimport {IHolographDropERC721V2} from \"../interface/IHolographDropERC721V2.sol\";\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {HolographTreasuryInterface} from \"../../interface/HolographTreasuryInterface.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {Configuration} from \"../struct/Configuration.sol\";\nimport {DropsInitializerV2} from \"../struct/DropsInitializerV2.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\nimport {SalesConfiguration} from \"../struct/SalesConfiguration.sol\";\n\nimport {Address} from \"../library/Address.sol\";\nimport {MerkleProof} from \"../library/MerkleProof.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified the source code for them.\n */\ncontract HolographDropERC721V2 is NonReentrant, ERC721H, IHolographDropERC721V2 {\n  /**\n   * CONTRACT VARIABLES\n   * all variables, without custom storage slots, are defined here\n   */\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Configuration for NFT minting contract storage\n   */\n  Configuration public config;\n\n  /**\n   * @notice Sales configuration\n   */\n  SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public presaleMintsByAddress;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /**\n   * CUSTOM ERRORS\n   */\n\n  /**\n   * MODIFIERS\n   */\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    if (config.editionSize != 0 && quantity + _currentTokenId > config.editionSize) {\n      revert Mint_SoldOut();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Presale active\n   */\n  modifier onlyPresaleActive() {\n    if (!_presaleActive()) {\n      revert Presale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * CONTRACT INITIALIZERS\n   * init function is used instead of constructor\n   */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    DropsInitializerV2 memory initializer = abi.decode(initPayload, (DropsInitializerV2));\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // to enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Setup config variables\n    config = Configuration({\n      metadataRenderer: IMetadataRenderer(initializer.metadataRenderer),\n      editionSize: initializer.editionSize,\n      royaltyBPS: initializer.royaltyBPS,\n      fundsRecipient: initializer.fundsRecipient\n    });\n\n    salesConfig = initializer.salesConfiguration;\n\n    // Initialize metadata renderer\n    if (initializer.metadataRenderer != address(0)) {\n      IMetadataRenderer(initializer.metadataRenderer).initializeWithData(initializer.metadataRendererInit);\n    }\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * static\n   */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version of the contract\n   */\n  function version() external pure returns (uint32) {\n    return 2;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(IHolographDropERC721V2).interfaceId;\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * dynamic\n   */\n\n  function owner() external view override(ERC721H, IHolographDropERC721V2) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  /**\n   * @notice Sale details\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (SaleDetails memory) {\n    return\n      SaleDetails({\n        publicSaleActive: _publicSaleActive(),\n        presaleActive: _presaleActive(),\n        publicSalePrice: salesConfig.publicSalePrice,\n        publicSaleStart: salesConfig.publicSaleStart,\n        publicSaleEnd: salesConfig.publicSaleEnd,\n        presaleStart: salesConfig.presaleStart,\n        presaleEnd: salesConfig.presaleEnd,\n        presaleMerkleRoot: salesConfig.presaleMerkleRoot,\n        totalMinted: _currentTokenId,\n        maxSupply: config.editionSize,\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress\n      });\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD and is controlled by the treasury\n  /// @dev Gets the flat Holograph protocol fee for a single mint in USD\n  function getHolographFeeFromTreasury() public view returns (uint256) {\n    address payable treasuryProxyAddress = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    HolographTreasuryInterface treasury = HolographTreasuryInterface(treasuryProxyAddress);\n    return treasury.getHolographMintFee();\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD\n  /// @dev Gets the Holograph protocol fee for amount of mints in USD\n  function getHolographFeeUsd(uint256 quantity) public view returns (uint256 fee) {\n    fee = getHolographFeeFromTreasury() * quantity;\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in wei after conversion\n  /// @dev Gets the Holograph protocol fee for amount of mints in wei\n  function getHolographFeeWei(uint256 quantity) public view returns (uint256) {\n    return _usdToWei(getHolographFeeFromTreasury() * quantity);\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: presaleMintsByAddress[minter],\n        publicMints: totalMintsByAddress[minter] - presaleMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @notice Contract URI Getter, proxies to metadataRenderer\n   * @return Contract URI\n   */\n  function contractURI() external view returns (string memory) {\n    return config.metadataRenderer.contractURI();\n  }\n\n  /**\n   * @notice Getter for metadataRenderer contract\n   */\n  function metadataRenderer() external view returns (IMetadataRenderer) {\n    return IMetadataRenderer(config.metadataRenderer);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /**\n   * @notice Token URI Getter, proxies to metadataRenderer\n   * @param tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    require(H721.exists(tokenId), \"ERC721: token does not exist\");\n\n    return config.metadataRenderer.tokenURI(tokenId);\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * available to all\n   */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n    uint256 holographMintFeeUsd = getHolographFeeFromTreasury();\n    uint256 holographMintFeeWei = _usdToWei(holographMintFeeUsd);\n\n    if (msg.value < (salePrice + holographMintFeeWei) * quantity) {\n      // The error will display what the correct price should be\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice + holographMintFeeUsd) * quantity);\n    }\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity - presaleMintsByAddress[msgSender()] >\n      salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * @notice Merkle-tree based presale purchase function\n   * @param quantity quantity to purchase\n   * @param maxQuantity max quantity that can be purchased via merkle proof #\n   * @param pricePerToken price that each token is purchased at\n   * @param merkleProof proof for presale mint\n   */\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] calldata merkleProof\n  ) external payable nonReentrant canMintTokens(quantity) onlyPresaleActive returns (uint256) {\n    if (\n      !MerkleProof.verify(\n        merkleProof,\n        salesConfig.presaleMerkleRoot,\n        keccak256(\n          // address, uint256, uint256\n          abi.encode(msgSender(), maxQuantity, pricePerToken)\n        )\n      )\n    ) {\n      revert Presale_MerkleNotApproved();\n    }\n\n    uint256 weiPricePerToken = _usdToWei(pricePerToken);\n    if (msg.value < weiPricePerToken * quantity) {\n      revert Purchase_WrongPrice(pricePerToken * quantity);\n    }\n    uint256 remainder = msg.value - (weiPricePerToken * quantity);\n\n    presaleMintsByAddress[msgSender()] += quantity;\n    if (presaleMintsByAddress[msgSender()] > maxQuantity) {\n      revert Presale_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: weiPricePerToken,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * admin only\n   */\n\n  /**\n   * @notice Admin mint tokens to a recipient for free\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function adminMint(address recipient, uint256 quantity) external onlyOwner canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev Mints multiple editions to the given list of addresses.\n   * @param recipients list of addresses to send the newly minted editions to\n   */\n  function adminMintAirdrop(\n    address[] calldata recipients\n  ) external onlyOwner canMintTokens(recipients.length) returns (uint256) {\n    unchecked {\n      for (uint256 i = 0; i < recipients.length; i++) {\n        _mintNFTs(recipients[i], 1);\n      }\n    }\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @notice Set a new metadata renderer\n   * @param newRenderer new renderer address to use\n   * @param setupRenderer data to setup new renderer with\n   */\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external onlyOwner {\n    config.metadataRenderer = newRenderer;\n\n    if (setupRenderer.length > 0) {\n      newRenderer.initializeWithData(setupRenderer);\n    }\n\n    emit UpdatedMetadataRenderer({sender: msgSender(), renderer: newRenderer});\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   * @param publicSaleStart unix timestamp when the public sale starts\n   * @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n   * @param presaleStart unix timestamp when the presale starts\n   * @param presaleEnd unix timestamp when the presale ends\n   * @param presaleMerkleRoot merkle root for the presale information\n   */\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n    salesConfig.publicSaleStart = publicSaleStart;\n    salesConfig.publicSaleEnd = publicSaleEnd;\n    salesConfig.presaleStart = presaleStart;\n    salesConfig.presaleEnd = presaleEnd;\n    salesConfig.presaleMerkleRoot = presaleMerkleRoot;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    config.fundsRecipient = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (config.fundsRecipient == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != config.fundsRecipient && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = config.fundsRecipient.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, config.fundsRecipient, funds);\n  }\n\n  /**\n   * @notice Admin function to finalize and open edition sale\n   */\n  function finalizeOpenEdition() external onlyOwner {\n    if (config.editionSize != type(uint64).max) {\n      revert Admin_UnableToFinalizeNotOpenEdition();\n    }\n\n    config.editionSize = uint64(_currentTokenId);\n    emit OpenMintFinalized(msgSender(), config.editionSize);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * non state changing\n   */\n\n  function _presaleActive() internal view returns (bool) {\n    return salesConfig.presaleStart <= block.timestamp && salesConfig.presaleEnd > block.timestamp;\n  }\n\n  function _publicSaleActive() internal view returns (bool) {\n    return salesConfig.publicSaleStart <= block.timestamp && salesConfig.publicSaleEnd > block.timestamp;\n  }\n\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * state changing\n   */\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n    for (uint256 i = 0; i < quantity; i++) {\n      _currentTokenId += 1;\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n\n      uint256 id = chainPrepend + uint256(tokenId);\n      emit NFTMinted(recipient, tokenId, id);\n    }\n  }\n\n  function _payoutHolographFee(uint256 quantity) internal {\n    // Transfer protocol mint fee to recipient address\n    uint256 holographMintFeeWei = getHolographFeeWei(quantity);\n\n    // Payout Holograph fee\n    address payable holographFeeRecipient = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    (bool success, ) = holographFeeRecipient.call{value: holographMintFeeWei, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!success) {\n      revert FeePaymentFailed();\n    }\n    emit MintFeePayout(holographMintFeeWei, holographFeeRecipient, success);\n  }\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    },
    "src/drops/utils/NFTMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n   * with further edits by Uniswap Labs also under MIT license.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        return prod0 / denominator;\n      }\n\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n        // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n      // See https://cs.stackexchange.com/q/138556/92363.\n\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\n      uint256 twos = denominator & (~denominator + 1);\n      assembly {\n        // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n      // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n      // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n      // in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n   *\n   * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n   */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n   */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = sqrt(a);\n      return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 128;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 64;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 32;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 16;\n      }\n      if (value >> 8 > 0) {\n        value >>= 8;\n        result += 8;\n      }\n      if (value >> 4 > 0) {\n        value >>= 4;\n        result += 4;\n      }\n      if (value >> 2 > 0) {\n        value >>= 2;\n        result += 2;\n      }\n      if (value >> 1 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log2(value);\n      return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >= 10 ** 64) {\n        value /= 10 ** 64;\n        result += 64;\n      }\n      if (value >= 10 ** 32) {\n        value /= 10 ** 32;\n        result += 32;\n      }\n      if (value >= 10 ** 16) {\n        value /= 10 ** 16;\n        result += 16;\n      }\n      if (value >= 10 ** 8) {\n        value /= 10 ** 8;\n        result += 8;\n      }\n      if (value >= 10 ** 4) {\n        value /= 10 ** 4;\n        result += 4;\n      }\n      if (value >= 10 ** 2) {\n        value /= 10 ** 2;\n        result += 2;\n      }\n      if (value >= 10 ** 1) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log10(value);\n      return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   *\n   * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n   */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 16;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 8;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 4;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 2;\n      }\n      if (value >> 8 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log256(value);\n      return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n    }\n  }\n}\n\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      uint256 length = Math.log10(value) + 1;\n      string memory buffer = new string(length);\n      uint256 ptr;\n      /// @solidity memory-safe-assembly\n      assembly {\n        ptr := add(buffer, add(32, length))\n      }\n      while (true) {\n        ptr--;\n        /// @solidity memory-safe-assembly\n        assembly {\n          mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n        }\n        value /= 10;\n        if (value == 0) break;\n      }\n      return buffer;\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      return toHexString(value, Math.log256(value) + 1);\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n\nlibrary Base64 {\n  /**\n   * @dev Base64 Encoding/Decoding Table\n   */\n  string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /**\n   * @dev Converts a `bytes` to its Bytes64 `string` representation.\n   */\n  function encode(bytes memory data) internal pure returns (string memory) {\n    /**\n     * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n     * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n     */\n    if (data.length == 0) return \"\";\n\n    // Loads the table into memory\n    string memory table = _TABLE;\n\n    // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n    // and split into 4 numbers of 6 bits.\n    // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n    // - `data.length + 2`  -> Round up\n    // - `/ 3`              -> Number of 3-bytes chunks\n    // - `4 *`              -> 4 characters for each chunk\n    string memory result = new string(4 * ((data.length + 2) / 3));\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Prepare the lookup table (skip the first \"length\" byte)\n      let tablePtr := add(table, 1)\n\n      // Prepare result pointer, jump over length\n      let resultPtr := add(result, 32)\n\n      // Run over the input, 3 bytes at a time\n      for {\n        let dataPtr := data\n        let endPtr := add(data, mload(data))\n      } lt(dataPtr, endPtr) {\n\n      } {\n        // Advance 3 bytes\n        dataPtr := add(dataPtr, 3)\n        let input := mload(dataPtr)\n\n        // To write each character, shift the 3 bytes (18 bits) chunk\n        // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n        // and apply logical AND with 0x3F which is the number of\n        // the previous character in the ASCII table prior to the Base64 Table\n        // The result is then added to the table to get the character to write,\n        // and finally write it in the result pointer but with a left shift\n        // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n      }\n\n      // When data `bytes` is not exactly 3 bytes long\n      // it is padded with `=` characters at the end\n      switch mod(mload(data), 3)\n      case 1 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n        mstore8(sub(resultPtr, 2), 0x3d)\n      }\n      case 2 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n      }\n    }\n\n    return result;\n  }\n}\n\n/// NFT metadata library for rendering metadata associated with editions\nlibrary NFTMetadataRenderer {\n  /// Generate edition metadata from storage information as base64-json blob\n  /// Combines the media data and metadata\n  /// @param name Name of NFT in metadata\n  /// @param description Description of NFT in metadata\n  /// @param imageURI URI of image to render for edition\n  /// @param animationURI URI of animation to render for edition\n  /// @param tokenOfEdition Token ID for specific token\n  /// @param editionSize Size of entire edition to show\n  function createMetadataEdition(\n    string memory name,\n    string memory description,\n    string memory imageURI,\n    string memory animationURI,\n    uint256 tokenOfEdition,\n    uint256 editionSize\n  ) internal pure returns (string memory) {\n    string memory _tokenMediaData = tokenMediaData(imageURI, animationURI);\n    bytes memory json = createMetadataJSON(name, description, _tokenMediaData, tokenOfEdition, editionSize);\n    return encodeMetadataJSON(json);\n  }\n\n  function encodeContractURIJSON(\n    string memory name,\n    string memory description,\n    string memory imageURI,\n    string memory animationURI,\n    uint256 royaltyBPS,\n    address royaltyRecipient\n  ) internal pure returns (string memory) {\n    bytes memory imageSpace = bytes(\"\");\n    if (bytes(imageURI).length > 0) {\n      imageSpace = abi.encodePacked('\", \"image\": \"', imageURI);\n    }\n    bytes memory animationSpace = bytes(\"\");\n    if (bytes(animationURI).length > 0) {\n      animationSpace = abi.encodePacked('\", \"animation_url\": \"', animationURI);\n    }\n\n    return\n      string(\n        encodeMetadataJSON(\n          abi.encodePacked(\n            '{\"name\": \"',\n            name,\n            '\", \"description\": \"',\n            description,\n            // this is for opensea since they don't respect ERC2981 right now\n            '\", \"seller_fee_basis_points\": ',\n            Strings.toString(royaltyBPS),\n            ', \"fee_recipient\": \"',\n            Strings.toHexString(uint256(uint160(royaltyRecipient)), 20),\n            imageSpace,\n            animationSpace,\n            '\"}'\n          )\n        )\n      );\n  }\n\n  /// Function to create the metadata json string for the nft edition\n  /// @param name Name of NFT in metadata\n  /// @param description Description of NFT in metadata\n  /// @param mediaData Data for media to include in json object\n  /// @param tokenOfEdition Token ID for specific token\n  /// @param editionSize Size of entire edition to show\n  function createMetadataJSON(\n    string memory name,\n    string memory description,\n    string memory mediaData,\n    uint256 tokenOfEdition,\n    uint256 editionSize\n  ) internal pure returns (bytes memory) {\n    bytes memory editionSizeText;\n    if (editionSize > 0) {\n      editionSizeText = abi.encodePacked(\"/\", Strings.toString(editionSize));\n    }\n    return\n      abi.encodePacked(\n        '{\"name\": \"',\n        name,\n        \" \",\n        Strings.toString(tokenOfEdition),\n        editionSizeText,\n        '\", \"',\n        'description\": \"',\n        description,\n        '\", \"',\n        mediaData,\n        'properties\": {\"number\": ',\n        Strings.toString(tokenOfEdition),\n        ', \"name\": \"',\n        name,\n        '\"}}'\n      );\n  }\n\n  /// Encodes the argument json bytes into base64-data uri format\n  /// @param json Raw json to base64 and turn into a data-uri\n  function encodeMetadataJSON(bytes memory json) internal pure returns (string memory) {\n    return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(json)));\n  }\n\n  /// Generates edition metadata from storage information as base64-json blob\n  /// Combines the media data and metadata\n  /// @param imageUrl URL of image to render for edition\n  /// @param animationUrl URL of animation to render for edition\n  function tokenMediaData(string memory imageUrl, string memory animationUrl) internal pure returns (string memory) {\n    bool hasImage = bytes(imageUrl).length > 0;\n    bool hasAnimation = bytes(animationUrl).length > 0;\n    if (hasImage && hasAnimation) {\n      return string(abi.encodePacked('image\": \"', imageUrl, '\", \"animation_url\": \"', animationUrl, '\", \"'));\n    }\n    if (hasImage) {\n      return string(abi.encodePacked('image\": \"', imageUrl, '\", \"'));\n    }\n    if (hasAnimation) {\n      return string(abi.encodePacked('animation_url\": \"', animationUrl, '\", \"'));\n    }\n\n    return \"\";\n  }\n}\n"
    },
    "src/enforcer/Holographer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\n\n/**\n * @dev This contract is a binder. It puts together all the variables to make the underlying contracts functional and be bridgeable.\n */\ncontract Holographer is Admin, Initializable, HolographerInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.originChain')) - 1)\n   */\n  bytes32 constant _originChainSlot = 0xd49ffd6af8249d6e6b5963d9d2b22c6db30ad594cb468453047a14e1c1bcde4d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.blockHeight')) - 1)\n   */\n  bytes32 constant _blockHeightSlot = 0x9172848b0f1df776dc924b58e7fa303087ae0409bbf611608529e7f747d55de3;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPHER: already initialized\");\n    (bytes memory encoded, bytes memory initCode) = abi.decode(initPayload, (bytes, bytes));\n    (uint32 originChain, address holograph, bytes32 contractType, address sourceContract) = abi.decode(\n      encoded,\n      (uint32, address, bytes32, address)\n    );\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_blockHeightSlot, number())\n      sstore(_contractTypeSlot, contractType)\n      sstore(_holographSlot, holograph)\n      sstore(_originChainSlot, originChain)\n      sstore(_sourceContractSlot, sourceContract)\n    }\n    (bool success, bytes memory returnData) = HolographRegistryInterface(HolographInterface(holograph).getRegistry())\n      .getReservedContractTypeAddress(contractType)\n      .delegatecall(abi.encodeWithSelector(InitializableInterface.init.selector, initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"HOLOGRAPH: initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Returns the contract type that is used for loading the Enforcer\n   */\n  function getContractType() external view returns (bytes32 contractType) {\n    assembly {\n      contractType := sload(_contractTypeSlot)\n    }\n  }\n\n  /**\n   * @dev Returns the block height of when the smart contract was deployed. Useful for retrieving deployment config for re-deployment on other EVM-compatible chains.\n   */\n  function getDeploymentBlock() external view returns (uint256 deploymentBlock) {\n    assembly {\n      deploymentBlock := sload(_blockHeightSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the Holograph smart contract.\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the Holograph smart contract that controls and enforces the ERC standards.\n   */\n  function getHolographEnforcer() public view returns (address) {\n    HolographInterface holograph;\n    bytes32 contractType;\n    assembly {\n      holograph := sload(_holographSlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return HolographRegistryInterface(holograph.getRegistry()).getReservedContractTypeAddress(contractType);\n  }\n\n  /**\n   * @dev Returns the original chain that contract was deployed on.\n   */\n  function getOriginChain() external view returns (uint32 originChain) {\n    assembly {\n      originChain := sload(_originChainSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the custom secure storage contract deployed in parallel with this contract deployment.\n   */\n  function getSourceContract() external view returns (address sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev This takes the Enforcer's source code, runs it, and uses current address for storage slots.\n   */\n  fallback() external payable {\n    address holographEnforcer = getHolographEnforcer();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), holographEnforcer, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/enforcer/HolographERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/EIP712.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/NonReentrant.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC20Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Burnable.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/ERC20Metadata.sol\";\nimport \"../interface/ERC20Permit.sol\";\nimport \"../interface/ERC20Receiver.sol\";\nimport \"../interface/ERC20Safer.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC20.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-20 Token\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC20 is Admin, Owner, Initializable, NonReentrant, EIP712, HolographERC20Interface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => uint256) private _nonces;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC20: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC20: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_reentrantSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint8 contractDecimals,\n      uint256 eventConfig,\n      string memory domainSeperator,\n      string memory domainVersion,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint8, uint256, string, string, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC20: could not init source\");\n    }\n    _setInitialized();\n    _eip712_init(domainSeperator, domainVersion);\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 0x20), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /*\n   * @dev all calls to source contract go through this function in order to inject original msg.sender in calldata\n   */\n  function _sourceCall(bytes memory payload) private returns (bool output) {\n    assembly {\n      mstore(add(payload, add(mload(payload), 0x20)), caller())\n      // offset memory position by 32 bytes to skip the 32 bytes where bytes length is stored\n      // add 32 bytes to bytes length to include the appended msg.sender to calldata\n      let result := call(\n        gas(),\n        sload(_sourceContractSlot),\n        callvalue(),\n        add(payload, 0x20),\n        add(mload(payload), 0x20),\n        0,\n        0\n      )\n      let pos := mload(0x40)\n      // reserve memory space for return data\n      mstore(0x40, add(pos, returndatasize()))\n      returndatacopy(pos, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(pos, returndatasize())\n      }\n      output := mload(pos)\n    }\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC20, interfaceId) || erc165Contract.supportsInterface(interfaceId) // check global interfaces // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function allowance(address account, address spender) public view returns (uint256) {\n    return _allowances[account][spender];\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function nonces(address account) public view returns (uint256) {\n    return _nonces[account];\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.beforeApprove.selector, msg.sender, spender, amount))\n      );\n    }\n    _approve(msg.sender, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.afterApprove.selector, msg.sender, spender, amount)));\n    }\n    return true;\n  }\n\n  function burn(uint256 amount) public {\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.beforeBurn.selector, msg.sender, amount)));\n    }\n    _burn(msg.sender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.afterBurn.selector, msg.sender, amount)));\n    }\n  }\n\n  function _allowance(address account, address to, uint256 amount) internal {\n    uint256 currentAllowance = _allowances[account][to];\n    if (currentAllowance >= amount) {\n      unchecked {\n        _allowances[account][to] = currentAllowance - amount;\n      }\n    } else {\n      if (_isEventRegistered(HolographERC20Event.onAllowance)) {\n        require(\n          _sourceCall(abi.encodeWithSelector(HolographedERC20.onAllowance.selector, account, to, amount)),\n          \"ERC20: amount exceeds allowance\"\n        );\n        _allowances[account][to] = 0;\n      } else {\n        revert(\"ERC20: amount exceeds allowance\");\n      }\n    }\n  }\n\n  function burnFrom(address account, uint256 amount) public returns (bool) {\n    _allowance(account, msg.sender, amount);\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.beforeBurn.selector, account, amount)));\n    }\n    _burn(account, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.afterBurn.selector, account, amount)));\n    }\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance - subtractedValue;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.beforeApprove.selector, msg.sender, spender, newAllowance))\n      );\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.afterApprove.selector, msg.sender, spender, newAllowance))\n      );\n    }\n    return true;\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 amount, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    _mint(to, amount);\n    if (_isEventRegistered(HolographERC20Event.bridgeIn)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.bridgeIn.selector, fromChain, from, to, amount, data)),\n        \"HOLOGRAPH: bridge in failed\"\n      );\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 amount) = abi.decode(payload, (address, address, uint256));\n    if (sender != from) {\n      _allowance(from, sender, amount);\n    }\n    if (_isEventRegistered(HolographERC20Event.bridgeOut)) {\n      /*\n       * @dev making a bridgeOut call to source contract\n       *      assembly is used so that msg.sender can be injected in the calldata\n       */\n      bytes memory sourcePayload = abi.encodeWithSelector(\n        HolographedERC20.bridgeOut.selector,\n        toChain,\n        from,\n        to,\n        amount\n      );\n      assembly {\n        // it is important to add 32 bytes in order to accommodate the first 32 bytes being used for storing length of bytes\n        mstore(add(sourcePayload, add(mload(sourcePayload), 0x20)), caller())\n        let result := call(\n          gas(),\n          sload(_sourceContractSlot),\n          callvalue(),\n          // start reading data from memory position, plus 32 bytes, to skip bytes length indicator\n          add(sourcePayload, 0x20),\n          // add an additional 32 bytes to bytes length to include the appended caller address\n          add(mload(sourcePayload), 0x20),\n          0,\n          0\n        )\n        // when reading back data, skip the first 32 bytes which is used to indicate bytes position in calldata\n        // also subtract 32 bytes from returndatasize to accomodate the skipped first 32 bytes\n        returndatacopy(data, 0x20, sub(returndatasize(), 0x20))\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n      }\n    }\n    _burn(from, amount);\n    return (Holographable.bridgeOut.selector, abi.encode(from, to, amount, data));\n  }\n\n  /**\n   * @dev Allows the bridge to mint tokens (used for hTokens only).\n   */\n  function holographBridgeMint(address to, uint256 amount) external onlyBridge returns (bytes4) {\n    _mint(to, amount);\n    return HolographERC20Interface.holographBridgeMint.selector;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance + addedValue;\n    }\n    unchecked {\n      require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.beforeApprove.selector, msg.sender, spender, newAllowance))\n      );\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.afterApprove.selector, msg.sender, spender, newAllowance))\n      );\n    }\n    return true;\n  }\n\n  function onERC20Received(\n    address account,\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) public returns (bytes4) {\n    require(_isContract(account), \"ERC20: operator not contract\");\n    if (_isEventRegistered(HolographERC20Event.beforeOnERC20Received)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(\n            HolographedERC20.beforeOnERC20Received.selector,\n            account,\n            sender,\n            address(this),\n            amount,\n            data\n          )\n        )\n      );\n    }\n    try ERC20(account).balanceOf(address(this)) returns (uint256) {\n      // do nothing, just want to see if this reverts due to invalid erc-20 contract\n    } catch {\n      revert(\"ERC20: failed getting balance\");\n    }\n    if (_isEventRegistered(HolographERC20Event.afterOnERC20Received)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(\n            HolographedERC20.afterOnERC20Received.selector,\n            account,\n            sender,\n            address(this),\n            amount,\n            data\n          )\n        )\n      );\n    }\n    return ERC20Receiver.onERC20Received.selector;\n  }\n\n  function permit(\n    address account,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n    bytes32 structHash = keccak256(\n      abi.encode(\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n        account,\n        spender,\n        amount,\n        _useNonce(account),\n        deadline\n      )\n    );\n    bytes32 hash = _hashTypedDataV4(structHash);\n    address signer = _recover(r, s, v, hash);\n    require(signer == account, \"ERC20: invalid signature\");\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.beforeApprove.selector, account, spender, amount)));\n    }\n    _approve(account, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.afterApprove.selector, account, spender, amount)));\n    }\n  }\n\n  function safeTransfer(address recipient, uint256 amount) public returns (bool) {\n    return safeTransfer(recipient, amount, \"\");\n  }\n\n  function safeTransfer(address recipient, uint256 amount, bytes memory data) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(HolographedERC20.beforeSafeTransfer.selector, msg.sender, recipient, amount, data)\n        )\n      );\n    }\n    _transfer(msg.sender, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(HolographedERC20.afterSafeTransfer.selector, msg.sender, recipient, amount, data)\n        )\n      );\n    }\n    return true;\n  }\n\n  function safeTransferFrom(address account, address recipient, uint256 amount) public returns (bool) {\n    return safeTransferFrom(account, recipient, amount, \"\");\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      /*\n       * @dev This is intentionally enabled to remove friction when operator or bridge needs to move tokens\n       */\n      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {\n        _allowance(account, msg.sender, amount);\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(HolographedERC20.beforeSafeTransfer.selector, account, recipient, amount, data)\n        )\n      );\n    }\n    _transfer(account, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(HolographedERC20.afterSafeTransfer.selector, account, recipient, amount, data)\n        )\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn tokens.\n   */\n  function sourceBurn(address from, uint256 amount) external onlySource {\n    _burn(from, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint tokens.\n   */\n  function sourceMint(address to, uint256 amount) external onlySource {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of token amounts.\n   */\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external onlySource {\n    for (uint256 i = 0; i < wallets.length; i++) {\n      _mint(wallets[i], amounts[i]);\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to transfer tokens.\n   */\n  function sourceTransfer(address from, address to, uint256 amount) external onlySource {\n    _transfer(from, to, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to withdraw contract balance.\n   */\n  function sourceTransfer(address payable destination, uint256 amount) external onlySource {\n    destination.transfer(amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to make calls to external contracts\n   */\n  function sourceExternalCall(address target, bytes calldata data) external onlySource {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.beforeTransfer.selector, msg.sender, recipient, amount))\n      );\n    }\n    _transfer(msg.sender, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.afterTransfer.selector, msg.sender, recipient, amount))\n      );\n    }\n    return true;\n  }\n\n  function transferFrom(address account, address recipient, uint256 amount) public returns (bool) {\n    if (account != msg.sender) {\n      /*\n       * @dev This is intentionally enabled to remove friction when operator or bridge needs to move tokens\n       */\n      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {\n        _allowance(account, msg.sender, amount);\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC20.beforeTransfer.selector, account, recipient, amount))\n      );\n    }\n    _transfer(account, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC20.afterTransfer.selector, account, recipient, amount)));\n    }\n    return true;\n  }\n\n  function _approve(address account, address spender, uint256 amount) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(spender != address(0), \"ERC20: spender is zero address\");\n    _allowances[account][spender] = amount;\n    emit Approval(account, spender, amount);\n  }\n\n  function _burn(address account, uint256 amount) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    _registryTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @notice Mints tokens.\n   * @dev Mint a specific amount of tokens to a specific address.\n   * @param to Address to mint to.\n   * @param amount Amount of tokens to mint.\n   */\n  function _mint(address to, uint256 amount) private {\n    require(to != address(0), \"ERC20: minting to burn address\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    _registryTransfer(address(0), to, amount);\n  }\n\n  function _transfer(address account, address recipient, uint256 amount) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(recipient != address(0), \"ERC20: recipient is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _balances[recipient] += amount;\n    _registryTransfer(account, recipient, amount);\n  }\n\n  function _registryTransfer(address _from, address _to, uint256 _amount) private {\n    emit Transfer(_from, _to, _amount);\n    HolographRegistryInterface(_holograph().getRegistry()).holographableEvent(\n      abi.encode(\n        // keccak256(\"TransferERC20(address,address,uint256)\")\n        bytes32(0x9b035625e569d1d2bf54830a290aefba7ab11610ba8490871dc62b86b63a8956),\n        _from,\n        _to,\n        _amount\n      )\n    );\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address account) private returns (uint256 current) {\n    current = _nonces[account];\n    _nonces[account]++;\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Internal function used for identifying signer\n   */\n  function _recover(bytes32 r, bytes32 s, uint8 v, bytes32 hash) private pure returns (address signer) {\n    if (v < 27) {\n      v += 27;\n    }\n    require(v == 27 || v == 28, \"ERC20: invalid v-value\");\n    // prevent signature malleability by checking if s-value is in the upper range\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      // if s-value is in upper range, calculate a new s-value\n      s = bytes32(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - uint256(s));\n      // flip the v-value\n      if (v == 27) {\n        v = 28;\n      } else {\n        v = 27;\n      }\n      // check if s-value is still in upper range\n      require(\n        uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n        \"ERC20: invalid s-value\"\n      );\n    }\n    signer = ecrecover(hash, v, r, s);\n    require(signer != address(0), \"ERC20: zero address signer\");\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _isEventRegistered(HolographERC20Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n"
    },
    "src/enforcer/HolographERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC721Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC721.sol\";\nimport \"../interface/HolographERC721Interface.sol\";\nimport \"../interface/ERC721Metadata.sol\";\nimport \"../interface/ERC721TokenReceiver.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC721.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/HolographRoyaltiesInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-721 Collection\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC721 is Admin, Owner, HolographERC721Interface, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Collection name.\n   */\n  string private _name;\n\n  /**\n   * @dev Collection symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Collection royalty base points.\n   */\n  uint16 private _bps;\n\n  /**\n   * @dev Array of all token ids in collection.\n   */\n  uint256[] private _allTokens;\n\n  /**\n   * @dev Map of token id to array index of _ownedTokens.\n   */\n  mapping(uint256 => uint256) private _ownedTokensIndex;\n\n  /**\n   * @dev Token id to wallet (owner) address map.\n   */\n  mapping(uint256 => address) private _tokenOwner;\n\n  /**\n   * @dev 1-to-1 map of token id that was assigned an approved operator address.\n   */\n  mapping(uint256 => address) private _tokenApprovals;\n\n  /**\n   * @dev Map of total tokens owner by a specific address.\n   */\n  mapping(address => uint256) private _ownedTokensCount;\n\n  /**\n   * @dev Map of array of token ids owned by a specific address.\n   */\n  mapping(address => uint256[]) private _ownedTokens;\n\n  /**\n   * @notice Map of full operator approval for a particular address.\n   * @dev Usually utilised for supporting marketplace proxy wallets.\n   */\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev Mapping from token id to position in the allTokens array.\n   */\n  mapping(uint256 => uint256) private _allTokensIndex;\n\n  /**\n   * @dev Mapping of all token ids that have been burned. This is to prevent re-minting of same token ids.\n   */\n  mapping(uint256 => bool) private _burnedTokens;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC721: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC721: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint16 contractBps,\n      uint256 eventConfig,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint16, uint256, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _bps = contractBps;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC721: could not init source\");\n      (bool success, bytes memory returnData) = _royalties().delegatecall(\n        abi.encodeWithSelector(\n          HolographRoyaltiesInterface.initHolographRoyalties.selector,\n          abi.encode(uint256(contractBps), uint256(0))\n        )\n      );\n      bytes4 selector = abi.decode(returnData, (bytes4));\n      require(success && selector == InitializableInterface.init.selector, \"ERC721: could not init royalties\");\n    }\n\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Gets a base64 encoded contract JSON file.\n   * @return string The URI.\n   */\n  function contractURI() external view returns (string memory) {\n    if (_isEventRegistered(HolographERC721Event.customContractURI)) {\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        mstore(calldatasize(), caller())\n        let result := staticcall(gas(), sload(_sourceContractSlot), 0, add(calldatasize(), 0x20), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    }\n    return HolographInterfacesInterface(_interfaces()).contractURI(_name, \"\", \"\", _bps, address(this));\n  }\n\n  /**\n   * @notice Gets the name of the collection.\n   * @return string The collection name.\n   */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @notice Shows the interfaces the contracts support\n   * @dev Must add new 4 byte interface Ids here to acknowledge support\n   * @param interfaceId ERC165 style 4 byte interfaceId.\n   * @return bool True if supported.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC721, interfaceId) || // check global interfaces\n      interfaces.supportsInterface(InterfaceType.ROYALTIES, interfaceId) || // check if royalties supports interface\n      erc165Contract.supportsInterface(interfaceId) // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Gets the collection's symbol.\n   * @return string The symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @dev Defaults the the Arweave URI\n   * @return string The URI.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := staticcall(gas(), sload(_sourceContractSlot), 0, add(calldatasize(), 0x20), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Get list of tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @return uint256[] Returns an array of token ids owned by wallet.\n   */\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\n    return _ownedTokens[wallet];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids owned by wallet.\n   */\n  function tokensOfOwner(\n    address wallet,\n    uint256 index,\n    uint256 length\n  ) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _ownedTokensCount[wallet];\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _ownedTokens[wallet][index + i];\n    }\n  }\n\n  /**\n   * @notice Adds a new address to the token's approval list.\n   * @dev Requires the sender to be in the approved addresses.\n   * @param to The address to approve.\n   * @param tokenId The affected token.\n   */\n  function approve(address to, uint256 tokenId) external payable {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(to != tokenOwner, \"ERC721: cannot approve self\");\n    require(_isApprovedStrict(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprove)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC721.beforeApprove.selector, tokenOwner, to, tokenId)));\n    }\n    _tokenApprovals[tokenId] = to;\n    emit Approval(tokenOwner, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterApprove)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC721.afterApprove.selector, tokenOwner, to, tokenId)));\n    }\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev The sender must be the owner or approved.\n   * @param tokenId The token to burn.\n   */\n  function burn(uint256 tokenId) external {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    address wallet = _tokenOwner[tokenId];\n    if (_isEventRegistered(HolographERC721Event.beforeBurn)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC721.beforeBurn.selector, wallet, tokenId)));\n    }\n    _burn(wallet, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterBurn)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC721.afterBurn.selector, wallet, tokenId)));\n    }\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 tokenId, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    delete _burnedTokens[tokenId];\n    _mint(to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.bridgeIn)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC721.bridgeIn.selector, fromChain, from, to, tokenId, data)),\n        \"HOLOGRAPH: bridge in failed\"\n      );\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 tokenId) = abi.decode(payload, (address, address, uint256));\n    require(to != address(0), \"ERC721: zero address\");\n    require(_isApproved(sender, tokenId), \"ERC721: sender not approved\");\n    require(from == _tokenOwner[tokenId], \"ERC721: from is not owner\");\n    if (_isEventRegistered(HolographERC721Event.bridgeOut)) {\n      /*\n       * @dev making a bridgeOut call to source contract\n       *      assembly is used so that msg.sender can be injected in the calldata\n       */\n      bytes memory sourcePayload = abi.encodeWithSelector(\n        HolographedERC721.bridgeOut.selector,\n        toChain,\n        from,\n        to,\n        tokenId\n      );\n      assembly {\n        // it is important to add 32 bytes in order to accommodate the first 32 bytes being used for storing length of bytes\n        mstore(add(sourcePayload, add(mload(sourcePayload), 0x20)), caller())\n        let result := call(\n          gas(),\n          sload(_sourceContractSlot),\n          callvalue(),\n          // start reading data from memory position, plus 32 bytes, to skip bytes length indicator\n          add(sourcePayload, 0x20),\n          // add an additional 32 bytes to bytes length to include the appended caller address\n          add(mload(sourcePayload), 0x20),\n          0,\n          0\n        )\n        // when reading back data, skip the first 32 bytes which is used to indicate bytes position in calldata\n        // also subtract 32 bytes from returndatasize to accomodate the skipped first 32 bytes\n        returndatacopy(data, 0x20, sub(returndatasize(), 0x20))\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n      }\n    }\n    _burn(from, tokenId);\n    return (Holographable.bridgeOut.selector, abi.encode(from, to, tokenId, data));\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(address from, address to, uint256 tokenId) external payable {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC721.beforeSafeTransfer.selector, from, to, tokenId, data))\n      );\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isContract(to)) {\n      require(\n        ERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) ==\n          ERC721TokenReceiver.onERC721Received.selector,\n        \"ERC721: onERC721Received fail\"\n      );\n    }\n    if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC721.afterSafeTransfer.selector, from, to, tokenId, data))\n      );\n    }\n  }\n\n  /**\n   * @notice Adds a new approved operator.\n   * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\n   * @param to The address to approve.\n   * @param approved Turn on or off approval status.\n   */\n  function setApprovalForAll(address to, bool approved) external {\n    require(to != msg.sender, \"ERC721: cannot approve self\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC721.beforeApprovalAll.selector, msg.sender, to, approved))\n      );\n    }\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n    if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedERC721.afterApprovalAll.selector, msg.sender, to, approved))\n      );\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be burned if it's locked by bridge.\n   */\n  function sourceBurn(uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _burn(wallet, tokenId);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a token.\n   */\n  function sourceMint(address to, uint224 tokenId) external onlySource {\n    // uint32 is reserved for chain id to be used\n    // we need to get current chain id, and prepend it to tokenId\n    // this will prevent possible tokenId overlap if minting simultaneously on multiple chains is possible\n    uint256 token = uint256(bytes32(abi.encodePacked(_chain(), tokenId)));\n    require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n    _mint(to, token);\n  }\n\n  /**\n   * @dev Allows source to get the prepend for their tokenIds.\n   */\n  function sourceGetChainPrepend() external view onlySource returns (uint256) {\n    return uint256(bytes32(abi.encodePacked(_chain(), uint224(0))));\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  function sourceMintBatch(address to, uint224[] calldata tokenIds) external onlySource {\n    require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n    uint32 chain = _chain();\n    uint256 token;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n      token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n      require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n      _mint(to, token);\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  function sourceMintBatch(address[] calldata wallets, uint224[] calldata tokenIds) external onlySource {\n    require(wallets.length == tokenIds.length, \"ERC721: array length missmatch\");\n    require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n    uint32 chain = _chain();\n    uint256 token;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n      require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n      _mint(wallets[i], token);\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  function sourceMintBatchIncremental(address to, uint224 startingTokenId, uint256 length) external onlySource {\n    uint256 token = uint256(bytes32(abi.encodePacked(_chain(), startingTokenId)));\n    for (uint256 i = 0; i < length; i++) {\n      require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n      _mint(to, token);\n      token++;\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to transfer a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be transfered if it's locked by bridge.\n   */\n  function sourceTransfer(address to, uint256 tokenId) external onlySource {\n    require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");\n    address wallet = _tokenOwner[tokenId];\n    _transferFrom(wallet, to, tokenId);\n  }\n\n  /**\n   * @dev Allows for source smart contract to make calls to external contracts\n   */\n  function sourceExternalCall(address target, bytes calldata data) external onlySource {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `msg.sender` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transfer(address to, uint256 tokenId) external payable {\n    transferFrom(msg.sender, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transferFrom(address from, address to, uint256 tokenId) public payable {\n    transferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   * @param data additional data to pass.\n   */\n  function transferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeTransfer)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC721.beforeTransfer.selector, from, to, tokenId, data)));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterTransfer)) {\n      require(_sourceCall(abi.encodeWithSelector(HolographedERC721.afterTransfer.selector, from, to, tokenId, data)));\n    }\n  }\n\n  /**\n   * @notice Get total number of tokens owned by wallet.\n   * @dev Used to see total amount of tokens owned by a specific wallet.\n   * @param wallet Address for which to get token balance.\n   * @return uint256 Returns an integer, representing total amount of tokens held by address.\n   */\n  function balanceOf(address wallet) public view returns (uint256) {\n    return _ownedTokensCount[wallet];\n  }\n\n  function burned(uint256 tokenId) public view returns (bool) {\n    return _burnedTokens[tokenId];\n  }\n\n  /**\n   * @notice Decimal places to have for totalSupply.\n   * @dev Since ERC721s are single, we use 0 as the decimal places to make sure a round number for totalSupply.\n   * @return uint256 Returns the number of decimal places to have for totalSupply.\n   */\n  function decimals() external pure returns (uint256) {\n    return 0;\n  }\n\n  function exists(uint256 tokenId) public view returns (bool) {\n    return _tokenOwner[tokenId] != address(0);\n  }\n\n  /**\n   * @notice Gets the approved address for the token.\n   * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\n   * @param tokenId Token id to get approved operator for.\n   * @return address Approved address for token.\n   */\n  function getApproved(uint256 tokenId) external view returns (address) {\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Checks if the address is approved.\n   * @dev Includes references to OpenSea and Rarible marketplace proxies.\n   * @param wallet Address of the wallet.\n   * @param operator Address of the marketplace operator.\n   * @return bool True if approved.\n   */\n  function isApprovedForAll(address wallet, address operator) external view returns (bool) {\n    return (_operatorApprovals[wallet][operator] || _sourceApproved(wallet, operator));\n  }\n\n  /**\n   * @notice Checks who the owner of a token is.\n   * @dev The token must exist.\n   * @param tokenId The token to look up.\n   * @return address Owner of the token.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address) {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(tokenOwner != address(0), \"ERC721: token does not exist\");\n    return tokenOwner;\n  }\n\n  /**\n   * @notice Get token by index.\n   * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256) {\n    require(index < _allTokens.length, \"ERC721: index out of bounds\");\n    return _allTokens[index];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for all tokens.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids minted.\n   */\n  function tokens(uint256 index, uint256 length) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _allTokens.length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _allTokens[index + i];\n    }\n  }\n\n  /**\n   * @notice Get token from wallet by index instead of token id.\n   * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\n   * @param wallet Specific address for which to get token for.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index in specified wallet.\n   */\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256) {\n    require(index < balanceOf(wallet), \"ERC721: index out of bounds\");\n    return _ownedTokens[wallet][index];\n  }\n\n  /**\n   * @notice Total amount of tokens in the collection.\n   * @dev Ignores burned tokens.\n   * @return uint256 Returns the total number of active (not burned) tokens.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _allTokens.length;\n  }\n\n  /**\n   * @notice Empty function that is triggered by external contract on NFT transfer.\n   * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\n   * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @return bytes4 Returns the interfaceId of onERC721Received.\n   */\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4) {\n    require(_isContract(_operator), \"ERC721: operator not contract\");\n    if (_isEventRegistered(HolographERC721Event.beforeOnERC721Received)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(\n            HolographedERC721.beforeOnERC721Received.selector,\n            _operator,\n            _from,\n            address(this),\n            _tokenId,\n            _data\n          )\n        )\n      );\n    }\n    try HolographERC721Interface(_operator).ownerOf(_tokenId) returns (address tokenOwner) {\n      require(tokenOwner == address(this), \"ERC721: contract not token owner\");\n    } catch {\n      revert(\"ERC721: token does not exist\");\n    }\n    if (_isEventRegistered(HolographERC721Event.afterOnERC721Received)) {\n      require(\n        _sourceCall(\n          abi.encodeWithSelector(\n            HolographedERC721.afterOnERC721Received.selector,\n            _operator,\n            _from,\n            address(this),\n            _tokenId,\n            _data\n          )\n        )\n      );\n    }\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Add a newly minted token into managed list of tokens.\n   * @param to Address of token owner for which to add the token.\n   * @param tokenId Id of token to add.\n   */\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\n    _ownedTokensCount[to]++;\n    _ownedTokens[to].push(tokenId);\n    _allTokensIndex[tokenId] = _allTokens.length;\n    _allTokens.push(tokenId);\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev All validation needs to be done before calling this function.\n   * @param wallet Address of current token owner.\n   * @param tokenId The token to burn.\n   */\n  function _burn(address wallet, uint256 tokenId) private {\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = address(0);\n    _registryTransfer(wallet, address(0), tokenId);\n    _removeTokenFromOwnerEnumeration(wallet, tokenId);\n    _burnedTokens[tokenId] = true;\n  }\n\n  /**\n   * @notice Deletes a token from the approval list.\n   * @dev Removes from count.\n   * @param tokenId T.\n   */\n  function _clearApproval(uint256 tokenId) private {\n    delete _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Mints an NFT.\n   * @dev Can to mint the token to the zero address and the token cannot already exist.\n   * @param to Address to mint to.\n   * @param tokenId The new token.\n   */\n  function _mint(address to, uint256 tokenId) private {\n    require(tokenId > 0, \"ERC721: token id cannot be zero\");\n    require(to != address(0), \"ERC721: minting to burn address\");\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");\n    _tokenOwner[tokenId] = to;\n    _registryTransfer(address(0), to, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    uint256 lastTokenIndex = _allTokens.length - 1;\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\n    _allTokens[tokenIndex] = lastTokenId;\n    _allTokensIndex[lastTokenId] = tokenIndex;\n    delete _allTokensIndex[tokenId];\n    delete _allTokens[lastTokenIndex];\n    _allTokens.pop();\n  }\n\n  /**\n   * @dev Remove a token from managed list of tokens.\n   * @param from Address of token owner for which to remove the token.\n   * @param tokenId Id of token to remove.\n   */\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n    _removeTokenFromAllTokensEnumeration(tokenId);\n    _ownedTokensCount[from]--;\n    uint256 lastTokenIndex = _ownedTokensCount[from];\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n    if (tokenIndex != lastTokenIndex) {\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from][tokenIndex] = lastTokenId;\n      _ownedTokensIndex[lastTokenId] = tokenIndex;\n    }\n    if (lastTokenIndex == 0) {\n      delete _ownedTokens[from];\n    } else {\n      delete _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from].pop();\n    }\n  }\n\n  /**\n   * @dev Primary private function that handles the transfer/mint/burn functionality.\n   * @param from Address from where token is being transferred. Zero address means it is being minted.\n   * @param to Address to whom the token is being transferred. Zero address means it is being burned.\n   * @param tokenId Id of token that is being transferred/minted/burned.\n   */\n  function _transferFrom(address from, address to, uint256 tokenId) private {\n    require(_tokenOwner[tokenId] == from, \"ERC721: token not owned\");\n    require(to != address(0), \"ERC721: use burn instead\");\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = to;\n    _registryTransfer(from, to, tokenId);\n    _removeTokenFromOwnerEnumeration(from, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _chain() private view returns (uint32) {\n    uint32 currentChain = HolographInterface(HolographerInterface(payable(address(this))).getHolograph())\n      .getHolographChainId();\n    if (currentChain != HolographerInterface(payable(address(this))).getOriginChain()) {\n      return currentChain;\n    }\n    return uint32(0);\n  }\n\n  /**\n   * @notice Checks if the token owner exists.\n   * @dev If the address is the zero address no owner exists.\n   * @param tokenId The affected token.\n   * @return bool True if it exists.\n   */\n  function _exists(uint256 tokenId) private view returns (bool) {\n    address tokenOwner = _tokenOwner[tokenId];\n    return tokenOwner != address(0);\n  }\n\n  function _sourceApproved(address _tokenWallet, address _tokenSpender) internal view returns (bool approved) {\n    if (_isEventRegistered(HolographERC721Event.onIsApprovedForAll)) {\n      HolographedERC721 sourceContract;\n      assembly {\n        sourceContract := sload(_sourceContractSlot)\n      }\n      if (sourceContract.onIsApprovedForAll(_tokenWallet, _tokenSpender)) {\n        approved = true;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if the address is an approved one.\n   * @dev Uses inlined checks for different usecases of approval.\n   * @param spender Address of the spender.\n   * @param tokenId The affected token.\n   * @return bool True if approved.\n   */\n  function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    address tokenOwner = _tokenOwner[tokenId];\n    return (spender == tokenOwner ||\n      _tokenApprovals[tokenId] == spender ||\n      _operatorApprovals[tokenOwner][spender] ||\n      _sourceApproved(tokenOwner, spender));\n  }\n\n  function _isApprovedStrict(address spender, uint256 tokenId) private view returns (bool) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    address tokenOwner = _tokenOwner[tokenId];\n    return (spender == tokenOwner || _operatorApprovals[tokenOwner][spender] || _sourceApproved(tokenOwner, spender));\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := staticcall(gas(), sload(_sourceContractSlot), 0, add(calldatasize(), 0x20), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Get the bridge contract address.\n   */\n  function _royalties() private view returns (address) {\n    return\n      HolographRegistryInterface(_holograph().getRegistry()).getContractTypeAddress(\n        // \"HolographRoyalties\" front zero padded to be 32 bytes\n        0x0000000000000000000000000000486f6c6f6772617068526f79616c74696573\n      );\n  }\n\n  function _registryTransfer(address _from, address _to, uint256 _tokenId) private {\n    emit Transfer(_from, _to, _tokenId);\n    HolographRegistryInterface(_holograph().getRegistry()).holographableEvent(\n      abi.encode(\n        // keccak256(\"TransferERC721(address,address,uint256)\")\n        bytes32(0x351b8d13789e4d8d2717631559251955685881a31494dd0b8b19b4ef8530bb6d),\n        _from,\n        _to,\n        _tokenId\n      )\n    );\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  event FundsReceived(address indexed source, uint256 amount);\n\n  receive() external payable {\n    emit FundsReceived(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    // Check if royalties support the function, send there, otherwise revert to source\n    address _target;\n    if (HolographInterfacesInterface(_interfaces()).supportsInterface(InterfaceType.ROYALTIES, msg.sig)) {\n      _target = _royalties();\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    } else {\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        mstore(calldatasize(), caller())\n        let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 0x20), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  /*\n   * @dev all calls to source contract go through this function in order to inject original msg.sender in calldata\n   */\n  function _sourceCall(bytes memory payload) private returns (bool output) {\n    assembly {\n      mstore(add(payload, add(mload(payload), 0x20)), caller())\n      // offset memory position by 32 bytes to skip the 32 bytes where bytes length is stored\n      // add 32 bytes to bytes length to include the appended msg.sender to calldata\n      let result := call(\n        gas(),\n        sload(_sourceContractSlot),\n        callvalue(),\n        add(payload, 0x20),\n        add(mload(payload), 0x20),\n        0,\n        0\n      )\n      let pos := mload(0x40)\n      // reserve memory space for return data\n      mstore(0x40, add(pos, returndatasize()))\n      returndatacopy(pos, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(pos, returndatasize())\n      }\n      output := mload(pos)\n    }\n  }\n\n  function _isEventRegistered(HolographERC721Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n"
    },
    "src/enforcer/HolographGeneric.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographGenericEvent.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/HolographGenericInterface.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedGeneric.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\n/**\n * @title Holograph Bridgeable Generic Contract\n * @author Holograph Foundation\n * @notice A smart contract for creating custom bridgeable logic.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographGeneric is Admin, Owner, Initializable, HolographGenericInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"GENERIC: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"GENERIC: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"GENERIC: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (uint256 eventConfig, bool skipInit, bytes memory initCode) = abi.decode(initPayload, (uint256, bool, bytes));\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"GENERIC: could not init source\");\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Allows for source smart contract to withdraw contract balance.\n   */\n  function sourceTransfer(address payable destination, uint256 amount) external onlySource {\n    destination.transfer(amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to make calls to external contracts\n   */\n  function sourceExternalCall(address target, bytes calldata data) external onlySource {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 0x20), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function _sourceCall(bytes memory payload) private returns (bool output) {\n    assembly {\n      let pos := mload(0x40)\n      mstore(0x40, add(pos, 0x20))\n      mstore(add(payload, add(mload(payload), 0x20)), caller())\n      // offset memory position by 32 bytes to skip the 32 bytes where bytes length is stored\n      // add 32 bytes to bytes length to include the appended msg.sender to calldata\n      let result := call(\n        gas(),\n        sload(_sourceContractSlot),\n        callvalue(),\n        add(payload, 0x20),\n        add(mload(payload), 0x20),\n        0,\n        0\n      )\n      returndatacopy(pos, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      output := mload(pos)\n    }\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.GENERIC, interfaceId) || erc165Contract.supportsInterface(interfaceId) // check global interfaces // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    if (_isEventRegistered(HolographGenericEvent.bridgeIn)) {\n      require(\n        _sourceCall(abi.encodeWithSelector(HolographedGeneric.bridgeIn.selector, fromChain, payload)),\n        \"HOLOGRAPH: bridge in failed\"\n      );\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    if (_isEventRegistered(HolographGenericEvent.bridgeOut)) {\n      bytes memory sourcePayload = abi.encodeWithSelector(\n        HolographedGeneric.bridgeOut.selector,\n        toChain,\n        sender,\n        payload\n      );\n      assembly {\n        // it is important to add 32 bytes in order to accommodate the first 32 bytes being used for storing length of bytes\n        mstore(add(sourcePayload, add(mload(sourcePayload), 0x20)), caller())\n        let result := call(\n          gas(),\n          sload(_sourceContractSlot),\n          callvalue(),\n          // start reading data from memory position, plus 32 bytes, to skip bytes length indicator\n          add(sourcePayload, 0x20),\n          // add an additional 32 bytes to bytes length to include the appended caller address\n          add(mload(sourcePayload), 0x20),\n          0,\n          0\n        )\n        // when reading back data, skip the first 32 bytes which is used to indicate bytes position in calldata\n        // also subtract 32 bytes from returndatasize to accomodate the skipped first 32 bytes\n        returndatacopy(data, 0x20, sub(returndatasize(), 0x20))\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n      }\n    }\n    return (Holographable.bridgeOut.selector, data);\n  }\n\n  /**\n   * @dev Allows for source smart contract to emit events.\n   */\n  function sourceEmit(bytes calldata eventData) external onlySource {\n    assembly {\n      calldatacopy(0, eventData.offset, eventData.length)\n      log0(0, eventData.length)\n    }\n  }\n\n  function sourceEmit(bytes32 eventId, bytes calldata eventData) external onlySource {\n    assembly {\n      calldatacopy(0, eventData.offset, eventData.length)\n      log1(0, eventData.length, eventId)\n    }\n  }\n\n  function sourceEmit(bytes32 eventId, bytes32 topic1, bytes calldata eventData) external onlySource {\n    assembly {\n      calldatacopy(0, eventData.offset, eventData.length)\n      log2(0, eventData.length, eventId, topic1)\n    }\n  }\n\n  function sourceEmit(bytes32 eventId, bytes32 topic1, bytes32 topic2, bytes calldata eventData) external onlySource {\n    assembly {\n      calldatacopy(0, eventData.offset, eventData.length)\n      log3(0, eventData.length, eventId, topic1, topic2)\n    }\n  }\n\n  function sourceEmit(\n    bytes32 eventId,\n    bytes32 topic1,\n    bytes32 topic2,\n    bytes32 topic3,\n    bytes calldata eventData\n  ) external onlySource {\n    assembly {\n      calldatacopy(0, eventData.offset, eventData.length)\n      log4(0, eventData.length, eventId, topic1, topic2, topic3)\n    }\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceGeneric() private view returns (HolographedGeneric sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _isEventRegistered(HolographGenericEvent _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n"
    },
    "src/enforcer/HolographRoyalties.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographRoyaltiesInterface.sol\";\n\nimport \"../struct/ZoraBidShares.sol\";\n\n/**\n * @title HolographRoyalties\n * @author Holograph Foundation\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract HolographRoyalties is Admin, Owner, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.ROYALTIES.defaultBp')) - 1)\n   */\n  bytes32 constant _defaultBpSlot = 0xff29fcf645501423fd56e0287670f6813a1e5db5cf706428bc8516381e7ffe81;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.ROYALTIES.defaultReceiver')) - 1)\n   */\n  bytes32 constant _defaultReceiverSlot = 0x00b381815b89a20a37ee91e8a0119be5e16f6d1668377e7ae457213a74a415bb;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.ROYALTIES.initialized')) - 1)\n   */\n  bytes32 constant _initializedPaidSlot = 0x91428d26cb4818e4e627ebb64c06b5a67b82f313516b5c903cf07a00681c95f6;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.ROYALTIES.payout.addresses')) - 1)\n   */\n  bytes32 constant _payoutAddressesSlot = 0xf31f2a3a453a7aa2f3054423a8c5474ac9817ea457b458152967bbcb12ed6a43;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.ROYALTIES.payout.bps')) - 1)\n   */\n  bytes32 constant _payoutBpsSlot = 0xa4023567d5b5f01c63e00d90785d7cd4ff057a237ad185c5ecade8f4059fb61a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.ROYALTIES.extendedCall')) - 1)\n   * @dev extendedCall is an init config used to determine if payouts should be sent via a call or a transfer.\n   */\n  bytes32 constant _extendedCallSlot = 0x254926eafdecb56f669f96a3a752fbca17becd902481431df613768b1f903fa3;\n\n  string constant _bpString = \"eip1967.Holograph.ROYALTIES.bp\";\n  string constant _receiverString = \"eip1967.Holograph.ROYALTIES.receiver\";\n  string constant _tokenAddressString = \"eip1967.Holograph.ROYALTIES.tokenAddress\";\n\n  /**\n   * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n   * @dev Emits event in order to comply with Rarible V1 royalty spec.\n   * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n   * @param recipients Address array of wallets that will receive tha royalties.\n   * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts.\n   *            Make sure that all the base points add up to a total of 10000.\n   */\n  event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n  /**\n   * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n   */\n  modifier onlyOwner() override {\n    require(isOwner(), \"ROYALTIES: caller not an owner\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ROYALTIES: already initialized\");\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_ownerSlot, caller())\n    }\n    uint256 bp = abi.decode(initPayload, (uint256));\n    setRoyalties(0, payable(address(this)), bp);\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function initHolographRoyalties(bytes memory initPayload) external returns (bytes4) {\n    uint256 initialized;\n    assembly {\n      initialized := sload(_initializedPaidSlot)\n    }\n    require(initialized == 0, \"ROYALTIES: already initialized\");\n    (uint256 bp, uint256 useExtenededCall) = abi.decode(initPayload, (uint256, uint256));\n    if (useExtenededCall > 0) {\n      useExtenededCall = 1;\n    }\n    assembly {\n      sstore(_extendedCallSlot, useExtenededCall)\n    }\n    setRoyalties(0, payable(address(this)), bp);\n    address payable[] memory addresses = new address payable[](1);\n    addresses[0] = payable(Owner(HolographerInterface(address(this)).getSourceContract()).owner());\n    uint256[] memory bps = new uint256[](1);\n    bps[0] = 10000;\n    _setPayoutAddresses(addresses);\n    _setPayoutBps(bps);\n    initialized = 1;\n    assembly {\n      sstore(_initializedPaidSlot, initialized)\n    }\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Check if message sender is a legitimate owner of the smart contract\n   * @dev We check owner, admin, and identity for a more comprehensive coverage.\n   * @return Returns true is message sender is an owner.\n   */\n  function isOwner() private view returns (bool) {\n    return (msg.sender == getOwner() ||\n      msg.sender == getAdmin() ||\n      msg.sender == Owner(HolographerInterface(address(this)).getSourceContract()).owner());\n  }\n\n  /**\n   * @dev This is here in place to prevent reverts in case contract is used outside of the protocol.\n   */\n  function getSourceContract() external view returns (address sourceContract) {\n    sourceContract = address(this);\n  }\n\n  /**\n   * @dev Gets the default royalty payment receiver address from storage slot.\n   * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _getDefaultReceiver() private view returns (address payable receiver) {\n    assembly {\n      receiver := sload(_defaultReceiverSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty payment receiver address to storage slot.\n   * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _setDefaultReceiver(address receiver) private {\n    assembly {\n      sstore(_defaultReceiverSlot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the default royalty base points(percentage) from storage slot.\n   * @return bp Royalty base points(percentage) for royalty payouts.\n   */\n  function _getDefaultBp() private view returns (uint256 bp) {\n    assembly {\n      bp := sload(_defaultBpSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty base points(percentage) to storage slot.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function _setDefaultBp(uint256 bp) private {\n    assembly {\n      sstore(_defaultBpSlot, bp)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n   * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _getReceiver(uint256 tokenId) private view returns (address payable receiver) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      receiver := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the receiver for.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _setReceiver(uint256 tokenId, address receiver) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      sstore(slot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n   * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n   */\n  function _getBp(uint256 tokenId) private view returns (uint256 bp) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      bp := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the base points for.\n   * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n   */\n  function _setBp(uint256 tokenId, uint256 bp) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      sstore(slot, bp)\n    }\n  }\n\n  function _getPayoutAddresses() private view returns (address payable[] memory addresses) {\n    // The slot hash has been precomputed for gas optimizaion\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    addresses = new address payable[](length);\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      addresses[i] = value;\n    }\n  }\n\n  function _setPayoutAddresses(address payable[] memory addresses) private {\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length = addresses.length;\n    assembly {\n      sstore(slot, length)\n    }\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = addresses[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getPayoutBps() private view returns (uint256[] memory bps) {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    bps = new uint256[](length);\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      bps[i] = value;\n    }\n  }\n\n  function _setPayoutBps(uint256[] memory bps) private {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length = bps.length;\n    assembly {\n      sstore(slot, length)\n    }\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = bps[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      tokenAddress := sload(slot)\n    }\n  }\n\n  function _setTokenAddress(string memory tokenName, address tokenAddress) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      sstore(slot, tokenAddress)\n    }\n  }\n\n  /**\n   * @dev Private function that transfers ETH to all payout recipients.\n   * @dev This contract is designed primarily to capture royalties, but is limited in payout logic.\n   * @dev This function uses a push payment model, where the contract pushes the ETH to the recipients.\n   * @dev The design is intended so that royalty distribution logic can be handled externally via payment distribution contracts.\n   * @dev The recommended usage for royalty structures that require more complex payout logic to multiple recipients is to\n   *      set 100% ownership payout with the recipient being the payment distribution contract.\n   */\n  function _payoutEth() private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    uint256 balance = address(this).balance;\n    uint256 sending;\n    bool extendedCall;\n    assembly {\n      extendedCall := sload(_extendedCallSlot)\n    }\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      // only send value if it is greater than 0\n      if (sending > 0) {\n        // If the contract enabled extended call on init then use call to transfer, otherwise use transfer\n        if (extendedCall == true) {\n          (bool success, ) = addresses[i].call{value: sending}(\"\");\n          require(success, \"ROYALTIES: Transfer failed\");\n        } else {\n          addresses[i].transfer(sending);\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Private function that transfers tokens to all payout recipients.\n   * @dev ERC20 tokens that use fee on transfer are not supported.\n   * @dev This contract is designed primarily to capture royalties, but is limited in payout logic.\n   * @dev This function uses a push payment model, where the contract pushes the ETH to the recipients.\n   * @dev The design is intended so that royalty distribution logic can be handled externally via payment distribution contracts.\n   * @dev The recommended usage for royalty structures that require more complex payout logic to multiple recipients is to\n   *      set 100% ownership payout with the recipient being the payment distribution contract.\n   *\n   * @param tokenAddress Smart contract address of ERC20 token.\n   */\n  function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    uint256 sending;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      // Some tokens revert when transferring a zero value amount this check ensures if one recipient's\n      // amount is zero, the transfer will still succeed for the other recipients.\n      if (sending > 0) {\n        require(\n          _callOptionalReturn(\n            tokenAddress,\n            erc20.transfer.selector,\n            abi.encode(address(addresses[i]), uint256(sending))\n          ),\n          \"ROYALTIES: ERC20 transfer failed\"\n        );\n      }\n    }\n  }\n\n  /**\n   * @dev Private function that transfers multiple tokens to all payout recipients.\n   * @dev Try to use _payoutToken and handle each token individually.\n   * @dev ERC20 tokens that use fee on transfer are not supported.\n   * @dev This contract is designed primarily to capture royalties, but is limited in payout logic.\n   * @dev This function uses a push payment model, where the contract pushes the ETH to the recipients.\n   * @dev The design is intended so that royalty distribution logic can be handled externally via payment distribution contracts.\n   * @dev The recommended usage for royalty structures that require more complex payout logic to multiple recipients is to\n   *      set 100% ownership payout with the recipient being the payment distribution contract.\n   *\n   * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n   */\n  function _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        // Some tokens revert when transferring a zero value amount this check ensures if one recipient's\n        // amount is zero, the transfer will still succeed for the other recipients.\n        if (sending > 0) {\n          require(\n            _callOptionalReturn(\n              tokenAddresses[t],\n              erc20.transfer.selector,\n              abi.encode(address(addresses[i]), uint256(sending))\n            ),\n            \"ROYALTIES: ERC20 transfer failed\"\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev This function validates that the call is being made by an authorised wallet.\n   * @dev Will revert entire tranaction if it fails.\n   */\n  function _validatePayoutRequestor() private view {\n    if (!isOwner()) {\n      bool matched;\n      address payable[] memory addresses = _getPayoutAddresses();\n      address payable sender = payable(msg.sender);\n      for (uint256 i = 0; i < addresses.length; i++) {\n        if (addresses[i] == sender) {\n          matched = true;\n          break;\n        }\n      }\n      require(matched, \"ROYALTIES: sender not authorized\");\n    }\n  }\n\n  /**\n   * @notice Set the wallets and percentages for royalty payouts.\n   *         Limited to 10 wallets to prevent out of gas errors.\n   *         For more complex royalty structures, set 100% ownership payout with the recipient being the payment distribution contract.\n   * @dev Function can only we called by owner, admin, or identity wallet.\n   * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n   * @param addresses An array of all the addresses that will be receiving royalty payouts.\n   * @param bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) public onlyOwner {\n    require(addresses.length == bps.length, \"ROYALTIES: missmatched lenghts\");\n    require(addresses.length <= 10, \"ROYALTIES: max 10 addresses\");\n    uint256 totalBp;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      require(addresses[i] != address(0), \"ROYALTIES: payee is zero address\");\n      require(bps[i] > 0, \"ROYALTIES: bp is zero\");\n      totalBp = totalBp + bps[i];\n    }\n    require(totalBp == 10000, \"ROYALTIES: bps must equal 10000\");\n    _setPayoutAddresses(addresses);\n    _setPayoutBps(bps);\n  }\n\n  /**\n   * @notice Show the wallets and percentages of payout recipients.\n   * @dev These are the recipients that will be getting royalty payouts.\n   * @return addresses An array of all the addresses that will be receiving royalty payouts.\n   * @return bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function getPayoutInfo() public view returns (address payable[] memory addresses, uint256[] memory bps) {\n    addresses = _getPayoutAddresses();\n    bps = _getPayoutBps();\n  }\n\n  /**\n   * @notice Get payout of all ETH in smart contract.\n   * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n   */\n  function getEthPayout() public {\n    _validatePayoutRequestor();\n    _payoutEth();\n  }\n\n  /**\n   * @notice Get payout for a specific token address. Token must have a positive balance!\n   * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n   * @param tokenAddress An address of the token for which to issue payouts for.\n   */\n  function getTokenPayout(address tokenAddress) public {\n    _validatePayoutRequestor();\n    _payoutToken(tokenAddress);\n  }\n\n  /**\n   * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n   * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n   * @param tokenAddresses An address array of tokens to issue payouts for.\n   */\n  function getTokensPayout(address[] memory tokenAddresses) public {\n    _validatePayoutRequestor();\n    _payoutTokens(tokenAddresses);\n  }\n\n  /**\n   * @notice Set the royalty information for entire contract, or a specific token.\n   * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n   * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function setRoyalties(uint256 tokenId, address payable receiver, uint256 bp) public onlyOwner {\n    require(receiver != address(0), \"ROYALTIES: receiver is zero address\");\n    require(bp <= 10000, \"ROYALTIES: base points over 100%\");\n    if (tokenId == 0) {\n      _setDefaultReceiver(receiver);\n      _setDefaultBp(bp);\n    } else {\n      _setReceiver(tokenId, receiver);\n      _setBp(tokenId, bp);\n    }\n    address[] memory receivers = new address[](1);\n    receivers[0] = address(receiver);\n    uint256[] memory bps = new uint256[](1);\n    bps[0] = bp;\n    emit SecondarySaleFees(tokenId, receivers, bps);\n  }\n\n  // IEIP2981\n  function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n    } else {\n      return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n    }\n  }\n\n  // Rarible V1\n  function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      bps[0] = _getDefaultBp();\n    } else {\n      bps[0] = _getBp(tokenId);\n    }\n    return bps;\n  }\n\n  // Rarible V1\n  function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n    }\n    return receivers;\n  }\n\n  // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n  // struct Part {\n  //     address payable account;\n  //     uint96 value;\n  // }\n\n  // function getRoyalties(uint256 tokenId) public view returns (Part[] memory) {\n  //     return royalties[id];\n  // }\n\n  // Manifold\n  function getRoyalties(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // Foundation\n  function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // SuperRare\n  // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n  // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n  // We'll just leave this here for just in case they open the flood gates.\n  function tokenCreator(\n    address,\n    /* contractAddress*/\n    uint256 tokenId\n  ) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // SuperRare\n  function calculateRoyaltyFee(\n    address,\n    /* contractAddress */\n    uint256 tokenId,\n    uint256 amount\n  ) public view returns (uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultBp() * amount) / 10000;\n    } else {\n      return (_getBp(tokenId) * amount) / 10000;\n    }\n  }\n\n  // Holograph\n  // we indicate that this contract operates market functions\n  function marketContract() public view returns (address) {\n    return address(this);\n  }\n\n  // Holograph\n  // we indicate that the receiver is the creator, to convince the smart contract to pay\n  function tokenCreators(uint256 tokenId) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // Holograph\n  // we provide the percentage that needs to be paid out from the sale\n  function bidSharesForToken(uint256 tokenId) public view returns (HolographBidShares memory bidShares) {\n    // this information is outside of the scope of our\n    bidShares.prevOwner.value = 0;\n    bidShares.owner.value = 0;\n    if (_getReceiver(tokenId) == address(0)) {\n      bidShares.creator.value = _getDefaultBp() * (10 ** 16);\n    } else {\n      bidShares.creator.value = _getBp(tokenId) * (10 ** 16);\n    }\n    return bidShares;\n  }\n\n  /**\n   * @notice Get the smart contract address of a token by common name.\n   * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n   * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n   * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n   */\n  function getTokenAddress(string memory tokenName) public view returns (address) {\n    return _getTokenAddress(tokenName);\n  }\n\n  /**\n   * @notice Used to wrap function calls to check if they return without revert regardless of return type.\n   * @dev Checks if wrapped function opcode is a revert, if it is then it reverts as well, if it's not then\n   *      it checks for return data, if return data exists, it is returned as a bool,\n   *      if return data does not exist (0 length) then success is expected and returns true\n   * @return Returns true if the wrapped function call returns without a revert even if it doesn't return true.\n   */\n  function _callOptionalReturn(address target, bytes4 functionSignature, bytes memory payload) internal returns (bool) {\n    bytes memory data = abi.encodePacked(functionSignature, payload);\n    bool success = true;\n    assembly {\n      let result := call(gas(), target, callvalue(), add(data, 0x20), mload(data), 0, 0)\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        if gt(returndatasize(), 0) {\n          returndatacopy(success, 0, 0x20)\n        }\n      }\n    }\n    return success;\n  }\n}\n"
    },
    "src/enum/ChainIdType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum ChainIdType {\n  UNDEFINED, //  0\n  EVM, //        1\n  HOLOGRAPH, //  2\n  LAYERZERO, //  3\n  HYPERLANE //   4\n}\n"
    },
    "src/enum/HolographERC20Event.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum HolographERC20Event {\n  UNDEFINED, // 0\n  bridgeIn, //  1\n  bridgeOut, //  2\n  afterApprove, //  3\n  beforeApprove, //  4\n  afterOnERC20Received, //  5\n  beforeOnERC20Received, //  6\n  afterBurn, //  7\n  beforeBurn, //  8\n  afterMint, //  9\n  beforeMint, // 10\n  afterSafeTransfer, // 11\n  beforeSafeTransfer, // 12\n  afterTransfer, // 13\n  beforeTransfer, // 14\n  onAllowance // 15\n}\n"
    },
    "src/enum/HolographERC721Event.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum HolographERC721Event {\n  UNDEFINED, // 0\n  bridgeIn, //  1\n  bridgeOut, //  2\n  afterApprove, //  3\n  beforeApprove, //  4\n  afterApprovalAll, //  5\n  beforeApprovalAll, //  6\n  afterBurn, //  7\n  beforeBurn, //  8\n  afterMint, //  9\n  beforeMint, // 10\n  afterSafeTransfer, // 11\n  beforeSafeTransfer, // 12\n  afterTransfer, // 13\n  beforeTransfer, // 14\n  beforeOnERC721Received, // 15\n  afterOnERC721Received, // 16\n  onIsApprovedForAll, // 17\n  customContractURI // 18\n}\n"
    },
    "src/enum/HolographGenericEvent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum HolographGenericEvent {\n  UNDEFINED, // 0\n  bridgeIn, //  1\n  bridgeOut //  2\n}\n"
    },
    "src/enum/InterfaceType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum InterfaceType {\n  UNDEFINED, // 0\n  ERC20, //     1\n  ERC721, //    2\n  ERC1155, //   3\n  ROYALTIES, // 4\n  GENERIC //    5\n}\n"
    },
    "src/enum/TokenUriType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum TokenUriType {\n  UNDEFINED, //   0\n  IPFS, //        1\n  HTTPS, //       2\n  ARWEAVE //      3\n}\n"
    },
    "src/extension/BatchMintMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  @title   Batch-mint Metadata\n *  @notice  The `BatchMintMetadata` is a contract extension for any base NFT contract. It lets the smart contract\n *           using this extension set metadata for `n` number of NFTs all at once. This is enabled by storing a single\n *           base URI for a batch of `n` NFTs, where the metadata for each NFT in a relevant batch is `baseURIs/tokenId`.\n */\n\ncontract BatchMintMetadata {\n  /// @dev Invalid index for batch\n  error BatchMintInvalidBatchId(uint256 index);\n\n  /// @dev Invalid token\n  error BatchMintInvalidTokenId(uint256 tokenId);\n\n  /// @dev Metadata frozen\n  error BatchMintMetadataFrozen(uint256 batchId);\n\n  /// @dev Largest tokenId of each batch of tokens with the same baseURIs + 1 {ex: batchId 100 at position 0 includes tokens 0-99}\n  uint256[] internal batchIds;\n\n  /// @dev Mapping from id of a batch of tokens => to base URI for the respective batch of tokens.\n  mapping(uint256 => string) internal baseURIs;\n\n  /// @dev Mapping from id of a batch of tokens => to whether the base URI for the respective batch of tokens is frozen.\n  mapping(uint256 => bool) public batchFrozen;\n\n  /// @dev This event emits when the metadata of all tokens are frozen.\n  /// While not currently supported by marketplaces, this event allows\n  /// future indexing if desired.\n  event MetadataFrozen();\n\n  // @dev This event emits when the metadata of a range of tokens is updated.\n  /// So that the third-party platforms such as NFT market could\n  /// timely update the images and related attributes of the NFTs.\n  event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n\n  /**\n   *  @notice         Returns the count of batches of NFTs.\n   *  @dev            Each batch of tokens has an in ID and an associated `baseURIs`.\n   *                  See {batchIds}.\n   */\n  function getBaseURICount() public view returns (uint256) {\n    return batchIds.length;\n  }\n\n  /**\n   *  @notice         Returns the ID for the batch of tokens at the given index.\n   *  @dev            See {getBaseURICount}.\n   *  @param _index   Index of the desired batch in batchIds array.\n   */\n  function getBatchIdAtIndex(uint256 _index) public view returns (uint256) {\n    if (_index >= getBaseURICount()) {\n      revert BatchMintInvalidBatchId(_index);\n    }\n    return batchIds[_index];\n  }\n\n  /// @dev Returns the id for the batch of tokens the given tokenId belongs to.\n  function _getBatchId(uint256 _tokenId) internal view returns (uint256 batchId, uint256 index) {\n    uint256 numOfTokenBatches = getBaseURICount();\n    uint256[] memory indices = batchIds;\n\n    for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\n      if (_tokenId < indices[i]) {\n        index = i;\n        batchId = indices[i];\n\n        return (batchId, index);\n      }\n    }\n\n    revert BatchMintInvalidTokenId(_tokenId);\n  }\n\n  /// @dev Returns the baseURIs for a token. The intended metadata URI for the token is baseURIs + tokenId.\n  function _getBaseURI(uint256 _tokenId) internal view returns (string memory) {\n    uint256 numOfTokenBatches = getBaseURICount();\n    uint256[] memory indices = batchIds;\n\n    for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\n      if (_tokenId < indices[i]) {\n        return baseURIs[indices[i]];\n      }\n    }\n\n    revert BatchMintInvalidTokenId(_tokenId);\n  }\n\n  /// @dev returns the starting tokenId of a given batchId.\n  function _getBatchStartId(uint256 _batchID) internal view returns (uint256) {\n    uint256 numOfTokenBatches = getBaseURICount();\n    uint256[] memory indices = batchIds;\n\n    for (uint256 i = 0; i < numOfTokenBatches; i++) {\n      if (_batchID == indices[i]) {\n        if (i > 0) {\n          return indices[i - 1];\n        }\n        return 0;\n      }\n    }\n\n    revert BatchMintInvalidBatchId(_batchID);\n  }\n\n  /// @dev Sets the base URI for the batch of tokens with the given batchId.\n  function _setBaseURI(uint256 _batchId, string memory _baseURIs) internal {\n    if (batchFrozen[_batchId]) {\n      revert BatchMintMetadataFrozen(_batchId);\n    }\n    baseURIs[_batchId] = _baseURIs;\n    emit BatchMetadataUpdate(_getBatchStartId(_batchId), _batchId);\n  }\n\n  /// @dev Freezes the base URI for the batch of tokens with the given batchId.\n  function _freezeBaseURI(uint256 _batchId) internal {\n    string memory baseURIsForBatch = baseURIs[_batchId];\n    if (bytes(baseURIsForBatch).length == 0) {\n      revert BatchMintInvalidBatchId(_batchId);\n    }\n    batchFrozen[_batchId] = true;\n    emit MetadataFrozen();\n  }\n\n  /// @dev Mints a batch of tokenIds and associates a common baseURIs to all those Ids.\n  function _batchMintMetadata(\n    uint256 _startId,\n    uint256 _amountToMint,\n    string memory _baseURIsForTokens\n  ) internal returns (uint256 nextTokenIdToMint, uint256 batchId) {\n    batchId = _startId + _amountToMint;\n    nextTokenIdToMint = batchId;\n\n    batchIds.push(batchId);\n\n    baseURIs[batchId] = _baseURIsForTokens;\n  }\n}\n"
    },
    "src/extension/InitializableLazyMint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/LazyMintInitializableInterface.sol\";\nimport \"./LazyMint.sol\";\n\n/**\n * @title Initializable Lazy Mint\n * @author https://github.com/holographxyz\n * @notice Allow to initialize a default nextTokenIdToLazyMint\n * @dev This allows to synchronize the nextTokenIdToLazyMint with a custom tokenId management\n */\nabstract contract InitializableLazyMint is LazyMint, LazyMintInitializableInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.lazyMintInitialized')) - 1)\n   */\n  bytes32 constant _lazyMintInitializedSlot = 0x48d0e47abf92fdd55242caeea30ef9b630788bb50b5c07884bc96bb0c942c6c1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function syncLazyMint() external virtual returns (uint256);\n\n  function _isLazyMintInitialized() internal view returns (bool lazyMintInitialized) {\n    assembly {\n      lazyMintInitialized := sload(_lazyMintInitializedSlot)\n    }\n  }\n\n  function _setLazyMintInitialized() internal {\n    assembly {\n      sstore(_lazyMintInitializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "src/extension/LazyMint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/ILazyMint.sol\";\nimport \"./BatchMintMetadata.sol\";\n\n/**\n *  The `LazyMint` is a contract extension for any base NFT contract. It lets you 'lazy mint' any number of NFTs\n *  at once. Here, 'lazy mint' means defining the metadata for particular tokenIds of your NFT contract, without actually\n *  minting a non-zero balance of NFTs of those tokenIds.\n */\n\nabstract contract LazyMint is ILazyMint, BatchMintMetadata {\n  /// @dev The sender is not authorized to perform the action\n  error LazyMintUnauthorized();\n  error LazyMintInvalidAmount();\n\n  /// @notice The tokenId assigned to the next new NFT to be lazy minted.\n  uint256 internal nextTokenIdToLazyMint;\n\n  /**\n   *  @notice                  Lets an authorized address lazy mint a given amount of NFTs.\n   *\n   *  @param _amount           The number of NFTs to lazy mint.\n   *  @param _baseURIForTokens The base URI for the 'n' number of NFTs being lazy minted, where the metadata for each\n   *                           of those NFTs is `${baseURIForTokens}/${tokenId}`.\n   *  @param _data             Additional bytes data to be used at the discretion of the consumer of the contract.\n   *  @return batchId          A unique integer identifier for the batch of NFTs lazy minted together.\n   */\n  function lazyMint(\n    uint256 _amount,\n    string memory _baseURIForTokens,\n    bytes memory _data\n  ) internal virtual returns (uint256 batchId) {\n    if (!_canLazyMint()) {\n      revert LazyMintUnauthorized();\n    }\n\n    if (_amount == 0) {\n      revert LazyMintInvalidAmount();\n    }\n\n    uint256 startId = nextTokenIdToLazyMint;\n\n    (nextTokenIdToLazyMint, batchId) = _batchMintMetadata(startId, _amount, _baseURIForTokens);\n\n    emit TokensLazyMinted(startId, startId + _amount - 1, _baseURIForTokens, _data);\n\n    return batchId;\n  }\n\n  /// @dev Returns whether lazy minting can be performed in the given execution context.\n  function _canLazyMint() internal view virtual returns (bool);\n}\n"
    },
    "src/faucet/Faucet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/InitializableInterface.sol\";\n\ncontract Faucet is Initializable {\n  address public owner;\n  HolographERC20Interface public token;\n\n  uint256 public faucetDripAmount = 100 ether;\n  uint256 public faucetCooldown = 24 hours;\n\n  mapping(address => uint256) lastAccessTime;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"Faucet contract is already initialized\");\n    (address _contractOwner, address _tokenInstance) = abi.decode(initPayload, (address, address));\n    token = HolographERC20Interface(_tokenInstance);\n    owner = _contractOwner;\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /// @notice Get tokens from faucet's own balance. Rate limited.\n  function requestTokens() external {\n    require(isAllowedToWithdraw(msg.sender), \"Come back later\");\n    require(token.balanceOf(address(this)) >= faucetDripAmount, \"Faucet is empty\");\n    lastAccessTime[msg.sender] = block.timestamp;\n    token.transfer(msg.sender, faucetDripAmount);\n  }\n\n  /// @notice Update token address\n  function setToken(address tokenAddress) external onlyOwner {\n    token = HolographERC20Interface(tokenAddress);\n  }\n\n  /// @notice Grant tokens to receiver from faucet's own balance. Not rate limited.\n  function grantTokens(address _address) external onlyOwner {\n    require(token.balanceOf(address(this)) >= faucetDripAmount, \"Faucet is empty\");\n    token.transfer(_address, faucetDripAmount);\n  }\n\n  function grantTokens(address _address, uint256 _amountWei) external onlyOwner {\n    require(token.balanceOf(address(this)) >= _amountWei, \"Insufficient funds\");\n    token.transfer(_address, _amountWei);\n  }\n\n  /// @notice Withdraw all funds from the faucet.\n  function withdrawAllTokens(address _receiver) external onlyOwner {\n    token.transfer(_receiver, token.balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw amount of funds from the faucet. Amount is in wei.\n  function withdrawTokens(address _receiver, uint256 _amountWei) external onlyOwner {\n    require(token.balanceOf(address(this)) >= _amountWei, \"Insufficient funds\");\n    token.transfer(_receiver, _amountWei);\n  }\n\n  /// @notice Configure the time between two drip requests. Time is in seconds.\n  function setWithdrawCooldown(uint256 _waitTimeSeconds) external onlyOwner {\n    faucetCooldown = _waitTimeSeconds;\n  }\n\n  /// @notice Configure the drip request amount. Amount is in wei.\n  function setWithdrawAmount(uint256 _amountWei) external onlyOwner {\n    faucetDripAmount = _amountWei;\n  }\n\n  /// @notice Check whether an address can request drip and is not on cooldown.\n  function isAllowedToWithdraw(address _address) public view returns (bool) {\n    if (lastAccessTime[_address] == 0) {\n      return true;\n    } else if (block.timestamp >= lastAccessTime[_address] + faucetCooldown) {\n      return true;\n    }\n    return false;\n  }\n\n  /// @notice Get the last time the address withdrew tokens.\n  function getLastAccessTime(address _address) public view returns (uint256) {\n    return lastAccessTime[_address];\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Caller is not the owner\");\n    _;\n  }\n}\n"
    },
    "src/Holograph.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/InitializableInterface.sol\";\nimport \"./interface/HolographInterface.sol\";\n\n/**\n * @title Holograph Protocol\n * @author https://github.com/holographxyz\n * @notice This is the primary Holograph Protocol smart contract\n * @dev This contract stores a reference to all the primary modules and variables of the protocol\n */\ncontract Holograph is Admin, Initializable, HolographInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.chainId')) - 1)\n   */\n  bytes32 constant _chainIdSlot = 0x7651bfc11f7485d07ab2b41c1312e2007c8cb7efb0f7352a6dee4a1153eebab2;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.factory')) - 1)\n   */\n  bytes32 constant _factorySlot = 0xa49f20855ba576e09d13c8041c8039fa655356ea27f6c40f1ec46a4301cd5b23;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographChainId')) - 1)\n   */\n  bytes32 constant _holographChainIdSlot = 0xd840a780c26e07edc6e1ee2eaa6f134ed5488dbd762614116653cee8542a3844;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.treasury')) - 1)\n   */\n  bytes32 constant _treasurySlot = 0x4215e7a38d75164ca078bbd61d0992cdeb1ba16f3b3ead5944966d3e4080e8b6;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (\n      uint32 holographChainId,\n      address bridge,\n      address factory,\n      address interfaces,\n      address operator,\n      address registry,\n      address treasury,\n      address utilityToken\n    ) = abi.decode(initPayload, (uint32, address, address, address, address, address, address, address));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_chainIdSlot, chainid())\n      sstore(_holographChainIdSlot, holographChainId)\n      sstore(_bridgeSlot, bridge)\n      sstore(_factorySlot, factory)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_registrySlot, registry)\n      sstore(_treasurySlot, treasury)\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the chain ID that the Protocol was deployed on\n   * @dev Useful for checking if/when a hard fork occurs\n   */\n  function getChainId() external view returns (uint256 chainId) {\n    assembly {\n      chainId := sload(_chainIdSlot)\n    }\n  }\n\n  /**\n   * @notice Update the chain ID\n   * @dev Useful for updating once a hard fork has been mitigated\n   * @param chainId EVM chain ID to use\n   */\n  function setChainId(uint256 chainId) external onlyAdmin {\n    assembly {\n      sstore(_chainIdSlot, chainId)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external onlyAdmin {\n    assembly {\n      sstore(_factorySlot, factory)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph chain Id\n   * @dev Holograph uses an internal chain id mapping\n   */\n  function getHolographChainId() external view returns (uint32 holographChainId) {\n    assembly {\n      holographChainId := sload(_holographChainIdSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph chain ID\n   * @dev Useful for updating once a hard fork was mitigated\n   * @param holographChainId Holograph chain ID to use\n   */\n  function setHolographChainId(uint32 holographChainId) external onlyAdmin {\n    assembly {\n      sstore(_holographChainIdSlot, holographChainId)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Treasury module\n   * @dev All of the Holograph Protocol assets are stored and managed by this module\n   */\n  function getTreasury() external view returns (address treasury) {\n    assembly {\n      treasury := sload(_treasurySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Treasury module address\n   * @param treasury address of the Holograph Treasury smart contract to use\n   */\n  function setTreasury(address treasury) external onlyAdmin {\n    assembly {\n      sstore(_treasurySlot, treasury)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/HolographBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/Holographable.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographFactoryInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\n\n/**\n * @title Holograph Bridge\n * @author https://github.com/holographxyz\n * @notice Beam any holographable contracts and assets across blockchains\n * @dev The contract abstracts all the complexities of making bridge requests and uses a universal interface to bridge any type of holographable assets\n */\ncontract HolographBridge is Admin, Initializable, HolographBridgeInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.factory')) - 1)\n   */\n  bytes32 constant _factorySlot = 0xa49f20855ba576e09d13c8041c8039fa655356ea27f6c40f1ec46a4301cd5b23;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.jobNonce')) - 1)\n   */\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Allow calls only from Holograph Operator contract\n   */\n  modifier onlyOperator() {\n    require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address factory, address holograph, address operator, address registry) = abi.decode(\n      initPayload,\n      (address, address, address, address)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_factorySlot, factory)\n      sstore(_holographSlot, holograph)\n      sstore(_operatorSlot, operator)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Receive a beam from another chain\n   * @dev This function can only be called by the Holograph Operator module\n   * @param fromChain Holograph Chain ID where the brigeOutRequest was created\n   * @param holographableContract address of the destination contract that the bridgeInRequest is targeted for\n   * @param hToken address of the hToken contract that wrapped the origin chain native gas token\n   * @param hTokenRecipient address of recipient for the hToken reward\n   * @param hTokenValue exact amount of hToken reward in wei\n   * @param doNotRevert boolean used to specify if the call should revert\n   * @param bridgeInPayload actual abi encoded bytes of the data that the holographable contract bridgeIn function will receive\n   */\n  function bridgeInRequest(\n    uint256 /* nonce*/,\n    uint32 fromChain,\n    address holographableContract,\n    address hToken,\n    address hTokenRecipient,\n    uint256 hTokenValue,\n    bool doNotRevert,\n    bytes calldata bridgeInPayload\n  ) external payable onlyOperator {\n    /**\n     * @dev check that the target contract is either Holograph Factory or a deployed holographable contract\n     */\n    require(\n      _registry().isHolographedContract(holographableContract) || address(_factory()) == holographableContract,\n      \"HOLOGRAPH: not holographed\"\n    );\n    /**\n     * @dev make a bridgeIn function call to the holographable contract\n     */\n    bytes4 selector = Holographable(holographableContract).bridgeIn(fromChain, bridgeInPayload);\n    /**\n     * @dev ensure returned selector is bridgeIn function signature, to guarantee that the function was called and succeeded\n     */\n    require(selector == Holographable.bridgeIn.selector, \"HOLOGRAPH: bridge in failed\");\n    /**\n     * @dev check if a specific reward amount was assigned to this request\n     */\n    if (hTokenValue > 0 && hTokenRecipient != address(0)) {\n      /**\n       * @dev mint the specific hToken amount for hToken recipient\n       *      this value is equivalent to amount that is deposited on origin chain's hToken contract\n       *      recipient can beam the asset to origin chain and unwrap for native gas token at any time\n       */\n      require(\n        HolographERC20Interface(hToken).holographBridgeMint(hTokenRecipient, hTokenValue) ==\n          HolographERC20Interface.holographBridgeMint.selector,\n        \"HOLOGRAPH: hToken mint failed\"\n      );\n    }\n    /**\n     * @dev allow the call to revert on demand, for example use case, look into the Holograph Operator's jobEstimator function\n     */\n    require(doNotRevert, \"HOLOGRAPH: reverted\");\n  }\n\n  /**\n   * @notice Create a beam request for a destination chain\n   * @dev This function works for deploying contracts and beaming supported holographable assets across chains\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   */\n  function bridgeOutRequest(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata bridgeOutPayload\n  ) external payable {\n    /**\n     * @dev check that the target contract is either Holograph Factory or a deployed holographable contract\n     */\n    require(\n      _registry().isHolographedContract(holographableContract) || address(_factory()) == holographableContract,\n      \"HOLOGRAPH: not holographed\"\n    );\n    /**\n     * @dev make a bridgeOut function call to the holographable contract\n     */\n    (bytes4 selector, bytes memory returnedPayload) = Holographable(holographableContract).bridgeOut(\n      toChain,\n      msg.sender,\n      bridgeOutPayload\n    );\n    /**\n     * @dev ensure returned selector is bridgeOut function signature, to guarantee that the function was called and succeeded\n     */\n    require(selector == Holographable.bridgeOut.selector, \"HOLOGRAPH: bridge out failed\");\n    /**\n     * @dev pass the request, along with all data, to Holograph Operator, to handle the cross-chain messaging logic\n     */\n    _operator().send{value: msg.value}(\n      gasLimit,\n      gasPrice,\n      toChain,\n      msg.sender,\n      _jobNonce(),\n      holographableContract,\n      returnedPayload\n    );\n  }\n\n  /**\n   * @notice Do not call this function, it will always revert\n   * @dev Used by getBridgeOutRequestPayload function\n   *      It is purposefully inverted to always revert on a successful call\n   *      Marked as external and not private to allow use inside try/catch of getBridgeOutRequestPayload function\n   *      If this function does not revert and returns a string, it is the actual revert reason\n   * @param sender address of actual sender that is planning to make a bridgeOutRequest call\n   * @param toChain holograph chain id of destination chain\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   */\n  function revertedBridgeOutRequest(\n    address sender,\n    uint32 toChain,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external returns (string memory revertReason) {\n    /**\n     * @dev make a bridgeOut function call to the holographable contract inside of a try/catch\n     */\n    try Holographable(holographableContract).bridgeOut(toChain, sender, bridgeOutPayload) returns (\n      bytes4 selector,\n      bytes memory payload\n    ) {\n      /**\n       * @dev ensure returned selector is bridgeOut function signature, to guarantee that the function was called and succeeded\n       */\n      if (selector != Holographable.bridgeOut.selector) {\n        /**\n         * @dev if selector does not match, then it means the request failed\n         */\n        return \"HOLOGRAPH: bridge out failed\";\n      }\n      assembly {\n        /**\n         * @dev the entire payload is sent back in a revert\n         */\n        revert(add(payload, 0x20), mload(payload))\n      }\n    } catch Error(string memory reason) {\n      return reason;\n    } catch {\n      return \"HOLOGRAPH: unknown error\";\n    }\n  }\n\n  /**\n   * @notice Get the payload created by the bridgeOutRequest function\n   * @dev Use this function to get the payload that will be generated by a bridgeOutRequest\n   *      Only use this with a static call\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   * @return samplePayload bytes made up of the bridgeOutRequest payload\n   */\n  function getBridgeOutRequestPayload(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata bridgeOutPayload\n  ) external returns (bytes memory samplePayload) {\n    /**\n     * @dev check that the target contract is either Holograph Factory or a deployed holographable contract\n     */\n    require(\n      _registry().isHolographedContract(holographableContract) || address(_factory()) == holographableContract,\n      \"HOLOGRAPH: not holographed\"\n    );\n    bytes memory payload;\n    /**\n     * @dev the revertedBridgeOutRequest function is wrapped into a try/catch function\n     */\n    try this.revertedBridgeOutRequest(msg.sender, toChain, holographableContract, bridgeOutPayload) returns (\n      string memory revertReason\n    ) {\n      /**\n       * @dev a non reverted result is actually a revert\n       */\n      revert(revertReason);\n    } catch (bytes memory realResponse) {\n      /**\n       * @dev a revert is actually success, so the return data is stored as payload\n       */\n      payload = realResponse;\n    }\n    uint256 jobNonce;\n    assembly {\n      jobNonce := sload(_jobNonceSlot)\n    }\n    /**\n     * @dev extract hlgFee from operator\n     */\n    uint256 fee = 0;\n    if (gasPrice < type(uint256).max && gasLimit < type(uint256).max) {\n      (uint256 hlgFee, , uint256 dstGasPrice) = _operator().getMessageFee(\n        toChain,\n        gasLimit,\n        gasPrice,\n        bridgeOutPayload\n      );\n      if (gasPrice == 0) {\n        gasPrice = dstGasPrice;\n      }\n      fee = hlgFee;\n    }\n    /**\n     * @dev the data is abi encoded into actual bridgeOutRequest payload bytes\n     */\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographBridgeInterface.bridgeInRequest.selector,\n      /**\n       * @dev the latest job nonce is incremented by one\n       */\n      jobNonce + 1,\n      _holograph().getHolographChainId(),\n      holographableContract,\n      _registry().getHToken(_holograph().getHolographChainId()),\n      address(0),\n      fee,\n      true,\n      payload\n    );\n    /**\n     * @dev this abi encodes the data just like in Holograph Operator\n     */\n    samplePayload = abi.encodePacked(encodedData, gasLimit, gasPrice);\n  }\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @dev @param toChain holograph chain id of destination chain for payload\n   * @dev @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @dev @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @dev @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(uint32, uint256, uint256, bytes calldata) external view returns (uint256, uint256, uint256) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := staticcall(gas(), sload(_operatorSlot), 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external onlyAdmin {\n    assembly {\n      sstore(_factorySlot, factory)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the latest job nonce\n   * @dev You can use the job nonce as a way to calculate total amount of bridge requests that have been made\n   */\n  function getJobNonce() external view returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := sload(_jobNonceSlot)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Factory Interface\n   */\n  function _factory() private view returns (HolographFactoryInterface factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interface\n   */\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Internal nonce, that increments on each call, used for randomness\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Operator Interface\n   */\n  function _operator() private view returns (HolographOperatorInterface operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Registry Interface\n   */\n  function _registry() private view returns (HolographRegistryInterface registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/HolographFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enforcer/Holographer.sol\";\n\nimport \"./interface/Holographable.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographFactoryInterface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\n\nimport \"./struct/BridgeSettings.sol\";\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\nimport \"./library/Strings.sol\";\n\n/**\n * @title Holograph Factory\n * @author https://github.com/holographxyz\n * @notice Deploy holographable contracts\n * @dev The contract provides methods that allow for the creation of Holograph Protocol compliant smart contracts, that are capable of minting holographable assets\n */\ncontract HolographFactory is Admin, Initializable, Holographable, HolographFactoryInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address holograph, address registry) = abi.decode(initPayload, (address, address));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_holographSlot, holograph)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Deploy holographable contract via bridge request\n   * @dev This function directly forwards the calldata to the deployHolographableContract function\n   *      It is used to allow for Holograph Bridge to make cross-chain deployments\n   */\n  function bridgeIn(uint32 /* fromChain*/, bytes calldata payload) external returns (bytes4) {\n    (DeploymentConfig memory config, Verification memory signature, address signer) = abi.decode(\n      payload,\n      (DeploymentConfig, Verification, address)\n    );\n    HolographFactoryInterface(address(this)).deployHolographableContract(config, signature, signer);\n    return Holographable.bridgeIn.selector;\n  }\n\n  /**\n   * @notice Deploy holographable contract via bridge request\n   * @dev This function directly returns the calldata\n   *      It is used to allow for Holograph Bridge to make cross-chain deployments\n   */\n  function bridgeOut(\n    uint32 /* toChain*/,\n    address /* sender*/,\n    bytes calldata payload\n  ) external pure returns (bytes4 selector, bytes memory data) {\n    return (Holographable.bridgeOut.selector, payload);\n  }\n\n  function deployHolographableContractMultiChain(\n    DeploymentConfig memory config,\n    Verification memory signature,\n    address signer,\n    bool deployOnCurrentChain,\n    BridgeSettings[] memory bridgeSettings\n  ) external payable {\n    if (deployOnCurrentChain) {\n      deployHolographableContract(config, signature, signer);\n    }\n    bytes memory payload = abi.encode(config, signature, signer);\n    HolographInterface holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n    HolographBridgeInterface bridge = HolographBridgeInterface(holograph.getBridge());\n    uint256 l = bridgeSettings.length;\n    for (uint256 i = 0; i < l; i++) {\n      bridge.bridgeOutRequest{value: bridgeSettings[i].value}(\n        bridgeSettings[i].toChain,\n        address(this),\n        bridgeSettings[i].gasLimit,\n        bridgeSettings[i].gasPrice,\n        payload\n      );\n    }\n  }\n\n  /**\n   * @notice Deploy a holographable smart contract\n   * @dev Using this function allows to deploy smart contracts that have the same address across all EVM chains\n   * @param config contract deployement configurations\n   * @param signature that was created by the wallet that created the original payload\n   * @param signer address of wallet that created the payload\n   */\n  function deployHolographableContract(\n    DeploymentConfig memory config,\n    Verification memory signature,\n    address signer\n  ) public {\n    address registry;\n    address holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n      registry := sload(_registrySlot)\n    }\n    /**\n     * @dev the configuration is encoded and hashed along with signer address\n     */\n    bytes32 hash = keccak256(\n      abi.encodePacked(\n        config.contractType,\n        config.chainType,\n        config.salt,\n        keccak256(config.byteCode),\n        keccak256(config.initCode),\n        signer\n      )\n    );\n    /**\n     * @dev the hash is validated against signature\n     *      this is to guarantee that the original creator's configuration has not been altered\n     */\n    require(_verifySigner(signature.r, signature.s, signature.v, hash, signer), \"HOLOGRAPH: invalid signature\");\n    /**\n     * @dev check that this contract has not already been deployed on this chain\n     */\n    bytes memory holographerBytecode = type(Holographer).creationCode;\n    address holographerAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), hash, keccak256(holographerBytecode)))))\n    );\n    require(!_isContract(holographerAddress), \"HOLOGRAPH: already deployed\");\n    /**\n     * @dev convert hash into uint256 which will be used as the salt for create2\n     */\n    uint256 saltInt = uint256(hash);\n    address sourceContractAddress;\n    bytes memory sourceByteCode = config.byteCode;\n    assembly {\n      /**\n       * @dev deploy the user created smart contract first\n       */\n      sourceContractAddress := create2(0, add(sourceByteCode, 0x20), mload(sourceByteCode), saltInt)\n    }\n    assembly {\n      /**\n       * @dev deploy the Holographer contract\n       */\n      holographerAddress := create2(0, add(holographerBytecode, 0x20), mload(holographerBytecode), saltInt)\n    }\n    /**\n     * @dev initialize the Holographer contract\n     */\n    require(\n      InitializableInterface(holographerAddress).init(\n        abi.encode(abi.encode(config.chainType, holograph, config.contractType, sourceContractAddress), config.initCode)\n      ) == InitializableInterface.init.selector,\n      \"initialization failed\"\n    );\n    /**\n     * @dev update the Holograph Registry with deployed contract address\n     */\n    HolographRegistryInterface(registry).setHolographedHashAddress(hash, holographerAddress);\n    /**\n     * @dev emit an event that on-chain indexers can easily read\n     */\n    emit BridgeableContractDeployed(holographerAddress, hash);\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Internal function used for verifying a signature\n   */\n  function _verifySigner(bytes32 r, bytes32 s, uint8 v, bytes32 hash, address signer) private pure returns (bool) {\n    if (v < 27) {\n      v += 27;\n    }\n    if (v != 27 && v != 28) {\n      return false;\n    }\n    // prevent signature malleability by checking if s-value is in the upper range\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      // if s-value is in upper range, calculate a new s-value\n      s = bytes32(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - uint256(s));\n      // flip the v-value\n      if (v == 27) {\n        v = 28;\n      } else {\n        v = 27;\n      }\n      // check if s-value is still in upper range\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n        return false;\n      }\n    }\n    /**\n     * @dev signature is checked against EIP-191 first, then directly, to support legacy wallets\n     */\n    return (signer != address(0) &&\n      (ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == signer ||\n        (\n          ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n66\", Strings.toHexString(uint256(hash), 32))),\n            v,\n            r,\n            s\n          )\n        ) ==\n        signer ||\n        ecrecover(hash, v, r, s) == signer));\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/HolographGenesis.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./interface/InitializableInterface.sol\";\n\n/**\n * @title HOLOGRAPH GENESIS\n * @dev In the beginning there was a smart contract...\n */\ncontract HolographGenesis {\n  uint32 private immutable _version;\n\n  // Nonce to prevent replay attacks on deployer approvals\n  uint256 private _approveDeployerNonce;\n\n  // Immutable addresses of the initial deployers\n  address private immutable deployer1 = 0xBB566182f35B9E5Ae04dB02a5450CC156d2f89c1;\n  address private immutable deployer2 = 0x22ED36947DDd1ae317F7816c410D3c0c58Bb9b90;\n  address private immutable deployer3 = 0xFfCA0d6986099FbDb3b6AD9b6aa5DF5ed1d44f0C;\n  address private immutable deployer4 = 0xDF9013a9Af763b181EF8acFC0e3229494004e001;\n  address private immutable deployer5 = 0x00Ac9Fd50C63f176B49F05FfedA324bD68C7cD69;\n\n  // Mapping of addresses that are approved deployers\n  mapping(address => bool) private _approvedDeployers;\n\n  // Events\n  event Message(string message);\n  event ContractDeployed(address deployedContract);\n\n  // Modifier to restrict function calls to approved deployers\n  modifier onlyDeployer() {\n    require(_approvedDeployers[msg.sender], \"HOLOGRAPH: deployer not approved\");\n    _;\n  }\n\n  /**\n   * @dev Sets the initial deployers as approved upon contract creation.\n   */\n  constructor() {\n    _version = 2;\n\n    // Set the immutable deployers as approved\n    _approvedDeployers[deployer1] = true;\n    _approvedDeployers[deployer2] = true;\n    _approvedDeployers[deployer3] = true;\n    _approvedDeployers[deployer4] = true;\n    _approvedDeployers[deployer5] = true;\n\n    emit Message(\"The future is Holographic\");\n  }\n\n  /**\n   * @dev Deploy a contract using the EIP-1014 (create2) opcode for deterministic addresses.\n   * @param chainId The chain on which to deploy\n   * @param saltHash A unique salt for contract creation\n   * @param secret A secret part of the salt\n   * @param sourceCode The bytecode of the contract to deploy\n   * @param initCode The initialization code for the contract\n   */\n  function deploy(\n    uint256 chainId,\n    bytes12 saltHash,\n    bytes20 secret,\n    bytes memory sourceCode,\n    bytes memory initCode\n  ) external onlyDeployer {\n    require(chainId == block.chainid, \"HOLOGRAPH: incorrect chain id\");\n    bytes32 salt = bytes32(abi.encodePacked(secret, saltHash));\n    address contractAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(sourceCode)))))\n    );\n    require(!_isContract(contractAddress), \"HOLOGRAPH: already deployed\");\n    assembly {\n      contractAddress := create2(0, add(sourceCode, 0x20), mload(sourceCode), salt)\n    }\n    require(_isContract(contractAddress), \"HOLOGRAPH: deployment failed\");\n    require(\n      InitializableInterface(contractAddress).init(initCode) == InitializableInterface.init.selector,\n      \"HOLOGRAPH: initialization failed\"\n    );\n\n    emit ContractDeployed(contractAddress);\n  }\n\n  /**\n   * @dev Check if an address is an approved deployer.\n   * @param deployer Address to check\n   * @return bool representing approval status\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool) {\n    return _approvedDeployers[deployer];\n  }\n\n  /**\n   * @dev Internal function to determine if an address is a deployed contract.\n   * @param contractAddress The address to check\n   * @return bool representing if the address is a contract\n   */\n  function _isContract(address contractAddress) internal view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Approve or disapprove a deployer using multi-signature verification.\n   * @param nonce A unique nonce\n   * @param newDeployer The address of the deployer to approve or disapprove\n   * @param approve Boolean representing the approval status\n   * @param sig1 The first signature for multisig\n   * @param sig2 The second signature for multisig\n   */\n  function approveDeployer(\n    uint256 nonce,\n    address newDeployer,\n    bool approve,\n    bytes memory sig1,\n    bytes memory sig2\n  ) external onlyDeployer {\n    require(nonce > _approveDeployerNonce, \"HOLOGRAPH: invalid nonce\");\n    _approveDeployerNonce = nonce; // Update the nonce\n\n    // Recover signers\n    address signer1 = recoverSigner(nonce, newDeployer, approve, sig1);\n    address signer2 = recoverSigner(nonce, newDeployer, approve, sig2);\n\n    // Check that both signers are approved deployers\n    require(_approvedDeployers[signer1], \"HOLOGRAPH: signer 1 not approved\");\n    require(_approvedDeployers[signer2], \"HOLOGRAPH: signer 2 not approved\");\n\n    // Ensure signatures come from two different deployers\n    require(signer1 != signer2, \"HOLOGRAPH: signatures must be from different deployers\");\n\n    // All checks passed, update the deployer approval status\n    _approvedDeployers[newDeployer] = approve;\n\n    emit Message(approve ? \"HOLOGRAPH: deployer approved\" : \"HOLOGRAPH: deployer disapproved\");\n  }\n\n  /**\n   * @dev Generates a hash of the message containing nonce, deployer address, and approval status.\n   * @param nonce Nonce used in the message\n   * @param newDeployer Address of the deployer in the message\n   * @param approve Approval status in the message\n   * @return bytes32 Ethereum signed message hash\n   */\n  function getMessageHash(uint256 nonce, address newDeployer, bool approve) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(nonce, newDeployer, approve));\n  }\n\n  /**\n   * @dev Recreates the Ethereum signed message hash from the plain message hash.\n   * @param _messageHash The hash of the original message\n   * @return bytes32 Ethereum signed message hash\n   */\n  function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n  }\n\n  /**\n   * @dev Recovers the signer from the signature.\n   * @param nonce Nonce used in the message\n   * @param newDeployer Address of the deployer in the message\n   * @param approve Approval status in the message\n   * @param signature The signature to recover\n   * @return address of the signer\n   */\n  function recoverSigner(\n    uint256 nonce,\n    address newDeployer,\n    bool approve,\n    bytes memory signature\n  ) public pure returns (address) {\n    bytes32 messageHash = getMessageHash(nonce, newDeployer, approve);\n    bytes32 prefixedHash = getEthSignedMessageHash(messageHash);\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n\n    return ecrecover(prefixedHash, v, r, s);\n  }\n\n  /**\n   * @dev Splits a signature into its r, s, and v components.\n   * @param sig The signature to split.\n   * @return r The r component of the signature.\n   * @return s The s component of the signature.\n   * @return v The recovery id component of the signature.\n   */\n  function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n    require(sig.length == 65, \"Invalid signature length\");\n\n    assembly {\n      // first 32 bytes, after the length prefix\n      r := mload(add(sig, 32))\n      // second 32 bytes\n      s := mload(add(sig, 64))\n      // final byte (first byte of the next 32 bytes)\n      v := byte(0, mload(add(sig, 96)))\n    }\n  }\n\n  /**\n   * @dev Returns the current nonce for deployer approvals.\n   * @return uint256 representing the current nonce\n   */\n  function getApproveDeployerNonce() external view onlyDeployer returns (uint256) {\n    return _approveDeployerNonce;\n  }\n\n  /**\n   * @dev Returns the version number of the Genesis contract\n   * @return uint32 representing the version number\n   */\n  function getVersion() external view returns (uint32) {\n    return _version;\n  }\n}\n"
    },
    "src/HolographGenesisLocal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./interface/InitializableInterface.sol\";\n\n/**\n * @title HOLOGRAPH GENESIS\n * @dev In the beginning there was a smart contract...\n */\ncontract HolographGenesisLocal {\n  uint32 private immutable _version;\n\n  // Immutable addresses of the initial deployers\n  address private immutable deployer1 = 0xdf5295149F367b1FBFD595bdA578BAd22e59f504;\n\n  // Mapping of addresses that are approved deployers\n  mapping(address => bool) private _approvedDeployers;\n\n  // Events\n  event Message(string message);\n  event ContractDeployed(address deployedContract);\n\n  // Modifier to restrict function calls to approved deployers\n  modifier onlyDeployer() {\n    require(_approvedDeployers[msg.sender], \"HOLOGRAPH: deployer not approved\");\n    _;\n  }\n\n  /**\n   * @dev Sets the initial deployers as approved upon contract creation.\n   */\n  constructor() {\n    _version = 2;\n\n    // Set the immutable deployers as approved\n    _approvedDeployers[deployer1] = true;\n\n    emit Message(\"The future is Holographic\");\n  }\n\n  /**\n   * @dev Deploy a contract using the EIP-1014 (create2) opcode for deterministic addresses.\n   * @param chainId The chain on which to deploy\n   * @param saltHash A unique salt for contract creation\n   * @param secret A secret part of the salt\n   * @param sourceCode The bytecode of the contract to deploy\n   * @param initCode The initialization code for the contract\n   */\n  function deploy(\n    uint256 chainId,\n    bytes12 saltHash,\n    bytes20 secret,\n    bytes memory sourceCode,\n    bytes memory initCode\n  ) external onlyDeployer {\n    require(chainId == block.chainid, \"HOLOGRAPH: incorrect chain id\");\n    bytes32 salt = bytes32(abi.encodePacked(secret, saltHash));\n    address contractAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(sourceCode)))))\n    );\n    require(!_isContract(contractAddress), \"HOLOGRAPH: already deployed\");\n    assembly {\n      contractAddress := create2(0, add(sourceCode, 0x20), mload(sourceCode), salt)\n    }\n    require(_isContract(contractAddress), \"HOLOGRAPH: deployment failed\");\n    require(\n      InitializableInterface(contractAddress).init(initCode) == InitializableInterface.init.selector,\n      \"HOLOGRAPH: initialization failed\"\n    );\n\n    emit ContractDeployed(contractAddress);\n  }\n\n  /**\n   * @dev Approve or revoke an address as a deployer.\n   * @param newDeployer Address to approve or revoke\n   * @param approve Boolean to approve or revoke\n   */\n  function approveDeployer(address newDeployer, bool approve) external onlyDeployer {\n    _approvedDeployers[newDeployer] = approve;\n  }\n\n  /**\n   * @dev Check if an address is an approved deployer.\n   * @param deployer Address to check\n   * @return bool representing approval status\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool) {\n    return _approvedDeployers[deployer];\n  }\n\n  /**\n   * @dev Internal function to determine if an address is a deployed contract.\n   * @param contractAddress The address to check\n   * @return bool representing if the address is a contract\n   */\n  function _isContract(address contractAddress) internal view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Returns the version number of the Genesis contract\n   * @return uint32 representing the version number\n   */\n  function getVersion() external view returns (uint32) {\n    return _version;\n  }\n}\n"
    },
    "src/HolographInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enum/ChainIdType.sol\";\nimport \"./enum/InterfaceType.sol\";\nimport \"./enum/TokenUriType.sol\";\n\nimport \"./interface/InitializableInterface.sol\";\n\nimport \"./library/Base64.sol\";\nimport \"./library/Strings.sol\";\n\n/**\n * @title Holograph Interfaces\n * @author https://github.com/holographxyz\n * @notice Get universal Holograph Protocol variables\n * @dev The contract stores a reference of all supported: chains, interfaces, functions, etc.\n */\ncontract HolographInterfaces is Admin, Initializable {\n  /**\n   * @dev Internal mapping of all InterfaceType interfaces\n   */\n  mapping(InterfaceType => mapping(bytes4 => bool)) private _supportedInterfaces;\n\n  /**\n   * @dev Internal mapping of all ChainIdType conversions\n   */\n  mapping(ChainIdType => mapping(uint256 => mapping(ChainIdType => uint256))) private _chainIdMap;\n\n  /**\n   * @dev Internal mapping of all TokenUriType prepends\n   */\n  mapping(TokenUriType => string) private _prependURI;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    address contractAdmin = abi.decode(initPayload, (address));\n    assembly {\n      sstore(_adminSlot, contractAdmin)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Get a base64 encoded contract URI JSON string\n   * @dev Used to dynamically generate contract JSON payload\n   * @param name the name of the smart contract\n   * @param imageURL string pointing to the primary contract image, can be: https, ipfs, or ar (arweave)\n   * @param externalLink url to website/page related to smart contract\n   * @param bps basis points used for specifying royalties percentage\n   * @param contractAddress address of the smart contract\n   * @return a base64 encoded json string representing the smart contract\n   */\n  function contractURI(\n    string calldata name,\n    string calldata imageURL,\n    string calldata externalLink,\n    uint16 bps,\n    address contractAddress\n  ) external pure returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\n          \"data:application/json;base64,\",\n          Base64.encode(\n            abi.encodePacked(\n              '{\"name\":\"',\n              name,\n              '\",\"description\":\"',\n              name,\n              '\",\"image\":\"',\n              imageURL,\n              '\",\"external_link\":\"',\n              externalLink,\n              '\",\"seller_fee_basis_points\":',\n              Strings.uint2str(bps),\n              ',\"fee_recipient\":\"0x',\n              Strings.toAsciiString(contractAddress),\n              '\"}'\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @notice Get the prepend to use for tokenURI\n   * @dev Provides the prepend to use with TokenUriType URI\n   */\n  function getUriPrepend(TokenUriType uriType) external view returns (string memory prepend) {\n    prepend = _prependURI[uriType];\n  }\n\n  /**\n   * @notice Update the tokenURI prepend\n   * @param uriType specify which TokenUriType to set for\n   * @param prepend the string to use for the prepend\n   */\n  function updateUriPrepend(TokenUriType uriType, string calldata prepend) external onlyAdmin {\n    _prependURI[uriType] = prepend;\n  }\n\n  /**\n   * @notice Update the tokenURI prepends\n   * @param uriTypes specify array of TokenUriTypes to set for\n   * @param prepends array string to use for the prepends\n   */\n  function updateUriPrepends(TokenUriType[] calldata uriTypes, string[] calldata prepends) external onlyAdmin {\n    for (uint256 i = 0; i < uriTypes.length; i++) {\n      _prependURI[uriTypes[i]] = prepends[i];\n    }\n  }\n\n  function getChainId(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType\n  ) external view returns (uint256 toChainId) {\n    return _chainIdMap[fromChainType][fromChainId][toChainType];\n  }\n\n  function updateChainIdMap(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType,\n    uint256 toChainId\n  ) external onlyAdmin {\n    _chainIdMap[fromChainType][fromChainId][toChainType] = toChainId;\n  }\n\n  function updateChainIdMaps(\n    ChainIdType[] calldata fromChainType,\n    uint256[] calldata fromChainId,\n    ChainIdType[] calldata toChainType,\n    uint256[] calldata toChainId\n  ) external onlyAdmin {\n    uint256 length = fromChainType.length;\n    for (uint256 i = 0; i < length; i++) {\n      _chainIdMap[fromChainType[i]][fromChainId[i]][toChainType[i]] = toChainId[i];\n    }\n  }\n\n  function supportsInterface(InterfaceType interfaceType, bytes4 interfaceId) external view returns (bool) {\n    return _supportedInterfaces[interfaceType][interfaceId];\n  }\n\n  function updateInterface(InterfaceType interfaceType, bytes4 interfaceId, bool supported) external onlyAdmin {\n    _supportedInterfaces[interfaceType][interfaceId] = supported;\n  }\n\n  function updateInterfaces(\n    InterfaceType interfaceType,\n    bytes4[] calldata interfaceIds,\n    bool supported\n  ) external onlyAdmin {\n    for (uint256 i = 0; i < interfaceIds.length; i++) {\n      _supportedInterfaces[interfaceType][interfaceIds[i]] = supported;\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/HolographOperator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/CrossChainMessageInterface.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\nimport \"./interface/HolographInterfacesInterface.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./struct/OperatorJob.sol\";\n\n/**\n * @title Holograph Operator\n * @author https://github.com/holographxyz\n * @notice Participate in the Holograph Protocol by becoming an Operator\n * @dev This contract allows operators to bond utility tokens and help execute operator jobs\n */\ncontract HolographOperator is Admin, Initializable, HolographOperatorInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.jobNonce')) - 1)\n   */\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.messagingModule')) - 1)\n   */\n  bytes32 constant _messagingModuleSlot = 0x54176250282e65985d205704ffce44a59efe61f7afd99e29fda50f55b48c061a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.minGasPrice')) - 1)\n   */\n  bytes32 constant _minGasPriceSlot = 0x264d744422f7427cd080572c35c848b6cd3a36da6b47519af89ef13098b12fc0;\n\n  /**\n   * @dev Internal number (in seconds), used for defining a window for operator to execute the job\n   */\n  uint256 private _blockTime;\n\n  /**\n   * @dev Minimum amount of tokens needed for bonding\n   */\n  uint256 private _baseBondAmount;\n\n  /**\n   * @dev The multiplier used for calculating bonding amount for pods\n   */\n  uint256 private _podMultiplier;\n\n  /**\n   * @dev The threshold used for limiting number of operators in a pod\n   */\n  uint256 private _operatorThreshold;\n\n  /**\n   * @dev The threshold step used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdStep;\n\n  /**\n   * @dev The threshold divisor used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdDivisor;\n\n  /**\n   * @dev Internal counter of all cross-chain messages received\n   */\n  uint256 private _inboundMessageCounter;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => uint256) private _operatorJobs;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => bool) private _failedJobs;\n\n  /**\n   * @dev Internal mapping of operator addresses, used for temp storage when defining an operator job\n   */\n  mapping(uint256 => address) private _operatorTempStorage;\n\n  /**\n   * @dev Internal index used for storing/referencing operator temp storage\n   */\n  uint32 private _operatorTempStorageCounter;\n\n  /**\n   * @dev Multi-dimensional array of available operators\n   */\n  address[][] private _operatorPods;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _bondedOperators;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _operatorPodIndex;\n\n  /**\n   * @dev Internal mapping of bonded operator amounts\n   */\n  mapping(address => uint256) private _bondedAmounts;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (\n      address bridge,\n      address holograph,\n      address interfaces,\n      address registry,\n      address utilityToken,\n      uint256 minGasPrice\n    ) = abi.decode(initPayload, (address, address, address, address, address, uint256));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_registrySlot, registry)\n      sstore(_utilityTokenSlot, utilityToken)\n      sstore(_minGasPriceSlot, minGasPrice)\n    }\n    _blockTime = 60; // 60 seconds allowed for execution\n    unchecked {\n      _baseBondAmount = 100 * (10 ** 18); // one single token unit * 100\n    }\n    // how much to increase bond amount per pod\n    _podMultiplier = 2; // 1, 4, 16, 64\n    // starting pod max amount\n    _operatorThreshold = 1000;\n    // how often to increase price per each operator\n    _operatorThresholdStep = 10;\n    // we want to multiply by decimals, but instead will have to divide\n    _operatorThresholdDivisor = 100; // == * 0.01\n    // set first operator for each pod as zero address\n    _operatorPods = [[address(0)]];\n    // mark zero address as bonded operator, to prevent abuse\n    _bondedOperators[address(0)] = 1;\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Recover failed job\n   * @dev If a job fails, it can be manually recovered\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function recoverJob(bytes calldata bridgeInRequestPayload) external payable {\n    bytes32 hash = keccak256(bridgeInRequestPayload);\n    require(_failedJobs[hash], \"HOLOGRAPH: invalid recovery job\");\n    (bool success, ) = _bridge().call{value: msg.value}(bridgeInRequestPayload);\n    require(success, \"HOLOGRAPH: recovery failed\");\n    delete (_failedJobs[hash]);\n  }\n\n  /**\n   * @notice Execute an available operator job\n   * @dev When making this call, if operating criteria is not met, the call will revert\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable {\n    /**\n     * @dev derive the payload hash for use in mappings\n     */\n    bytes32 hash = keccak256(bridgeInRequestPayload);\n    /**\n     * @dev check that job exists\n     */\n    require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n    uint256 gasLimit = 0;\n    uint256 gasPrice = 0;\n    assembly {\n      /**\n       * @dev extract gasLimit\n       */\n      gasLimit := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x40))\n      /**\n       * @dev extract gasPrice\n       */\n      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))\n    }\n    /**\n     * @dev unpack bitwise packed operator job details\n     */\n    OperatorJob memory job = getJobDetails(hash);\n    /**\n     * @dev to prevent replay attacks, remove job from mapping\n     */\n    delete _operatorJobs[hash];\n    /**\n     * @dev operators of last resort are allowed, but they will not receive HLG rewards of any sort\n     */\n    bool isBonded = _bondedAmounts[msg.sender] != 0;\n    /**\n     * @dev check that a specific operator was selected for the job\n     */\n    if (job.operator != address(0)) {\n      /**\n       * @dev switch pod to index based value\n       */\n      uint256 pod = job.pod - 1;\n      /**\n       * @dev check if sender is not the selected primary operator\n       */\n      if (job.operator != msg.sender) {\n        /**\n         * @dev sender is not selected operator, need to check if allowed to do job\n         */\n        uint256 elapsedTime = block.timestamp - uint256(job.startTimestamp);\n        uint256 timeDifference = elapsedTime / job.blockTimes;\n        /**\n         * @dev validate that initial selected operator time slot is still active\n         */\n        require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n        /**\n         * @dev check that the selected missed the time slot due to a gas spike\n         */\n        require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n        /**\n         * @dev check if time is within fallback operator slots\n         */\n        if (timeDifference < 6) {\n          uint256 podIndex = uint256(job.fallbackOperators[timeDifference - 1]);\n          /**\n           * @dev do a quick sanity check to make sure operator did not leave from index or is a zero address\n           */\n          if (podIndex > 0 && podIndex < _operatorPods[pod].length) {\n            address fallbackOperator = _operatorPods[pod][podIndex];\n            /**\n             * @dev ensure that sender is currently valid backup operator\n             */\n            require(fallbackOperator == msg.sender, \"HOLOGRAPH: invalid fallback\");\n          } else {\n            require(_bondedOperators[msg.sender] == job.pod, \"HOLOGRAPH: pod only fallback\");\n          }\n        }\n        /**\n         * @dev time to reward the current operator\n         */\n        uint256 amount = _getBaseBondAmount(pod);\n        /**\n         * @dev select operator that failed to do the job, is slashed the pod base fee\n         */\n        _bondedAmounts[job.operator] -= amount;\n        /**\n         * @dev only allow HLG rewards to go to bonded operators\n         *      if operator is bonded, the slashed amount is sent to current operator\n         *      otherwise it's sent to HolographTreasury, can be burned or distributed from there\n         */\n        _utilityToken().transfer((isBonded ? msg.sender : address(_holograph().getTreasury())), amount);\n        /**\n         * @dev check if slashed operator has enough tokens bonded to stay\n         */\n        if (_bondedAmounts[job.operator] >= amount) {\n          /**\n           * @dev enough bond amount leftover, put operator back in\n           */\n          _operatorPods[pod].push(job.operator);\n          _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n          _bondedOperators[job.operator] = job.pod;\n        } else {\n          /**\n           * @dev slashed operator does not have enough tokens bonded, return remaining tokens only\n           */\n          uint256 leftovers = _bondedAmounts[job.operator];\n          if (leftovers > 0) {\n            _bondedAmounts[job.operator] = 0;\n            _utilityToken().transfer(job.operator, leftovers);\n          }\n        }\n      } else {\n        /**\n         * @dev the selected operator is executing the job\n         */\n        _operatorPods[pod].push(msg.sender);\n        _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n        _bondedOperators[msg.sender] = job.pod;\n      }\n    }\n    /**\n     * @dev every executed job (even if failed) increments total message counter by one\n     */\n    ++_inboundMessageCounter;\n    /**\n     * @dev reward operator (with HLG) for executing the job\n     *      this is out of scope and is purposefully omitted from code\n     *      currently no rewards are issued\n     */\n    //_utilityToken().transfer((isBonded ? msg.sender : address(_utilityToken())), (10**18));\n    /**\n     * @dev always emit an event at end of job, this helps other operators keep track of job status\n     */\n    emit FinishedOperatorJob(hash, msg.sender);\n    /**\n     * @dev ensure that there is enough has left for the job\n     */\n    require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");\n    /**\n     * @dev execute the job\n     */\n    try\n      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n        msg.sender,\n        bridgeInRequestPayload\n      )\n    {\n      /// @dev do nothing\n    } catch {\n      /// @dev return any payed funds in case of revert\n      payable(msg.sender).transfer(msg.value);\n      _failedJobs[hash] = true;\n      emit FailedOperatorJob(hash);\n    }\n  }\n\n  /*\n   * @dev Purposefully made to be external so that Operator can call it during executeJob function\n   *      Check the executeJob function to understand it's implementation\n   */\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {\n    require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");\n    assembly {\n      /**\n       * @dev remove gas price from end\n       */\n      calldatacopy(0, payload.offset, sub(payload.length, 0x20))\n      /**\n       * @dev hToken recipient is injected right before making the call\n       */\n      mstore(0x84, msgSender)\n      /**\n       * @dev make non-reverting call\n       */\n      let result := call(\n        /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n        mload(sub(payload.length, 0x40)),\n        /// @dev destination is bridge contract\n        sload(_bridgeSlot),\n        /// @dev any value is passed along\n        callvalue(),\n        /// @dev data is retrieved from 0 index memory position\n        0,\n        /// @dev everything except for last 32 bytes (gas limit) is sent\n        sub(payload.length, 0x40),\n        0,\n        0\n      )\n      if eq(result, 0) {\n        revert(0, 0)\n      }\n      return(0, 0)\n    }\n  }\n\n  /**\n   * @notice Receive a cross-chain message\n   * @dev This function is restricted for use by Holograph Messaging Module only\n   */\n  function crossChainMessage(bytes calldata bridgeInRequestPayload) external payable {\n    require(\n      msg.sender == address(_messagingModule()) || msg.sender == 0x777C19834a1A2FF6353a1E9cfb7C799ed7943a11,\n      \"HOLOGRAPH: messaging only call\"\n    );\n    uint256 gasPrice = 0;\n    assembly {\n      /**\n       * @dev extract gasPrice\n       */\n      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))\n    }\n    bool underpriced = gasPrice < _minGasPrice();\n    unchecked {\n      bytes32 jobHash = keccak256(bridgeInRequestPayload);\n      /**\n       * @dev load and increment operator temp storage in one call\n       */\n      ++_operatorTempStorageCounter;\n      /**\n       * @dev use job hash, job nonce, block number, and block timestamp for generating a random number\n       */\n      uint256 random = uint256(keccak256(abi.encodePacked(jobHash, _jobNonce(), block.number, block.timestamp)));\n      // use the left 128 bits of random number\n      uint256 random1 = uint256(random >> 128);\n      // use the right 128 bits of random number\n      uint256 random2 = uint256(uint128(random));\n      // combine the two new random numbers for use in additional pod operator selection logic\n      random = uint256(keccak256(abi.encodePacked(random1 + random2)));\n      /**\n       * @dev divide by total number of pods, use modulus/remainder\n       */\n      uint256 pod = random1 % _operatorPods.length;\n      /**\n       * @dev identify the total number of available operators in pod\n       */\n      uint256 podSize = _operatorPods[pod].length;\n      /**\n       * @dev select a primary operator\n       */\n      uint256 operatorIndex = underpriced ? 0 : random2 % podSize;\n      /**\n       * @dev If operator index is 0, then it's open season! Anyone can execute this job. First come first serve\n       *      pop operator to ensure that they cannot be selected for any other job until this one completes\n       *      decrease pod size to accomodate popped operator\n       */\n      _operatorTempStorage[_operatorTempStorageCounter] = _operatorPods[pod][operatorIndex];\n      _popOperator(pod, operatorIndex);\n      if (podSize > 1) {\n        podSize--;\n      }\n      _operatorJobs[jobHash] = uint256(\n        ((pod + 1) << 248) |\n          (uint256(_operatorTempStorageCounter) << 216) |\n          (block.number << 176) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 1)) << 160) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 2)) << 144) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 3)) << 128) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 4)) << 112) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 5)) << 96) |\n          (block.timestamp << 16) |\n          0\n      ); // 80 next available bit position && so far 176 bits used with only 128 left\n      /**\n       * @dev emit event to signal to operators that a job has become available\n       */\n      emit AvailableOperatorJob(jobHash, bridgeInRequestPayload);\n    }\n  }\n\n  /**\n   * @notice Calculate the amount of gas needed to execute a bridgeInRequest\n   * @dev Use this function to estimate the amount of gas that will be used by the bridgeInRequest function\n   *      Set a specific gas limit when making this call, subtract return value, to get total gas used\n   *      Only use this with a static call\n   * @param bridgeInRequestPayload abi encoded bytes making up the bridgeInRequest payload\n   * @return the gas amount remaining after the static call is returned\n   */\n  function jobEstimator(bytes calldata bridgeInRequestPayload) external payable returns (uint256) {\n    assembly {\n      calldatacopy(0, bridgeInRequestPayload.offset, sub(bridgeInRequestPayload.length, 0x40))\n      /**\n       * @dev bridgeInRequest doNotRevert is purposefully set to false so a rever would happen\n       */\n      mstore8(0xE3, 0x00)\n      let result := call(gas(), sload(_bridgeSlot), callvalue(), 0, sub(bridgeInRequestPayload.length, 0x40), 0, 0)\n      /**\n       * @dev if for some reason the call does not revert, it is force reverted\n       */\n      if eq(result, 1) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      /**\n       * @dev remaining gas is set as the return value\n       */\n      mstore(0x00, gas())\n      return(0x00, 0x20)\n    }\n  }\n\n  /**\n   * @notice Send cross chain bridge request message\n   * @dev This function is restricted to only be callable by Holograph Bridge\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param nonce incremented number used to ensure job hashes are unique\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload bytes made up of the bridgeOutRequest payload\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 nonce,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external payable {\n    require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");\n    CrossChainMessageInterface messagingModule = _messagingModule();\n    uint256 hlgFee = messagingModule.getHlgFee(toChain, gasLimit, gasPrice, bridgeOutPayload);\n    address hToken = _registry().getHToken(_holograph().getHolographChainId());\n    require(hlgFee < msg.value, \"HOLOGRAPH: not enough value\");\n    payable(hToken).transfer(hlgFee);\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographBridgeInterface.bridgeInRequest.selector,\n      /**\n       * @dev job nonce is an incremented value that is assigned to each bridge request to guarantee unique hashes\n       */\n      nonce,\n      /**\n       * @dev including the current holograph chain id (origin chain)\n       */\n      _holograph().getHolographChainId(),\n      /**\n       * @dev holographable contract have the same address across all chains, so our destination address will be the same\n       */\n      holographableContract,\n      /**\n       * @dev get the current chain's hToken for native gas token\n       */\n      hToken,\n      /**\n       * @dev recipient will be defined when operator picks up the job\n       */\n      address(0),\n      /**\n       * @dev value is set to zero for now\n       */\n      hlgFee,\n      /**\n       * @dev specify that function call should not revert\n       */\n      true,\n      /**\n       * @dev attach actual holographableContract function call\n       */\n      bridgeOutPayload\n    );\n    /**\n     * @dev add gas variables to the back for later extraction\n     */\n    encodedData = abi.encodePacked(encodedData, gasLimit, gasPrice);\n    /**\n     * @dev Send the data to the current Holograph Messaging Module\n     *      This will be changed to dynamically select which messaging module to use based on destination network\n     */\n    messagingModule.send{value: msg.value - hlgFee}(\n      gasLimit,\n      gasPrice,\n      toChain,\n      msgSender,\n      msg.value - hlgFee,\n      encodedData\n    );\n    /**\n     * @dev for easy indexing, an event is emitted with the payload hash for status tracking\n     */\n    emit CrossChainMessageSent(keccak256(encodedData));\n  }\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @dev @param toChain holograph chain id of destination chain for payload\n   * @dev @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @dev @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @dev @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(uint32, uint256, uint256, bytes calldata) external view returns (uint256, uint256, uint256) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := staticcall(gas(), sload(_messagingModuleSlot), 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Get the details for an available operator job\n   * @dev The job hash is a keccak256 hash of the entire job payload\n   * @param jobHash keccak256 hash of the job\n   * @return an OperatorJob struct with details about a specific job\n   */\n  function getJobDetails(bytes32 jobHash) public view returns (OperatorJob memory) {\n    uint256 packed = _operatorJobs[jobHash];\n    /**\n     * @dev The job is bitwise packed into a single 32 byte slot, this unpacks it before returning the struct\n     */\n    return\n      OperatorJob(\n        uint8(packed >> 248),\n        uint16(_blockTime),\n        _operatorTempStorage[uint32(packed >> 216)],\n        uint40(packed >> 176),\n        // TODO: move the bit-shifting around to have it be sequential\n        uint64(packed >> 16),\n        [\n          uint16(packed >> 160),\n          uint16(packed >> 144),\n          uint16(packed >> 128),\n          uint16(packed >> 112),\n          uint16(packed >> 96)\n        ]\n      );\n  }\n\n  /**\n   * @notice Get number of pods available\n   * @dev This returns number of pods that have been opened via bonding\n   */\n  function getTotalPods() external view returns (uint256 totalPods) {\n    return _operatorPods.length;\n  }\n\n  /**\n   * @notice Get total number of operators in a pod\n   * @dev Use in conjunction with paginated getPodOperators function\n   * @param pod the pod to query\n   * @return total operators in a pod\n   */\n  function getPodOperatorsLength(uint256 pod) external view returns (uint256) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    return _operatorPods[pod - 1].length;\n  }\n\n  /**\n   * @notice Get list of operators in a pod\n   * @dev Use paginated getPodOperators function instead if list gets too long\n   * @param pod the pod to query\n   * @return operators array list of operators in a pod\n   */\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    operators = _operatorPods[pod - 1];\n  }\n\n  /**\n   * @notice Get paginated list of operators in a pod\n   * @dev Use in conjunction with getPodOperatorsLength to know the total length of results\n   * @param pod the pod to query\n   * @param index the array index to start from\n   * @param length the length of result set to be (will be shorter if reached end of array)\n   * @return operators a paginated array of operators\n   */\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    /**\n     * @dev if pod 0 is selected, this will create a revert\n     */\n    pod--;\n    /**\n     * @dev get total length of pod operators\n     */\n    uint256 supply = _operatorPods[pod].length;\n    /**\n     * @dev check if length is out of bounds for this result set\n     */\n    if (index + length > supply) {\n      /**\n       * @dev adjust length to return remainder of the results\n       */\n      length = supply - index;\n    }\n    /**\n     * @dev create in-memory array\n     */\n    operators = new address[](length);\n    /**\n     * @dev add operators to result set\n     */\n    for (uint256 i = 0; i < length; i++) {\n      operators[i] = _operatorPods[pod][index + i];\n    }\n  }\n\n  /**\n   * @notice Check the base and current price for bonding to a particular pod\n   * @dev Useful for understanding what is required for bonding to a pod\n   * @param pod the pod to get bonding amounts for\n   * @return base the base bond amount required for a pod\n   * @return current the current bond amount required for a pod\n   */\n  function getPodBondAmounts(uint256 pod) external view returns (uint256 base, uint256 current) {\n    base = _getBaseBondAmount(pod - 1);\n    current = _getCurrentBondAmount(pod - 1);\n  }\n\n  /**\n   * @notice Get an operator's currently bonded amount\n   * @dev Useful for checking how much an operator has bonded\n   * @param operator address of operator to check\n   * @return amount total number of utility token bonded\n   */\n  function getBondedAmount(address operator) external view returns (uint256 amount) {\n    return _bondedAmounts[operator];\n  }\n\n  /**\n   * @notice Get an operator's currently bonded pod\n   * @dev Useful for checking if an operator is currently bonded\n   * @param operator address of operator to check\n   * @return pod number that operator is bonded on, returns zero if not bonded or selected for job\n   */\n  function getBondedPod(address operator) external view returns (uint256 pod) {\n    return _bondedOperators[operator];\n  }\n\n  /**\n   * @notice Get an operator's currently bonded pod index\n   * @dev Useful for checking if an operator is a fallback for active job\n   * @param operator address of operator to check\n   * @return index currently bonded pod's operator index, returns zero if not in pod or moved out for active job\n   */\n  function getBondedPodIndex(address operator) external view returns (uint256 index) {\n    return _operatorPodIndex[operator];\n  }\n\n  /**\n   * @notice Topup a bonded operator with more utility tokens\n   * @dev Useful function if an operator got slashed and wants to add a safety buffer to not get unbonded\n   *      This function will not work if operator has currently been selected for a job\n   * @param operator address of operator to topup\n   * @param amount utility token amount to add\n   */\n  function topupUtilityToken(address operator, uint256 amount) external {\n    /**\n     * @dev check that an operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    unchecked {\n      /**\n       * @dev add the additional amount to operator\n       */\n      _bondedAmounts[operator] += amount;\n    }\n    /**\n     * @dev transfer tokens last, to prevent reentrancy attacks\n     */\n    require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Bond utility tokens and become an operator\n   * @dev An operator can only bond to one pod at a time, per network\n   * @param operator address of operator to bond (can be an ownable smart contract)\n   * @param amount utility token amount to bond (can be greater than minimum)\n   * @param pod number of pod to bond to (can be for one that does not exist yet)\n   */\n  function bondUtilityToken(address operator, uint256 amount, uint256 pod) external {\n    /**\n     * @dev an operator can only bond to one pod at any give time per network\n     */\n    require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n    if (_isContract(operator)) {\n      require(Ownable(operator).owner() != address(0), \"HOLOGRAPH: contract not ownable\");\n    }\n    unchecked {\n      /**\n       * @dev get the current bonding minimum for selected pod\n       */\n      uint256 current = _getCurrentBondAmount(pod - 1);\n      require(current <= amount, \"HOLOGRAPH: bond amount too small\");\n      /**\n       * @dev check if selected pod is greater than currently existing pods\n       */\n      if (_operatorPods.length < pod) {\n        /**\n         * @dev activate pod(s) up until the selected pod\n         */\n        for (uint256 i = _operatorPods.length; i < pod; i++) {\n          /**\n           * @dev add zero address into pod to mitigate empty pod issues\n           */\n          _operatorPods.push([address(0)]);\n        }\n      }\n      /**\n       * @dev prevent bonding to a pod with more than uint16 max value\n       */\n      require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");\n      _operatorPods[pod - 1].push(operator);\n      _operatorPodIndex[operator] = _operatorPods[pod - 1].length - 1;\n      _bondedOperators[operator] = pod;\n      _bondedAmounts[operator] = amount;\n      /**\n       * @dev transfer tokens last, to prevent reentrancy attacks\n       */\n      require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n    }\n  }\n\n  /**\n   * @notice Unbond HLG utility tokens and stop being an operator\n   * @dev A bonded operator selected for a job cannot unbond until they complete the job, or are slashed\n   * @param operator address of operator to unbond\n   * @param recipient address where to send the bonded tokens\n   */\n  function unbondUtilityToken(address operator, address recipient) external {\n    /**\n     * @dev validate that operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    /**\n     * @dev check if sender is not actual operator\n     */\n    if (msg.sender != operator) {\n      /**\n       * @dev check if operator is a smart contract\n       */\n      require(_isContract(operator), \"HOLOGRAPH: operator not contract\");\n      /**\n       * @dev check if smart contract is owned by sender\n       */\n      require(Ownable(operator).owner() == msg.sender, \"HOLOGRAPH: sender not owner\");\n    }\n    /**\n     * @dev get current bonded amount by operator\n     */\n    uint256 amount = _bondedAmounts[operator];\n    /**\n     * @dev unset operator bond amount before making a transfer\n     */\n    _bondedAmounts[operator] = 0;\n    /**\n     * @dev remove all operator references\n     */\n    _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);\n    /**\n     * @dev transfer tokens to recipient\n     */\n    require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Messaging Module\n   * @dev All cross-chain message requests will get forwarded to this adress\n   */\n  function getMessagingModule() external view returns (address messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Messaging Module address\n   * @param messagingModule address of the LayerZero Endpoint to use\n   */\n  function setMessagingModule(address messagingModule) external onlyAdmin {\n    assembly {\n      sstore(_messagingModuleSlot, messagingModule)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n  }\n\n  /**\n   * @notice Get the Minimum Gas Price\n   * @dev The minimum value required to execute a job without it being marked as under priced\n   */\n  function getMinGasPrice() external view returns (uint256 minGasPrice) {\n    assembly {\n      minGasPrice := sload(_minGasPriceSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Minimum Gas Price\n   * @param minGasPrice amount to set for minimum gas price\n   */\n  function setMinGasPrice(uint256 minGasPrice) external onlyAdmin {\n    assembly {\n      sstore(_minGasPriceSlot, minGasPrice)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interface\n   */\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Messaging Module Interface\n   */\n  function _messagingModule() private view returns (CrossChainMessageInterface messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Registry Interface\n   */\n  function _registry() private view returns (HolographRegistryInterface registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Utility Token Interface\n   */\n  function _utilityToken() private view returns (HolographERC20Interface utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the minimum gas price allowed\n   */\n  function _minGasPrice() private view returns (uint256 minGasPrice) {\n    assembly {\n      minGasPrice := sload(_minGasPriceSlot)\n    }\n  }\n\n  /**\n   * @dev Internal nonce, that increments on each call, used for randomness\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  /**\n   * @dev Internal function used to remove an operator from a particular pod\n   */\n  function _popOperator(uint256 pod, uint256 operatorIndex) private {\n    /**\n     * @dev only pop the operator if it's not a zero address\n     */\n    if (operatorIndex > 0) {\n      unchecked {\n        address operator = _operatorPods[pod][operatorIndex];\n        /**\n         * @dev mark operator as no longer bonded\n         */\n        _bondedOperators[operator] = 0;\n        /**\n         * @dev remove pod reference for operator\n         */\n        _operatorPodIndex[operator] = 0;\n        uint256 lastIndex = _operatorPods[pod].length - 1;\n        if (lastIndex != operatorIndex) {\n          /**\n           * @dev if operator is not last index, move last index to operator's current index\n           */\n          _operatorPods[pod][operatorIndex] = _operatorPods[pod][lastIndex];\n          _operatorPodIndex[_operatorPods[pod][operatorIndex]] = operatorIndex;\n        }\n        /**\n         * @dev delete last index\n         */\n        delete _operatorPods[pod][lastIndex];\n        /**\n         * @dev shorten array length\n         */\n        _operatorPods[pod].pop();\n      }\n    }\n  }\n\n  /**\n   * @dev Internal function used for calculating the base bonding amount for a pod\n   */\n  function _getBaseBondAmount(uint256 pod) private view returns (uint256) {\n    return (_podMultiplier ** pod) * _baseBondAmount;\n  }\n\n  /**\n   * @dev Internal function used for calculating the current bonding amount for a pod\n   */\n  function _getCurrentBondAmount(uint256 pod) private view returns (uint256) {\n    uint256 current = (_podMultiplier ** pod) * _baseBondAmount;\n    if (pod >= _operatorPods.length) {\n      return current;\n    }\n    uint256 threshold = _operatorThreshold / (2 ** pod);\n    uint256 position = _operatorPods[pod].length;\n    if (position > threshold) {\n      position -= threshold;\n      //       current += (current / _operatorThresholdDivisor) * position;\n      current += (current / _operatorThresholdDivisor) * (position / _operatorThresholdStep);\n    }\n    return current;\n  }\n\n  /**\n   * @dev Internal function used for generating a random pod operator selection by using previously mined blocks\n   */\n  function _randomBlockHash(uint256 random, uint256 podSize, uint256 n) private view returns (uint256) {\n    unchecked {\n      return (random + uint256(blockhash(block.number - n))) % podSize;\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Purposefully left empty to ensure ether transfers use least amount of gas possible\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/HolographRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\n\n/**\n * @title Holograph Registry\n * @author https://github.com/holographxyz\n * @notice View and validate all deployed holographable contracts\n * @dev Use this to: validate that contracts are Holograph Protocol compliant, get source code for supported standards, and interact with hTokens\n */\ncontract HolographRegistry is Admin, Initializable, HolographRegistryInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n\n  /**\n   * @dev Array of all Holographable contracts that were ever deployed on this chain\n   */\n  address[] private _holographableContracts;\n\n  /**\n   * @dev A mapping of hashes to contract addresses\n   */\n  mapping(bytes32 => address) private _holographedContractsHashMap;\n\n  /**\n   * @dev Storage slot for saving contract type to contract address references\n   */\n  mapping(bytes32 => address) private _contractTypeAddresses;\n\n  /**\n   * @dev Reserved type addresses for Admin\n   *  Note: this is used for defining default contracts\n   */\n  mapping(bytes32 => bool) private _reservedTypes;\n\n  /**\n   * @dev A list of smart contracts that are guaranteed secure and holographable\n   */\n  mapping(address => bool) private _holographedContracts;\n\n  /**\n   * @dev Mapping of all hTokens available for the different EVM chains\n   */\n  mapping(uint32 => address) private _hTokens;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address holograph, bytes32[] memory reservedTypes) = abi.decode(initPayload, (address, bytes32[]));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_holographSlot, holograph)\n    }\n    for (uint256 i = 0; i < reservedTypes.length; i++) {\n      _reservedTypes[reservedTypes[i]] = true;\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function isHolographedContract(address smartContract) external view returns (bool) {\n    return _holographedContracts[smartContract];\n  }\n\n  function isHolographedHashDeployed(bytes32 hash) external view returns (bool) {\n    return _holographedContractsHashMap[hash] != address(0);\n  }\n\n  function holographableEvent(bytes calldata payload) external {\n    if (_holographedContracts[msg.sender]) {\n      emit HolographableContractEvent(msg.sender, payload);\n    }\n  }\n\n  /**\n   * @dev Allows to reference a deployed smart contract, and use it's code as reference inside of Holographers\n   */\n  function referenceContractTypeAddress(address contractAddress) external returns (bytes32) {\n    bytes32 contractType;\n    assembly {\n      contractType := extcodehash(contractAddress)\n    }\n    require(\n      (// check that bytecode is not empty\n      contractType != 0x0 &&\n        // check that hash is not for empty bytes\n        contractType != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470),\n      \"HOLOGRAPH: empty contract\"\n    );\n    require(_contractTypeAddresses[contractType] == address(0), \"HOLOGRAPH: contract already set\");\n    require(!_reservedTypes[contractType], \"HOLOGRAPH: reserved address type\");\n    _contractTypeAddresses[contractType] = contractAddress;\n    return contractType;\n  }\n\n  /**\n   * @dev Returns the contract address for a contract type\n   */\n  function getContractTypeAddress(bytes32 contractType) external view returns (address) {\n    return _contractTypeAddresses[contractType];\n  }\n\n  /**\n   * @dev Sets the contract address for a contract type\n   */\n  function setContractTypeAddress(bytes32 contractType, address contractAddress) external onlyAdmin {\n    require(_reservedTypes[contractType], \"HOLOGRAPH: not reserved type\");\n    _contractTypeAddresses[contractType] = contractAddress;\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev This contract stores a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for all holographable contracts\n   * @param index The index to start enumeration from\n   * @param length The length of returned results\n   * @return contracts address[] Returns a set length array of holographable contracts deployed\n   */\n  function getHolographableContracts(uint256 index, uint256 length) external view returns (address[] memory contracts) {\n    uint256 supply = _holographableContracts.length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    contracts = new address[](length);\n    for (uint256 i = 0; i < length; i++) {\n      contracts[i] = _holographableContracts[index + i];\n    }\n  }\n\n  /**\n   * @notice Get total number of deployed holographable contracts\n   */\n  function getHolographableContractsLength() external view returns (uint256) {\n    return _holographableContracts.length;\n  }\n\n  /**\n   * @dev Returns the address for a holographed hash\n   */\n  function getHolographedHashAddress(bytes32 hash) external view returns (address) {\n    return _holographedContractsHashMap[hash];\n  }\n\n  /**\n   * @dev Allows Holograph Factory to register a deployed contract, referenced with deployment hash\n   */\n  function setHolographedHashAddress(bytes32 hash, address contractAddress) external {\n    address holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n    require(msg.sender == HolographInterface(holograph).getFactory(), \"HOLOGRAPH: factory only function\");\n    _holographedContractsHashMap[hash] = contractAddress;\n    _holographedContracts[contractAddress] = true;\n    _holographableContracts.push(contractAddress);\n  }\n\n  /**\n   * @dev Returns the hToken address for a given chain id\n   */\n  function getHToken(uint32 chainId) external view returns (address) {\n    return _hTokens[chainId];\n  }\n\n  /**\n   * @dev Sets the hToken address for a specific chain id\n   */\n  function setHToken(uint32 chainId, address hToken) external onlyAdmin {\n    _hTokens[chainId] = hToken;\n  }\n\n  /**\n   * @dev Returns the reserved contract address for a contract type\n   */\n  function getReservedContractTypeAddress(bytes32 contractType) external view returns (address contractTypeAddress) {\n    if (_reservedTypes[contractType]) {\n      contractTypeAddress = _contractTypeAddresses[contractType];\n    }\n  }\n\n  /**\n   * @dev Allows admin to update or toggle reserved type\n   */\n  function setReservedContractTypeAddress(bytes32 hash, bool reserved) external onlyAdmin {\n    _reservedTypes[hash] = reserved;\n  }\n\n  /**\n   * @dev Allows admin to update or toggle reserved types\n   */\n  function setReservedContractTypeAddresses(bytes32[] calldata hashes, bool[] calldata reserved) external onlyAdmin {\n    for (uint256 i = 0; i < hashes.length; i++) {\n      _reservedTypes[hashes[i]] = reserved[i];\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/HolographTreasury.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/HolographERC721Interface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographTreasuryInterface.sol\";\nimport \"./interface/HolographFactoryInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\n\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title Holograph Treasury\n * @author https://github.com/holographxyz\n * @notice This contract holds and manages the protocol treasury\n * @dev As of now this is an empty zero logic contract and is still a work in progress\n */\ncontract HolographTreasury is Admin, Initializable, HolographTreasuryInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Holograph Mint Fee is can be used to charge a flat fee for minting\n   */\n  uint256 public holographMintFee;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address holograph, address operator, address registry) = abi.decode(\n      initPayload,\n      (address, address, address, address)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_operatorSlot, operator)\n      sstore(_registrySlot, registry)\n    }\n\n    holographMintFee = 1000000; // $1.00 USD (6 decimal places)\n\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev This contract stores a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function _holograph() private view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _operator() private view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function _registry() private view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Mint Fee\n   * @dev This fee is charged to mint holographable assets\n   */\n  function getHolographMintFee() external view returns (uint256) {\n    return holographMintFee;\n  }\n\n  /**\n   * @notice Update the Holograph Mint Fee\n   * @param fee new fee to charge for minting holographable assets\n   */\n  function setHolographMintFee(uint256 fee) external onlyAdmin {\n    holographMintFee = fee;\n  }\n\n  /**\n   * @notice Withdraws native tokens from the contract\n   * @dev Can only be called by the admin\n   */\n  function withdraw() external onlyAdmin {\n    uint256 balance = address(this).balance;\n    require(balance > 0, \"HOLOGRAPH: No balance to withdraw\");\n\n    (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n    require(success, \"HOLOGRAPH: Withdraw failed\");\n  }\n\n  /**\n   * @notice Withdraws native tokens from the contract to a specified address\n   * @dev Can only be called by the admin\n   * @param recipient The address to send the withdrawn funds to\n   */\n  function withdrawTo(address payable recipient) external onlyAdmin {\n    uint256 balance = address(this).balance;\n    require(balance > 0, \"HOLOGRAPH: No balance to withdraw\");\n\n    (bool success, ) = recipient.call{value: balance}(\"\");\n    require(success, \"HOLOGRAPH: Withdraw failed\");\n  }\n\n  /**\n   * @dev Purposefully left empty to ensure ether transfers use least amount of gas possible\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/interface/CollectionURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CollectionURI {\n  function contractURI() external view returns (string memory);\n}\n"
    },
    "src/interface/CrossChainMessageInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CrossChainMessageInterface {\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 msgValue,\n    bytes calldata crossChainPayload\n  ) external payable;\n\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice);\n\n  function getHlgFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee);\n}\n"
    },
    "src/interface/ERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity 0.8.13;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface ERC1271 {\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param hash      Hash of the data to be signed\n   * @param signature Signature byte array associated with _data\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/interface/ERC165.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/interface/ERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256 balance);\n\n  function transfer(address _to, uint256 _value) external returns (bool success);\n\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n  function approve(address _spender, uint256 _value) external returns (bool success);\n\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"
    },
    "src/interface/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Burnable {\n  function burn(uint256 amount) external;\n\n  function burnFrom(address account, uint256 amount) external returns (bool);\n}\n"
    },
    "src/interface/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Metadata {\n  function decimals() external view returns (uint8);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "src/interface/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity 0.8.13;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface ERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``account``'s tokens,\n   * given ``account``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `account`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``account``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address account,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `account`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``account``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/interface/ERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Receiver {\n  function onERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bytes4);\n}\n"
    },
    "src/interface/ERC20Safer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Safer {\n  function safeTransfer(address recipient, uint256 amount) external returns (bool);\n\n  function safeTransfer(address recipient, uint256 amount, bytes memory data) external returns (bool);\n\n  function safeTransferFrom(address account, address recipient, uint256 amount) external returns (bool);\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n}\n"
    },
    "src/interface/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n/* is ERC165 */\ninterface ERC721 {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param _owner An address for whom to query the balance\n  /// @return The number of NFTs owned by `_owner`, possibly zero\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param _tokenId The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf(uint256 _tokenId) external view returns (address);\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `_to` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  /// @param data Additional data with no specified format, sent in call to `_to`\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param _approved The new approved NFT controller\n  /// @param _tokenId The NFT to approve\n  function approve(address _approved, uint256 _tokenId) external payable;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param _operator Address to add to the set of authorized operators\n  /// @param _approved True if the operator is approved, false to revoke approval\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `_tokenId` is not a valid NFT.\n  /// @param _tokenId The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved(uint256 _tokenId) external view returns (address);\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param _owner The address that owns the NFTs\n  /// @param _operator The address that acts on behalf of the owner\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "src/interface/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n/* is ERC721 */\ninterface ERC721Enumerable {\n  /// @notice Count NFTs tracked by this contract\n  /// @return A count of valid NFTs tracked by this contract, where each one of\n  ///  them has an assigned and queryable owner not equal to the zero address\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Enumerate valid NFTs\n  /// @dev Throws if `_index` >= `totalSupply()`.\n  /// @param _index A counter less than `totalSupply()`\n  /// @return The token identifier for the `_index`th NFT,\n  ///  (sort order not specified)\n  function tokenByIndex(uint256 _index) external view returns (uint256);\n\n  /// @notice Enumerate NFTs assigned to an owner\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n  ///  `_owner` is the zero address, representing invalid NFTs.\n  /// @param _owner An address where we are interested in NFTs owned by them\n  /// @param _index A counter less than `balanceOf(_owner)`\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n  ///   (sort order not specified)\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "src/interface/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface ERC721Metadata {\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n\n  /// @notice An abbreviated name for NFTs in this contract\n  function symbol() external view returns (string memory _symbol);\n\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n  ///  Metadata JSON Schema\".\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/interface/ERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n  /// @notice Handle the receipt of an NFT\n  /// @dev The ERC721 smart contract calls this function on the recipient\n  ///  after a `transfer`. This function MAY throw to revert and reject the\n  ///  transfer. Return of other than the magic value MUST result in the\n  ///  transaction being reverted.\n  ///  Note: the contract address is always the message sender.\n  /// @param _operator The address which called `safeTransferFrom` function\n  /// @param _from The address which previously owned the token\n  /// @param _tokenId The NFT identifier which is being transferred\n  /// @param _data Additional data with no specified format\n  /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  ///  unless throwing\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4);\n}\n"
    },
    "src/interface/Holographable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Holographable {\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external returns (bytes4);\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external returns (bytes4 selector, bytes memory data);\n}\n"
    },
    "src/interface/HolographBridgeInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Holograph Bridge\n * @author https://github.com/holographxyz\n * @notice Beam any holographable contracts and assets across blockchains\n * @dev The contract abstracts all the complexities of making bridge requests and uses a universal interface to bridge any type of holographable assets\n */\ninterface HolographBridgeInterface {\n  /**\n   * @notice Receive a beam from another chain\n   * @dev This function can only be called by the Holograph Operator module\n   * @param fromChain Holograph Chain ID where the brigeOutRequest was created\n   * @param holographableContract address of the destination contract that the bridgeInRequest is targeted for\n   * @param hToken address of the hToken contract that wrapped the origin chain native gas token\n   * @param hTokenRecipient address of recipient for the hToken reward\n   * @param hTokenValue exact amount of hToken reward in wei\n   * @param doNotRevert boolean used to specify if the call should revert\n   * @param bridgeInPayload actual abi encoded bytes of the data that the holographable contract bridgeIn function will receive\n   */\n  function bridgeInRequest(\n    uint256 nonce,\n    uint32 fromChain,\n    address holographableContract,\n    address hToken,\n    address hTokenRecipient,\n    uint256 hTokenValue,\n    bool doNotRevert,\n    bytes calldata bridgeInPayload\n  ) external payable;\n\n  /**\n   * @notice Create a beam request for a destination chain\n   * @dev This function works for deploying contracts and beaming supported holographable assets across chains\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   */\n  function bridgeOutRequest(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata bridgeOutPayload\n  ) external payable;\n\n  /**\n   * @notice Do not call this function, it will always revert\n   * @dev Used by getBridgeOutRequestPayload function\n   *      It is purposefully inverted to always revert on a successful call\n   *      Marked as external and not private to allow use inside try/catch of getBridgeOutRequestPayload function\n   *      If this function does not revert and returns a string, it is the actual revert reason\n   * @param sender address of actual sender that is planning to make a bridgeOutRequest call\n   * @param toChain holograph chain id of destination chain\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   */\n  function revertedBridgeOutRequest(\n    address sender,\n    uint32 toChain,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external returns (string memory revertReason);\n\n  /**\n   * @notice Get the payload created by the bridgeOutRequest function\n   * @dev Use this function to get the payload that will be generated by a bridgeOutRequest\n   *      Only use this with a static call\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   * @return samplePayload bytes made up of the bridgeOutRequest payload\n   */\n  function getBridgeOutRequestPayload(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata bridgeOutPayload\n  ) external returns (bytes memory samplePayload);\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @param toChain holograph chain id of destination chain for payload\n   * @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice);\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory);\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external;\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph);\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external;\n\n  /**\n   * @notice Get the latest job nonce\n   * @dev You can use the job nonce as a way to calculate total amount of bridge requests that have been made\n   */\n  function getJobNonce() external view returns (uint256 jobNonce);\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator);\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n}\n"
    },
    "src/interface/HolographedERC1155.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph ERC-1155 Non-Fungible Token Standard\n/// @dev See https://holograph.network/standard/ERC-1155\n///  Note: the ERC-165 identifier for this interface is 0xFFFFFFFF.\ninterface HolographedERC1155 {\n  // event id = 1\n  function bridgeIn(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bytes memory _data);\n\n  // event id = 3\n  function afterApprove(address _owner, address _to, uint256 _tokenId, uint256 _amount) external returns (bool success);\n\n  // event id = 4\n  function beforeApprove(\n    address _owner,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 5\n  function afterApprovalAll(address _to, bool _approved) external returns (bool success);\n\n  // event id = 6\n  function beforeApprovalAll(address _to, bool _approved) external returns (bool success);\n\n  // event id = 7\n  function afterBurn(address _owner, uint256 _tokenId, uint256 _amount) external returns (bool success);\n\n  // event id = 8\n  function beforeBurn(address _owner, uint256 _tokenId, uint256 _amount) external returns (bool success);\n\n  // event id = 9\n  function afterMint(address _owner, uint256 _tokenId, uint256 _amount) external returns (bool success);\n\n  // event id = 10\n  function beforeMint(address _owner, uint256 _tokenId, uint256 _amount) external returns (bool success);\n\n  // event id = 11\n  function afterSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 12\n  function beforeSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 13\n  function afterTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 14\n  function beforeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 15\n  function afterOnERC1155Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 16\n  function beforeOnERC1155Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n}\n"
    },
    "src/interface/HolographedERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph ERC-20 Fungible Token Standard\n/// @dev See https://holograph.network/standard/ERC-20\n///  Note: the ERC-165 identifier for this interface is 0xFFFFFFFF.\ninterface HolographedERC20 {\n  // event id = 1\n  function bridgeIn(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external returns (bytes memory _data);\n\n  // event id = 3\n  function afterApprove(address _owner, address _to, uint256 _amount) external returns (bool success);\n\n  // event id = 4\n  function beforeApprove(address _owner, address _to, uint256 _amount) external returns (bool success);\n\n  // event id = 5\n  function afterOnERC20Received(\n    address _token,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 6\n  function beforeOnERC20Received(\n    address _token,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 7\n  function afterBurn(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 8\n  function beforeBurn(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 9\n  function afterMint(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 10\n  function beforeMint(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 11\n  function afterSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 12\n  function beforeSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 13\n  function afterTransfer(address _from, address _to, uint256 _amount) external returns (bool success);\n\n  // event id = 14\n  function beforeTransfer(address _from, address _to, uint256 _amount) external returns (bool success);\n\n  // event id = 15\n  function onAllowance(address _owner, address _to, uint256 _amount) external returns (bool success);\n}\n"
    },
    "src/interface/HolographedERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph ERC-721 Non-Fungible Token Standard\n/// @dev See https://holograph.network/standard/ERC-721\n///  Note: the ERC-165 identifier for this interface is 0xFFFFFFFF.\ninterface HolographedERC721 {\n  // event id = 1\n  function bridgeIn(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) external returns (bytes memory _data);\n\n  // event id = 3\n  function afterApprove(address _owner, address _to, uint256 _tokenId) external returns (bool success);\n\n  // event id = 4\n  function beforeApprove(address _owner, address _to, uint256 _tokenId) external returns (bool success);\n\n  // event id = 5\n  function afterApprovalAll(address _sender, address _to, bool _approved) external returns (bool success);\n\n  // event id = 6\n  function beforeApprovalAll(address _sender, address _to, bool _approved) external returns (bool success);\n\n  // event id = 7\n  function afterBurn(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 8\n  function beforeBurn(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 9\n  function afterMint(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 10\n  function beforeMint(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 11\n  function afterSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 12\n  function beforeSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 13\n  function afterTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 14\n  function beforeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 15\n  function afterOnERC721Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 16\n  function beforeOnERC721Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 17\n  function onIsApprovedForAll(address _wallet, address _operator) external view returns (bool approved);\n\n  // event id = 18\n  function contractURI() external view returns (string memory contractJSON);\n}\n"
    },
    "src/interface/HolographedGeneric.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph Generic Standard\ninterface HolographedGeneric {\n  // event id = 1\n  function bridgeIn(uint32 _chainId, bytes calldata _data) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(uint32 _chainId, address _sender, bytes calldata _payload) external returns (bytes memory _data);\n}\n"
    },
    "src/interface/HolographERC20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./ERC20.sol\";\nimport \"./ERC20Burnable.sol\";\nimport \"./ERC20Metadata.sol\";\nimport \"./ERC20Permit.sol\";\nimport \"./ERC20Receiver.sol\";\nimport \"./ERC20Safer.sol\";\nimport \"./ERC165.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographERC20Interface is\n  ERC165,\n  ERC20,\n  ERC20Burnable,\n  ERC20Metadata,\n  ERC20Receiver,\n  ERC20Safer,\n  ERC20Permit,\n  Holographable\n{\n  function holographBridgeMint(address to, uint256 amount) external returns (bytes4);\n\n  function sourceBurn(address from, uint256 amount) external;\n\n  function sourceMint(address to, uint256 amount) external;\n\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external;\n\n  function sourceTransfer(address from, address to, uint256 amount) external;\n\n  function sourceTransfer(address payable destination, uint256 amount) external;\n\n  function sourceExternalCall(address target, bytes calldata data) external;\n}\n"
    },
    "src/interface/HolographERC721Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./CollectionURI.sol\";\nimport \"./ERC165.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\nimport \"./ERC721TokenReceiver.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographERC721Interface is\n  ERC165,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Metadata,\n  ERC721TokenReceiver,\n  CollectionURI,\n  Holographable\n{\n  function approve(address to, uint256 tokenId) external payable;\n\n  function burn(uint256 tokenId) external;\n\n  function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n  function setApprovalForAll(address to, bool approved) external;\n\n  function sourceBurn(uint256 tokenId) external;\n\n  function sourceMint(address to, uint224 tokenId) external;\n\n  function sourceGetChainPrepend() external view returns (uint256);\n\n  function sourceTransfer(address to, uint256 tokenId) external;\n\n  function sourceExternalCall(address target, bytes calldata data) external;\n\n  function transfer(address to, uint256 tokenId) external payable;\n\n  function contractURI() external view returns (string memory);\n\n  function getApproved(uint256 tokenId) external view returns (address);\n\n  function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function burned(uint256 tokenId) external view returns (bool);\n\n  function decimals() external pure returns (uint256);\n\n  function exists(uint256 tokenId) external view returns (bool);\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256);\n\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "src/interface/HolographerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographerInterface {\n  function getContractType() external view returns (bytes32 contractType);\n\n  function getDeploymentBlock() external view returns (uint256 deploymentBlock);\n\n  function getHolograph() external view returns (address holograph);\n\n  function getHolographEnforcer() external view returns (address);\n\n  function getOriginChain() external view returns (uint32 originChain);\n\n  function getSourceContract() external view returns (address sourceContract);\n}\n"
    },
    "src/interface/HolographFactoryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../struct/DeploymentConfig.sol\";\nimport \"../struct/Verification.sol\";\n\n/**\n * @title Holograph Factory\n * @author https://github.com/holographxyz\n * @notice Deploy holographable contracts\n * @dev The contract provides methods that allow for the creation of Holograph Protocol compliant smart contracts, that are capable of minting holographable assets\n */\ninterface HolographFactoryInterface {\n  /**\n   * @dev This event is fired every time that a bridgeable contract is deployed.\n   */\n  event BridgeableContractDeployed(address indexed contractAddress, bytes32 indexed hash);\n\n  /**\n   * @notice Deploy a holographable smart contract\n   * @dev Using this function allows to deploy smart contracts that have the same address across all EVM chains\n   * @param config contract deployement configurations\n   * @param signature that was created by the wallet that created the original payload\n   * @param signer address of wallet that created the payload\n   */\n  function deployHolographableContract(\n    DeploymentConfig memory config,\n    Verification memory signature,\n    address signer\n  ) external;\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph);\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n}\n"
    },
    "src/interface/HolographGenericInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./ERC165.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographGenericInterface is ERC165, Holographable {\n  function sourceEmit(bytes calldata eventData) external;\n\n  function sourceEmit(bytes32 eventId, bytes calldata eventData) external;\n\n  function sourceEmit(bytes32 eventId, bytes32 topic1, bytes calldata eventData) external;\n\n  function sourceEmit(bytes32 eventId, bytes32 topic1, bytes32 topic2, bytes calldata eventData) external;\n\n  function sourceEmit(\n    bytes32 eventId,\n    bytes32 topic1,\n    bytes32 topic2,\n    bytes32 topic3,\n    bytes calldata eventData\n  ) external;\n}\n"
    },
    "src/interface/HolographInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Holograph Protocol\n * @author https://github.com/holographxyz\n * @notice This is the primary Holograph Protocol smart contract\n * @dev This contract stores a reference to all the primary modules and variables of the protocol\n */\ninterface HolographInterface {\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge);\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external;\n\n  /**\n   * @notice Get the chain ID that the Protocol was deployed on\n   * @dev Useful for checking if/when a hard fork occurs\n   */\n  function getChainId() external view returns (uint256 chainId);\n\n  /**\n   * @notice Update the chain ID\n   * @dev Useful for updating once a hard fork has been mitigated\n   * @param chainId EVM chain ID to use\n   */\n  function setChainId(uint256 chainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory);\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external;\n\n  /**\n   * @notice Get the Holograph chain Id\n   * @dev Holograph uses an internal chain id mapping\n   */\n  function getHolographChainId() external view returns (uint32 holographChainId);\n\n  /**\n   * @notice Update the Holograph chain ID\n   * @dev Useful for updating once a hard fork was mitigated\n   * @param holographChainId Holograph chain ID to use\n   */\n  function setHolographChainId(uint32 holographChainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces);\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external;\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator);\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n\n  /**\n   * @notice Get the Holograph Treasury module\n   * @dev All of the Holograph Protocol assets are stored and managed by this module\n   */\n  function getTreasury() external view returns (address treasury);\n\n  /**\n   * @notice Update the Holograph Treasury module address\n   * @param treasury address of the Holograph Treasury smart contract to use\n   */\n  function setTreasury(address treasury) external;\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken);\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external;\n}\n"
    },
    "src/interface/HolographInterfacesInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../enum/ChainIdType.sol\";\nimport \"../enum/InterfaceType.sol\";\nimport \"../enum/TokenUriType.sol\";\n\ninterface HolographInterfacesInterface {\n  function contractURI(\n    string calldata name,\n    string calldata imageURL,\n    string calldata externalLink,\n    uint16 bps,\n    address contractAddress\n  ) external pure returns (string memory);\n\n  function getUriPrepend(TokenUriType uriType) external view returns (string memory prepend);\n\n  function updateUriPrepend(TokenUriType uriType, string calldata prepend) external;\n\n  function updateUriPrepends(TokenUriType[] calldata uriTypes, string[] calldata prepends) external;\n\n  function getChainId(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType\n  ) external view returns (uint256 toChainId);\n\n  function updateChainIdMap(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType,\n    uint256 toChainId\n  ) external;\n\n  function updateChainIdMaps(\n    ChainIdType[] calldata fromChainType,\n    uint256[] calldata fromChainId,\n    ChainIdType[] calldata toChainType,\n    uint256[] calldata toChainId\n  ) external;\n\n  function supportsInterface(InterfaceType interfaceType, bytes4 interfaceId) external view returns (bool);\n\n  function updateInterface(InterfaceType interfaceType, bytes4 interfaceId, bool supported) external;\n\n  function updateInterfaces(InterfaceType interfaceType, bytes4[] calldata interfaceIds, bool supported) external;\n}\n"
    },
    "src/interface/HolographOperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../struct/OperatorJob.sol\";\n\ninterface HolographOperatorInterface {\n  /**\n   * @dev Event is emitted for every time that a valid job is available.\n   */\n  event AvailableOperatorJob(bytes32 jobHash, bytes payload);\n\n  /**\n   * @dev Event is emitted for every time that a job is completed.\n   */\n  event FinishedOperatorJob(bytes32 jobHash, address operator);\n\n  /**\n   * @dev Event is emitted every time a cross-chain message is sent\n   */\n  event CrossChainMessageSent(bytes32 messageHash);\n\n  /**\n   * @dev Event is emitted if an operator job execution fails\n   */\n  event FailedOperatorJob(bytes32 jobHash);\n\n  /**\n   * @notice Execute an available operator job\n   * @dev When making this call, if operating criteria is not met, the call will revert\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable;\n\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable;\n\n  /**\n   * @notice Receive a cross-chain message\n   * @dev This function is restricted for use by Holograph Messaging Module only\n   */\n  function crossChainMessage(bytes calldata bridgeInRequestPayload) external payable;\n\n  /**\n   * @notice Calculate the amount of gas needed to execute a bridgeInRequest\n   * @dev Use this function to estimate the amount of gas that will be used by the bridgeInRequest function\n   *      Set a specific gas limit when making this call, subtract return value, to get total gas used\n   *      Only use this with a static call\n   * @param bridgeInRequestPayload abi encoded bytes making up the bridgeInRequest payload\n   * @return the gas amount remaining after the static call is returned\n   */\n  function jobEstimator(bytes calldata bridgeInRequestPayload) external payable returns (uint256);\n\n  /**\n   * @notice Send cross chain bridge request message\n   * @dev This function is restricted to only be callable by Holograph Bridge\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param nonce incremented number used to ensure job hashes are unique\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload bytes made up of the bridgeOutRequest payload\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 nonce,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external payable;\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @param toChain holograph chain id of destination chain for payload\n   * @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice);\n\n  /**\n   * @notice Get the details for an available operator job\n   * @dev The job hash is a keccak256 hash of the entire job payload\n   * @param jobHash keccak256 hash of the job\n   * @return an OperatorJob struct with details about a specific job\n   */\n  function getJobDetails(bytes32 jobHash) external view returns (OperatorJob memory);\n\n  /**\n   * @notice Get number of pods available\n   * @dev This returns number of pods that have been opened via bonding\n   */\n  function getTotalPods() external view returns (uint256 totalPods);\n\n  /**\n   * @notice Get total number of operators in a pod\n   * @dev Use in conjunction with paginated getPodOperators function\n   * @param pod the pod to query\n   * @return total operators in a pod\n   */\n  function getPodOperatorsLength(uint256 pod) external view returns (uint256);\n\n  /**\n   * @notice Get list of operators in a pod\n   * @dev Use paginated getPodOperators function instead if list gets too long\n   * @param pod the pod to query\n   * @return operators array list of operators in a pod\n   */\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators);\n\n  /**\n   * @notice Get paginated list of operators in a pod\n   * @dev Use in conjunction with getPodOperatorsLength to know the total length of results\n   * @param pod the pod to query\n   * @param index the array index to start from\n   * @param length the length of result set to be (will be shorter if reached end of array)\n   * @return operators a paginated array of operators\n   */\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators);\n\n  /**\n   * @notice Check the base and current price for bonding to a particular pod\n   * @dev Useful for understanding what is required for bonding to a pod\n   * @param pod the pod to get bonding amounts for\n   * @return base the base bond amount required for a pod\n   * @return current the current bond amount required for a pod\n   */\n  function getPodBondAmounts(uint256 pod) external view returns (uint256 base, uint256 current);\n\n  /**\n   * @notice Get an operator's currently bonded amount\n   * @dev Useful for checking how much an operator has bonded\n   * @param operator address of operator to check\n   * @return amount total number of utility token bonded\n   */\n  function getBondedAmount(address operator) external view returns (uint256 amount);\n\n  /**\n   * @notice Get an operator's currently bonded pod\n   * @dev Useful for checking if an operator is currently bonded\n   * @param operator address of operator to check\n   * @return pod number that operator is bonded on, returns zero if not bonded or selected for job\n   */\n  function getBondedPod(address operator) external view returns (uint256 pod);\n\n  /**\n   * @notice Get an operator's currently bonded pod index\n   * @dev Useful for checking if an operator is a fallback for active job\n   * @param operator address of operator to check\n   * @return index currently bonded pod's operator index, returns zero if not in pod or moved out for active job\n   */\n  function getBondedPodIndex(address operator) external view returns (uint256 index);\n\n  /**\n   * @notice Topup a bonded operator with more utility tokens\n   * @dev Useful function if an operator got slashed and wants to add a safety buffer to not get unbonded\n   * @param operator address of operator to topup\n   * @param amount utility token amount to add\n   */\n  function topupUtilityToken(address operator, uint256 amount) external;\n\n  /**\n   * @notice Bond utility tokens and become an operator\n   * @dev An operator can only bond to one pod at a time, per network\n   * @param operator address of operator to bond (can be an ownable smart contract)\n   * @param amount utility token amount to bond (can be greater than minimum)\n   * @param pod number of pod to bond to (can be for one that does not exist yet)\n   */\n  function bondUtilityToken(address operator, uint256 amount, uint256 pod) external;\n\n  /**\n   * @notice Unbond HLG utility tokens and stop being an operator\n   * @dev A bonded operator selected for a job cannot unbond until they complete the job, or are slashed\n   * @param operator address of operator to unbond\n   * @param recipient address where to send the bonded tokens\n   */\n  function unbondUtilityToken(address operator, address recipient) external;\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge);\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external;\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph);\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external;\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces);\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external;\n\n  /**\n   * @notice Get the address of the Holograph Messaging Module\n   * @dev All cross-chain message requests will get forwarded to this adress\n   */\n  function getMessagingModule() external view returns (address messagingModule);\n\n  /**\n   * @notice Update the Holograph Messaging Module address\n   * @param messagingModule address of the LayerZero Endpoint to use\n   */\n  function setMessagingModule(address messagingModule) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken);\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external;\n\n  /**\n   * @notice Get the Minimum Gas Price\n   * @dev This amount is used as the value that will define a job as underpriced is lower than\n   */\n  function getMinGasPrice() external view returns (uint256 minGasPrice);\n\n  /**\n   * @notice Update the Minimum Gas Price\n   * @param minGasPrice amount to set for minimum gas price\n   */\n  function setMinGasPrice(uint256 minGasPrice) external;\n}\n"
    },
    "src/interface/HolographRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographRegistryInterface {\n  event HolographableContractEvent(address indexed _holographableContract, bytes _payload);\n\n  function isHolographedContract(address smartContract) external view returns (bool);\n\n  function isHolographedHashDeployed(bytes32 hash) external view returns (bool);\n\n  function referenceContractTypeAddress(address contractAddress) external returns (bytes32);\n\n  function getContractTypeAddress(bytes32 contractType) external view returns (address);\n\n  function setContractTypeAddress(bytes32 contractType, address contractAddress) external;\n\n  function getHolograph() external view returns (address holograph);\n\n  function setHolograph(address holograph) external;\n\n  function getHolographableContracts(uint256 index, uint256 length) external view returns (address[] memory contracts);\n\n  function getHolographableContractsLength() external view returns (uint256);\n\n  function getHolographedHashAddress(bytes32 hash) external view returns (address);\n\n  function setHolographedHashAddress(bytes32 hash, address contractAddress) external;\n\n  function getHToken(uint32 chainId) external view returns (address);\n\n  function setHToken(uint32 chainId, address hToken) external;\n\n  function getReservedContractTypeAddress(bytes32 contractType) external view returns (address contractTypeAddress);\n\n  function setReservedContractTypeAddress(bytes32 hash, bool reserved) external;\n\n  function setReservedContractTypeAddresses(bytes32[] calldata hashes, bool[] calldata reserved) external;\n\n  function getUtilityToken() external view returns (address utilityToken);\n\n  function setUtilityToken(address utilityToken) external;\n\n  function holographableEvent(bytes calldata payload) external;\n}\n"
    },
    "src/interface/HolographRoyaltiesInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../struct/ZoraBidShares.sol\";\n\ninterface HolographRoyaltiesInterface {\n  function initHolographRoyalties(bytes memory data) external returns (bytes4);\n\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) external;\n\n  function getPayoutInfo() external view returns (address payable[] memory addresses, uint256[] memory bps);\n\n  function getEthPayout() external;\n\n  function getTokenPayout(address tokenAddress) external;\n\n  function getTokensPayout(address[] memory tokenAddresses) external;\n\n  function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n\n  function setRoyalties(uint256 tokenId, address payable receiver, uint256 bp) external;\n\n  function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n  function getFeeBps(uint256 tokenId) external view returns (uint256[] memory);\n\n  function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n\n  function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n\n  function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n\n  function tokenCreator(address /* contractAddress*/, uint256 tokenId) external view returns (address);\n\n  function calculateRoyaltyFee(\n    address /* contractAddress */,\n    uint256 tokenId,\n    uint256 amount\n  ) external view returns (uint256);\n\n  function marketContract() external view returns (address);\n\n  function tokenCreators(uint256 tokenId) external view returns (address);\n\n  function bidSharesForToken(uint256 tokenId) external view returns (HolographBidShares memory bidShares);\n\n  function getStorageSlot(string calldata slot) external pure returns (bytes32);\n\n  function getTokenAddress(string memory tokenName) external view returns (address);\n}\n"
    },
    "src/interface/HolographTreasuryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographTreasuryInterface {\n  /**\n   * @notice Update the Holograph Mint Fee\n   * @param fee new fee to charge for minting holographable assets\n   */\n  function setHolographMintFee(uint256 fee) external;\n\n  /**\n   * @notice Withdraws native tokens from the contract\n   * @dev Can only be called by the admin\n   */\n  function withdraw() external;\n\n  /**\n   * @notice Withdraws native tokens from the contract to a specified address\n   * @dev Can only be called by the admin\n   * @param recipient The address to send the withdrawn funds to\n   */\n  function withdrawTo(address payable recipient) external;\n\n  /**\n   * @notice Get the Holograph Mint Fee\n   * @dev This fee is charged to mint holographable assets\n   * @return The current holograph mint fee\n   */\n  function getHolographMintFee() external view returns (uint256);\n}\n"
    },
    "src/interface/IContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *  for you contract.\n *\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\ninterface IContractMetadata {\n  /// @dev Returns the metadata URI of the contract.\n  function contractURI() external view returns (string memory);\n\n  /**\n   *  @dev Sets contract URI for the storefront-level metadata of the contract.\n   *       Only module admin can call this function.\n   */\n  function setContractURI(string calldata _uri) external;\n\n  /// @dev Emitted when the contract URI is updated.\n  event ContractURIUpdated(string prevURI, string newURI);\n}\n"
    },
    "src/interface/ICountdownERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CustomERC721SaleDetails} from \"src/struct/CustomERC721SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface ICountdownERC721 {\n  // Access errors\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Only minter can access this function\n  error Access_OnlyMinter();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n  /// @notice Contract is not initialized yet\n  error NotInitialized();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n  /// @notice The countdown has been completed\n  error Purchase_CountdownCompleted();\n\n  // Init errors\n  error CountdownEndMustBeDivisibleByMintTimeCost(uint128 countdownEnd, uint128 mintTimeCost);\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when an nfs is minted\n  /// @param recipient address that the nft was minted to\n  /// @param tokenId id of the minted nft\n  /// @param id id of the minted nft with chain id prefix\n  event NFTMinted(address indexed recipient, uint256 indexed tokenId, uint256 id);\n\n  /// @notice Getter for the contract description\n  function DESCRIPTION() external view returns (string memory);\n\n  /// @notice Getter for the sale start date\n  function START_DATE() external view returns (uint256);\n\n  /// @notice Getter for the initial max supply\n  function INITIAL_MAX_SUPPLY() external view returns (uint256);\n\n  /// @notice Getter for the mint interval\n  function MINT_INTERVAL() external view returns (uint256);\n\n  /// @notice Getter for the minter role\n  function minter() external view returns (address);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  function setSaleConfiguration(uint104 publicSalePrice, uint24 maxSalePurchasePerAddress) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (CustomERC721SaleDetails memory);\n\n  /// @notice Function to return the current max supply\n  function currentTheoricalMaxSupply() external view returns (uint256);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/interface/ICustomERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CustomERC721SaleDetails} from \"src/struct/CustomERC721SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface ICustomERC721 {\n  // Access errors\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Only minter can access this function\n  error Access_OnlyMinter();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n  /// @notice Lazy mint initialization failed\n  error LazyMint_AlreadyInitialized();\n  /// @notice Contract is not initialized yet\n  error NotInitialized();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n  /// @notice The countdown has been completed\n  error Purchase_CountdownCompleted();\n\n  // Init errors\n  error CountdownEndMustBeDivisibleByMintTimeCost(uint128 countdownEnd, uint128 mintTimeCost);\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when an nfs is minted\n  /// @param recipient address that the nft was minted to\n  /// @param tokenId id of the minted nft\n  /// @param id id of the minted nft with chain id prefix\n  event NFTMinted(address indexed recipient, uint256 indexed tokenId, uint256 id);\n\n  /// @notice Getter for the sale start date\n  function START_DATE() external view returns (uint256);\n\n  /// @notice Getter for the initial max supply\n  function INITIAL_MAX_SUPPLY() external view returns (uint256);\n\n  /// @notice Getter for the mint interval\n  function MINT_INTERVAL() external view returns (uint256);\n\n  /// @notice Getter for the minter role\n  function minter() external view returns (address);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  function setSaleConfiguration(uint104 publicSalePrice, uint24 maxSalePurchasePerAddress) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (CustomERC721SaleDetails memory);\n\n  /// @notice Function to return the current max supply\n  function currentTheoricalMaxSupply() external view returns (uint256);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/interface/IDelayedReveal.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `DelayedReveal` is a contract extension for base NFT contracts. It lets you create batches of\n *  'delayed-reveal' NFTs. You can learn more about the usage of delayed reveal NFTs here - https://blog.thirdweb.com/delayed-reveal-nfts\n */\n\ninterface IDelayedReveal {\n  /// @dev Emitted when tokens are revealed.\n  event TokenURIRevealed(uint256 indexed index, string revealedURI);\n\n  /**\n   *  @notice Reveals a batch of delayed reveal NFTs.\n   *\n   *  @param identifier The ID for the batch of delayed-reveal NFTs to reveal.\n   *\n   *  @param key        The key with which the base URI for the relevant batch of NFTs was encrypted.\n   */\n  function reveal(uint256 identifier, bytes calldata key) external returns (string memory revealedURI);\n\n  /**\n   *  @notice Performs XOR encryption/decryption.\n   *\n   *  @param data The data to encrypt. In the case of delayed-reveal NFTs, this is the \"revealed\" state\n   *              base URI of the relevant batch of NFTs.\n   *\n   *  @param key  The key with which to encrypt data\n   */\n  function encryptDecrypt(bytes memory data, bytes calldata key) external pure returns (bytes memory result);\n}\n"
    },
    "src/interface/ILazyMint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `LazyMint` is a contract extension for any base NFT contract. It lets you 'lazy mint' any number of NFTs\n *  at once. Here, 'lazy mint' means defining the metadata for particular tokenIds of your NFT contract, without actually\n *  minting a non-zero balance of NFTs of those tokenIds.\n */\n\ninterface ILazyMint {\n  /// @dev Emitted when tokens are lazy minted.\n  event TokensLazyMinted(uint256 indexed startTokenId, uint256 endTokenId, string baseURI, bytes encryptedBaseURI);\n}\n"
    },
    "src/interface/InitializableInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need of a constructor\n */\ninterface InitializableInterface {\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external returns (bytes4);\n}\n"
    },
    "src/interface/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.13;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n  // NOTE: At the moment we are only implementing the quoteExactOutputSingle function\n  // /// @notice Returns the amount out received for a given exact input swap without executing the swap\n  // /// @param path The path of the swap, i.e. each token pair and the pool fee\n  // /// @param amountIn The amount of the first token to swap\n  // /// @return amountOut The amount of the last token that would be received\n  // /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n  // /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n  // /// @return gasEstimate The estimate of the gas that the swap consumes\n  // function quoteExactInput(\n  //   bytes memory path,\n  //   uint256 amountIn\n  // )\n  //   external\n  //   returns (\n  //     uint256 amountOut,\n  //     uint160[] memory sqrtPriceX96AfterList,\n  //     uint32[] memory initializedTicksCrossedList,\n  //     uint256 gasEstimate\n  //   );\n\n  // struct QuoteExactInputSingleParams {\n  //   address tokenIn;\n  //   address tokenOut;\n  //   uint256 amountIn;\n  //   uint24 fee;\n  //   uint160 sqrtPriceLimitX96;\n  // }\n\n  // /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n  // /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n  // /// tokenIn The token being swapped in\n  // /// tokenOut The token being swapped out\n  // /// fee The fee of the token pool to consider for the pair\n  // /// amountIn The desired input amount\n  // /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  // /// @return amountOut The amount of `tokenOut` that would be received\n  // /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n  // /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n  // /// @return gasEstimate The estimate of the gas that the swap consumes\n  // function quoteExactInputSingle(\n  //   QuoteExactInputSingleParams memory params\n  // )\n  //   external\n  //   returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);\n\n  // /// @notice Returns the amount in required for a given exact output swap without executing the swap\n  // /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n  // /// @param amountOut The amount of the last token to receive\n  // /// @return amountIn The amount of first token required to be paid\n  // /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n  // /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n  // /// @return gasEstimate The estimate of the gas that the swap consumes\n  // function quoteExactOutput(\n  //   bytes memory path,\n  //   uint256 amountOut\n  // )\n  //   external\n  //   returns (\n  //     uint256 amountIn,\n  //     uint160[] memory sqrtPriceX96AfterList,\n  //     uint32[] memory initializedTicksCrossedList,\n  //     uint256 gasEstimate\n  //   );\n\n  struct QuoteExactOutputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    uint24 fee;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n  /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n  /// tokenIn The token being swapped in\n  /// tokenOut The token being swapped out\n  /// fee The fee of the token pool to consider for the pair\n  /// amountOut The desired output amount\n  /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n  /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n  /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n  /// @return gasEstimate The estimate of the gas that the swap consumes\n  function quoteExactOutputSingle(\n    QuoteExactOutputSingleParams memory params\n  ) external returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);\n}\n"
    },
    "src/interface/LayerZeroEndpointInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./LayerZeroUserApplicationConfigInterface.sol\";\n\ninterface LayerZeroEndpointInterface is LayerZeroUserApplicationConfigInterface {\n  // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n  // @param _dstChainId - the destination chain identifier\n  // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n  // @param _payload - a custom bytes payload to send to the destination contract\n  // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n  // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n  // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n  function send(\n    uint16 _dstChainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable _refundAddress,\n    address _zroPaymentAddress,\n    bytes calldata _adapterParams\n  ) external payable;\n\n  // @notice used by the messaging library to publish verified payload\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source contract (as bytes) at the source chain\n  // @param _dstAddress - the address on destination chain\n  // @param _nonce - the unbound message ordering nonce\n  // @param _gasLimit - the gas limit for external contract execution\n  // @param _payload - verified payload to send to the destination contract\n  function receivePayload(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    address _dstAddress,\n    uint64 _nonce,\n    uint256 _gasLimit,\n    bytes calldata _payload\n  ) external;\n\n  // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n  // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n  // @param _srcAddress - the source chain contract address\n  function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n  // @param _dstChainId - the destination chain identifier\n  // @param _userApplication - the user app address on this EVM chain\n  // @param _payload - the custom message to send over LayerZero\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n  function estimateFees(\n    uint16 _dstChainId,\n    address _userApplication,\n    bytes calldata _payload,\n    bool _payInZRO,\n    bytes calldata _adapterParam\n  ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n  // @notice get this Endpoint's immutable source identifier\n  function getChainId() external view returns (uint16);\n\n  // @notice the interface to retry failed message on this Endpoint destination\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  // @param _payload - the payload to be retried\n  function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n  // @notice query if any STORED payload (message blocking) at the endpoint.\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n  // @notice query if the _libraryAddress is valid for sending msgs.\n  // @param _userApplication - the user app address on this EVM chain\n  function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n  // @notice query if the _libraryAddress is valid for receiving msgs.\n  // @param _userApplication - the user app address on this EVM chain\n  function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n  // @notice query if the non-reentrancy guard for send() is on\n  // @return true if the guard is on. false otherwise\n  function isSendingPayload() external view returns (bool);\n\n  // @notice query if the non-reentrancy guard for receive() is on\n  // @return true if the guard is on. false otherwise\n  function isReceivingPayload() external view returns (bool);\n\n  // @notice get the configuration of the LayerZero messaging library of the specified version\n  // @param _version - messaging library version\n  // @param _chainId - the chainId for the pending config change\n  // @param _userApplication - the contract address of the user application\n  // @param _configType - type of configuration. every messaging library has its own convention.\n  function getConfig(\n    uint16 _version,\n    uint16 _chainId,\n    address _userApplication,\n    uint256 _configType\n  ) external view returns (bytes memory);\n\n  // @notice get the send() LayerZero messaging library version\n  // @param _userApplication - the contract address of the user application\n  function getSendVersion(address _userApplication) external view returns (uint16);\n\n  // @notice get the lzReceive() LayerZero messaging library version\n  // @param _userApplication - the contract address of the user application\n  function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "src/interface/LayerZeroModuleInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface LayerZeroModuleInterface {\n  function lzReceive(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    uint64 _nonce,\n    bytes calldata _payload\n  ) external payable;\n\n  function getInterfaces() external view returns (address interfaces);\n\n  function setInterfaces(address interfaces) external;\n\n  function getLZEndpoint() external view returns (address lZEndpoint);\n\n  function setLZEndpoint(address lZEndpoint) external;\n\n  function getOperator() external view returns (address operator);\n\n  function setOperator(address operator) external;\n}\n"
    },
    "src/interface/LayerZeroOverrides.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface LayerZeroOverrides {\n  // @dev defaultAppConfig struct\n  struct ApplicationConfiguration {\n    uint16 inboundProofLibraryVersion;\n    uint64 inboundBlockConfirmations;\n    address relayer;\n    uint16 outboundProofType;\n    uint64 outboundBlockConfirmations;\n    address oracle;\n  }\n\n  struct DstPrice {\n    uint128 dstPriceRatio; // 10^10\n    uint128 dstGasPriceInWei;\n  }\n\n  struct DstConfig {\n    uint128 dstNativeAmtCap;\n    uint64 baseGas;\n    uint64 gasPerByte;\n  }\n\n  // @dev using this to retrieve UltraLightNodeV2 address\n  function defaultSendLibrary() external view returns (address);\n\n  // @dev using this to extract defaultAppConfig\n  function getAppConfig(\n    uint16 destinationChainId,\n    address userApplicationAddress\n  ) external view returns (ApplicationConfiguration memory);\n\n  // @dev using this to extract defaultAppConfig directly from storage slot\n  function defaultAppConfig(\n    uint16 destinationChainId\n  )\n    external\n    view\n    returns (\n      uint16 inboundProofLibraryVersion,\n      uint64 inboundBlockConfirmations,\n      address relayer,\n      uint16 outboundProofType,\n      uint64 outboundBlockConfirmations,\n      address oracle\n    );\n\n  // @dev access the mapping to get base price fee\n  function dstPriceLookup(\n    uint16 destinationChainId\n  ) external view returns (uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n\n  // @dev access the mapping to get base gas and gas per byte\n  function dstConfigLookup(\n    uint16 destinationChainId,\n    uint16 outboundProofType\n  ) external view returns (uint128 dstNativeAmtCap, uint64 baseGas, uint64 gasPerByte);\n\n  // @dev send message to LayerZero Endpoint\n  function send(\n    uint16 _dstChainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable _refundAddress,\n    address _zroPaymentAddress,\n    bytes calldata _adapterParams\n  ) external payable;\n\n  // @dev estimate LayerZero message cost\n  function estimateFees(\n    uint16 _dstChainId,\n    address _userApplication,\n    bytes calldata _payload,\n    bool _payInZRO,\n    bytes calldata _adapterParam\n  ) external view returns (uint256 nativeFee, uint256 zroFee);\n}\n"
    },
    "src/interface/LayerZeroReceiverInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface LayerZeroReceiverInterface {\n  // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "src/interface/LayerZeroUserApplicationConfigInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface LayerZeroUserApplicationConfigInterface {\n  // @notice set the configuration of the LayerZero messaging library of the specified version\n  // @param _version - messaging library version\n  // @param _chainId - the chainId for the pending config change\n  // @param _configType - type of configuration. every messaging library has its own convention.\n  // @param _config - configuration in the bytes. can encode arbitrary content.\n  function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\n\n  // @notice set the send() LayerZero messaging library version to _version\n  // @param _version - new messaging library version\n  function setSendVersion(uint16 _version) external;\n\n  // @notice set the lzReceive() LayerZero messaging library version to _version\n  // @param _version - new messaging library version\n  function setReceiveVersion(uint16 _version) external;\n\n  // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n  // @param _srcChainId - the chainId of the source chain\n  // @param _srcAddress - the contract address of the source contract at the source chain\n  function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "src/interface/LazyMintInitializableInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Initializable Lazy Mint\n * @author https://github.com/holographxyz\n * @notice Allow to initialize a default nextTokenIdToLazyMint\n * @dev This allows to synchronize the nextTokenIdToLazyMint with a custom tokenId management\n */\ninterface LazyMintInitializableInterface {\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function syncLazyMint() external returns (uint256);\n}\n"
    },
    "src/interface/Ownable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Ownable {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function owner() external view returns (address);\n\n  function transferOwnership(address _newOwner) external;\n\n  function isOwner() external view returns (bool);\n\n  function isOwner(address wallet) external view returns (bool);\n}\n"
    },
    "src/library/Base64.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Base64 {\n  bytes private constant base64stdchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  bytes private constant base64urlchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n  function encode(string memory _str) internal pure returns (string memory) {\n    bytes memory _bs = bytes(_str);\n    return encode(_bs);\n  }\n\n  function encode(bytes memory _bs) internal pure returns (string memory) {\n    uint256 rem = _bs.length % 3;\n\n    uint256 res_length = ((_bs.length + 2) / 3) * 4 - ((3 - rem) % 3);\n    bytes memory res = new bytes(res_length);\n\n    uint256 i = 0;\n    uint256 j = 0;\n\n    for (; i + 3 <= _bs.length; i += 3) {\n      (res[j], res[j + 1], res[j + 2], res[j + 3]) = encode3(uint8(_bs[i]), uint8(_bs[i + 1]), uint8(_bs[i + 2]));\n\n      j += 4;\n    }\n\n    if (rem != 0) {\n      uint8 la0 = uint8(_bs[_bs.length - rem]);\n      uint8 la1 = 0;\n\n      if (rem == 2) {\n        la1 = uint8(_bs[_bs.length - 1]);\n      }\n\n      (bytes1 b0, bytes1 b1, bytes1 b2 /* bytes1 b3*/, ) = encode3(la0, la1, 0);\n      res[j] = b0;\n      res[j + 1] = b1;\n      if (rem == 2) {\n        res[j + 2] = b2;\n      }\n    }\n\n    return string(res);\n  }\n\n  function encode3(\n    uint256 a0,\n    uint256 a1,\n    uint256 a2\n  ) private pure returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3) {\n    uint256 n = (a0 << 16) | (a1 << 8) | a2;\n\n    uint256 c0 = (n >> 18) & 63;\n    uint256 c1 = (n >> 12) & 63;\n    uint256 c2 = (n >> 6) & 63;\n    uint256 c3 = (n) & 63;\n\n    b0 = base64urlchars[c0];\n    b1 = base64urlchars[c1];\n    b2 = base64urlchars[c2];\n    b3 = base64urlchars[c3];\n  }\n}\n"
    },
    "src/library/Bytes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Bytes {\n  function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\n    uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\n    return (flag == 1 ? true : false);\n  }\n\n  function setBoolean(uint192 _packedBools, uint192 _boolNumber, bool _value) internal pure returns (uint192) {\n    if (_value) {\n      return _packedBools | (uint192(1) << _boolNumber);\n    } else {\n      return _packedBools & ~(uint192(1) << _boolNumber);\n    }\n  }\n\n  function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n    bytes memory tempBytes;\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        tempBytes := mload(0x40)\n        let lengthmod := and(_length, 31)\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n        for {\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n        mstore(tempBytes, _length)\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      default {\n        tempBytes := mload(0x40)\n        mstore(tempBytes, 0)\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n    return tempBytes;\n  }\n\n  function trim(bytes32 source) internal pure returns (bytes memory) {\n    uint256 temp = uint256(source);\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return slice(abi.encodePacked(source), 32 - length, length);\n  }\n}\n"
    },
    "src/library/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.13;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   *\n   * _Available since v4.2._\n   */\n  function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "src/library/NFTMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {MetadataParams} from \"../struct/MetadataParams.sol\";\n\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n   * with further edits by Uniswap Labs also under MIT license.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        return prod0 / denominator;\n      }\n\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n        // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n      // See https://cs.stackexchange.com/q/138556/92363.\n\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\n      uint256 twos = denominator & (~denominator + 1);\n      assembly {\n        // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n      // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n      // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n      // in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n   *\n   * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n   */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n   */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = sqrt(a);\n      return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 128;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 64;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 32;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 16;\n      }\n      if (value >> 8 > 0) {\n        value >>= 8;\n        result += 8;\n      }\n      if (value >> 4 > 0) {\n        value >>= 4;\n        result += 4;\n      }\n      if (value >> 2 > 0) {\n        value >>= 2;\n        result += 2;\n      }\n      if (value >> 1 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log2(value);\n      return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >= 10 ** 64) {\n        value /= 10 ** 64;\n        result += 64;\n      }\n      if (value >= 10 ** 32) {\n        value /= 10 ** 32;\n        result += 32;\n      }\n      if (value >= 10 ** 16) {\n        value /= 10 ** 16;\n        result += 16;\n      }\n      if (value >= 10 ** 8) {\n        value /= 10 ** 8;\n        result += 8;\n      }\n      if (value >= 10 ** 4) {\n        value /= 10 ** 4;\n        result += 4;\n      }\n      if (value >= 10 ** 2) {\n        value /= 10 ** 2;\n        result += 2;\n      }\n      if (value >= 10 ** 1) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log10(value);\n      return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   *\n   * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n   */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 16;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 8;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 4;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 2;\n      }\n      if (value >> 8 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log256(value);\n      return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n    }\n  }\n}\n\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      uint256 length = Math.log10(value) + 1;\n      string memory buffer = new string(length);\n      uint256 ptr;\n      /// @solidity memory-safe-assembly\n      assembly {\n        ptr := add(buffer, add(32, length))\n      }\n      while (true) {\n        ptr--;\n        /// @solidity memory-safe-assembly\n        assembly {\n          mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n        }\n        value /= 10;\n        if (value == 0) break;\n      }\n      return buffer;\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      return toHexString(value, Math.log256(value) + 1);\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n\nlibrary Base64 {\n  /**\n   * @dev Base64 Encoding/Decoding Table\n   */\n  string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /**\n   * @dev Converts a `bytes` to its Bytes64 `string` representation.\n   */\n  function encode(bytes memory data) internal pure returns (string memory) {\n    /**\n     * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n     * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n     */\n    if (data.length == 0) return \"\";\n\n    // Loads the table into memory\n    string memory table = _TABLE;\n\n    // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n    // and split into 4 numbers of 6 bits.\n    // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n    // - `data.length + 2`  -> Round up\n    // - `/ 3`              -> Number of 3-bytes chunks\n    // - `4 *`              -> 4 characters for each chunk\n    string memory result = new string(4 * ((data.length + 2) / 3));\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Prepare the lookup table (skip the first \"length\" byte)\n      let tablePtr := add(table, 1)\n\n      // Prepare result pointer, jump over length\n      let resultPtr := add(result, 32)\n\n      // Run over the input, 3 bytes at a time\n      for {\n        let dataPtr := data\n        let endPtr := add(data, mload(data))\n      } lt(dataPtr, endPtr) {\n\n      } {\n        // Advance 3 bytes\n        dataPtr := add(dataPtr, 3)\n        let input := mload(dataPtr)\n\n        // To write each character, shift the 3 bytes (18 bits) chunk\n        // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n        // and apply logical AND with 0x3F which is the number of\n        // the previous character in the ASCII table prior to the Base64 Table\n        // The result is then added to the table to get the character to write,\n        // and finally write it in the result pointer but with a left shift\n        // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n      }\n\n      // When data `bytes` is not exactly 3 bytes long\n      // it is padded with `=` characters at the end\n      switch mod(mload(data), 3)\n      case 1 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n        mstore8(sub(resultPtr, 2), 0x3d)\n      }\n      case 2 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n      }\n    }\n\n    return result;\n  }\n}\n\n/// NFT metadata library for rendering metadata associated with editions\nlibrary NFTMetadataRenderer {\n  /// Function to create the metadata for an edition\n  /// @param params MetadataParams struct containing all metadata information\n  function createMetadataEdition(MetadataParams memory params) internal pure returns (string memory) {\n    bytes memory json = createMetadataJSON(params);\n    return encodeMetadataJSON(json);\n  }\n\n  function encodeContractURIJSON(\n    string memory name,\n    string memory description,\n    string memory imageURI,\n    string memory animationURI,\n    uint256 royaltyBPS,\n    address royaltyRecipient\n  ) internal pure returns (string memory) {\n    bytes memory imageSpace = bytes(\"\");\n    if (bytes(imageURI).length > 0) {\n      imageSpace = abi.encodePacked('\", \"image\": \"', imageURI);\n    }\n    bytes memory animationSpace = bytes(\"\");\n    if (bytes(animationURI).length > 0) {\n      animationSpace = abi.encodePacked('\", \"animation_url\": \"', animationURI);\n    }\n\n    return\n      string(\n        encodeMetadataJSON(\n          abi.encodePacked(\n            '{\"name\": \"',\n            name,\n            '\", \"description\": \"',\n            description,\n            // this is for opensea since they don't respect ERC2981 right now\n            '\", \"seller_fee_basis_points\": ',\n            Strings.toString(royaltyBPS),\n            ', \"fee_recipient\": \"',\n            Strings.toHexString(uint256(uint160(royaltyRecipient)), 20),\n            imageSpace,\n            animationSpace,\n            '\"}'\n          )\n        )\n      );\n  }\n\n  /// Function to create the metadata json string for the nft edition\n  /// @param params MetadataParams struct containing all metadata information\n  function createMetadataJSON(MetadataParams memory params) internal pure returns (bytes memory) {\n    bytes memory editionSizeText;\n    string memory tokenOfEditionString;\n    {\n      if (params.editionSize > 0) {\n        editionSizeText = abi.encodePacked(\"/\", Strings.toString(params.editionSize));\n      }\n\n      tokenOfEditionString = Strings.toString(params.tokenOfEdition);\n    }\n\n    return\n      abi.encodePacked(\n        abi.encodePacked(\n          '{\"name\": \"',\n          params.name,\n          \" \",\n          tokenOfEditionString,\n          editionSizeText,\n          '\", \"description\": \"',\n          params.description,\n          '\", \"external_url\": \"',\n          params.externalUrl,\n          '\", \"image\": \"',\n          params.imageURI,\n          '\", \"encrypted_media_url\": \"',\n          params.encryptedMediaUrl\n        ),\n        abi.encodePacked(\n          '\", \"decryption_key\": \"',\n          params.decryptionKey,\n          '\", \"hash\": \"',\n          params.hash,\n          '\", \"decrypted_media_url\": \"',\n          params.decryptedMediaUrl,\n          '\", \"animation_url\": \"',\n          params.animationURI,\n          '\", \"properties\": {\"number\": ',\n          tokenOfEditionString,\n          ', \"name\": \"',\n          params.name,\n          '\"}}'\n        )\n      );\n  }\n\n  /// Encodes the argument json bytes into base64-data uri format\n  /// @param json Raw json to base64 and turn into a data-uri\n  function encodeMetadataJSON(bytes memory json) internal pure returns (string memory) {\n    return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(json)));\n  }\n\n  /// Generates edition metadata from storage information as base64-json blob\n  /// Combines the media data and metadata\n  /// @param imageUrl URL of image to render for edition\n  /// @param animationUrl URL of animation to render for edition\n  function tokenMediaData(string memory imageUrl, string memory animationUrl) internal pure returns (string memory) {\n    bool hasImage = bytes(imageUrl).length > 0;\n    bool hasAnimation = bytes(animationUrl).length > 0;\n    if (hasImage && hasAnimation) {\n      return string(abi.encodePacked('image\": \"', imageUrl, '\", \"animation_url\": \"', animationUrl, '\", \"'));\n    }\n    if (hasImage) {\n      return string(abi.encodePacked('image\": \"', imageUrl, '\", \"'));\n    }\n    if (hasAnimation) {\n      return string(abi.encodePacked('animation_url\": \"', animationUrl, '\", \"'));\n    }\n\n    return \"\";\n  }\n\n  /// @dev Generates a metadata string from provided URLs and keys\n  /// This function checks for the presence of media-related information and formats them into a JSON-like string.\n  /// @param params MetadataParams struct containing all metadata information\n  /// @return A string that concatenates all provided and non-empty fields into a JSON-like format for NFT metadata.\n  function tokenMediaData(MetadataParams memory params) internal pure returns (string memory) {\n    // Initialize boolean variables to check if each parameter contains data.\n    bool hasImage = bytes(params.imageURI).length > 0;\n    bool hasAnimation = bytes(params.animationURI).length > 0;\n    bool hasExternal = bytes(params.externalUrl).length > 0;\n    bool hasEncryptedMedia = bytes(params.encryptedMediaUrl).length > 0;\n    bool hasDecryptionKey = bytes(params.decryptionKey).length > 0;\n    bool hasHash = bytes(params.hash).length > 0;\n    bool hasDecryptedMedia = bytes(params.decryptedMediaUrl).length > 0;\n\n    // Check if all parameters are provided and concatenate them into a JSON-like string.\n    if (\n      hasImage && hasAnimation && hasExternal && hasEncryptedMedia && hasDecryptionKey && hasHash && hasDecryptedMedia\n    ) {\n      return\n        string(\n          abi.encodePacked(\n            '\"image\": \"',\n            params.imageURI,\n            '\", ',\n            '\"animation_url\": \"',\n            params.animationURI,\n            '\", ',\n            '\"external_url\": \"',\n            params.externalUrl,\n            '\", ',\n            '\"encrypted_media_url\": \"',\n            params.encryptedMediaUrl,\n            '\", ',\n            '\"decryption_key\": \"',\n            params.decryptionKey,\n            '\", ',\n            '\"hash\": \"',\n            params.hash,\n            '\", ',\n            '\"decrypted_media_url\": \"',\n            params.decryptedMediaUrl,\n            '\", '\n          )\n        );\n    }\n\n    // Individual checks for each field, appending them to the result if they contain data.\n    if (hasImage) {\n      return string(abi.encodePacked('\"image\": \"', params.imageURI, '\", '));\n    }\n    if (hasAnimation) {\n      return string(abi.encodePacked('\"animation_url\": \"', params.animationURI, '\", '));\n    }\n    if (hasExternal) {\n      return string(abi.encodePacked('\"external_url\": \"', params.externalUrl, '\", '));\n    }\n    if (hasEncryptedMedia) {\n      return string(abi.encodePacked('\"encrypted_media_url\": \"', params.encryptedMediaUrl, '\", '));\n    }\n    if (hasDecryptionKey) {\n      return string(abi.encodePacked('\"decryption_key\": \"', params.decryptionKey, '\", '));\n    }\n    if (hasHash) {\n      return string(abi.encodePacked('\"hash\": \"', params.hash, '\", '));\n    }\n    if (hasDecryptedMedia) {\n      return string(abi.encodePacked('\"decrypted_media_url\": \"', params.decryptedMediaUrl, '\", '));\n    }\n\n    // Return an empty string if none of the fields are provided.\n    return \"\";\n  }\n}\n"
    },
    "src/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Strings {\n  function toHexString(address account) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(account)));\n  }\n\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = bytes16(\"0123456789abcdef\")[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint256 i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = char(hi);\n      s[2 * i + 1] = char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) {\n      return bytes1(uint8(b) + 0x30);\n    } else {\n      return bytes1(uint8(b) + 0x57);\n    }\n  }\n\n  function uint2str(uint256 _i) internal pure returns (string memory _uint256AsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint256 j = _i;\n    uint256 len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint256 k = len;\n    while (_i != 0) {\n      k = k - 1;\n      uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n      bytes1 b1 = bytes1(temp);\n      bstr[k] = b1;\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n\n  function toString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n}\n"
    },
    "src/mock/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/EIP712.sol\";\nimport \"../abstract/NonReentrant.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Burnable.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/ERC20Metadata.sol\";\nimport \"../interface/ERC20Permit.sol\";\nimport \"../interface/ERC20Receiver.sol\";\nimport \"../interface/ERC20Safer.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC165.sol\";\n\nimport \"../library/ECDSA.sol\";\n\n/**\n * @title Mock ERC20 Token\n * @author Holograph Foundation\n * @notice Used for imitating the likes of WETH and WMATIC tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract ERC20Mock is\n  ERC165,\n  ERC20,\n  ERC20Burnable,\n  ERC20Metadata,\n  ERC20Receiver,\n  ERC20Safer,\n  ERC20Permit,\n  NonReentrant,\n  EIP712\n{\n  bool private _works;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of all supported ERC165 interfaces.\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => uint256) private _nonces;\n\n  /**\n   * @dev Constructor does not accept any parameters.\n   */\n  constructor(\n    string memory contractName,\n    string memory contractSymbol,\n    uint8 contractDecimals,\n    string memory domainSeperator,\n    string memory domainVersion\n  ) {\n    _works = true;\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n\n    // ERC165\n    _supportedInterfaces[ERC165.supportsInterface.selector] = true;\n\n    // ERC20\n    _supportedInterfaces[ERC20.allowance.selector] = true;\n    _supportedInterfaces[ERC20.approve.selector] = true;\n    _supportedInterfaces[ERC20.balanceOf.selector] = true;\n    _supportedInterfaces[ERC20.totalSupply.selector] = true;\n    _supportedInterfaces[ERC20.transfer.selector] = true;\n    _supportedInterfaces[ERC20.transferFrom.selector] = true;\n    _supportedInterfaces[\n      ERC20.allowance.selector ^\n        ERC20.approve.selector ^\n        ERC20.balanceOf.selector ^\n        ERC20.totalSupply.selector ^\n        ERC20.transfer.selector ^\n        ERC20.transferFrom.selector\n    ] = true;\n\n    // ERC20Metadata\n    _supportedInterfaces[ERC20Metadata.name.selector] = true;\n    _supportedInterfaces[ERC20Metadata.symbol.selector] = true;\n    _supportedInterfaces[ERC20Metadata.decimals.selector] = true;\n    _supportedInterfaces[\n      ERC20Metadata.name.selector ^ ERC20Metadata.symbol.selector ^ ERC20Metadata.decimals.selector\n    ] = true;\n\n    // ERC20Burnable\n    _supportedInterfaces[ERC20Burnable.burn.selector] = true;\n    _supportedInterfaces[ERC20Burnable.burnFrom.selector] = true;\n    _supportedInterfaces[ERC20Burnable.burn.selector ^ ERC20Burnable.burnFrom.selector] = true;\n\n    // ERC20Safer\n    // bytes4(keccak256(abi.encodePacked('safeTransfer(address,uint256)'))) == 0x423f6cef\n    _supportedInterfaces[0x423f6cef] = true;\n    // bytes4(keccak256(abi.encodePacked('safeTransfer(address,uint256,bytes)'))) == 0xeb795549\n    _supportedInterfaces[0xeb795549] = true;\n    // bytes4(keccak256(abi.encodePacked('safeTransferFrom(address,address,uint256)'))) == 0x42842e0e\n    _supportedInterfaces[0x42842e0e] = true;\n    // bytes4(keccak256(abi.encodePacked('safeTransferFrom(address,address,uint256,bytes)'))) == 0xb88d4fde\n    _supportedInterfaces[0xb88d4fde] = true;\n    _supportedInterfaces[bytes4(0x423f6cef) ^ bytes4(0xeb795549) ^ bytes4(0x42842e0e) ^ bytes4(0xb88d4fde)] = true;\n\n    // ERC20Receiver\n    _supportedInterfaces[ERC20Receiver.onERC20Received.selector] = true;\n\n    // ERC20Permit\n    _supportedInterfaces[ERC20Permit.permit.selector] = true;\n    _supportedInterfaces[ERC20Permit.nonces.selector] = true;\n    _supportedInterfaces[ERC20Permit.DOMAIN_SEPARATOR.selector] = true;\n    _supportedInterfaces[\n      ERC20Permit.permit.selector ^ ERC20Permit.nonces.selector ^ ERC20Permit.DOMAIN_SEPARATOR.selector\n    ] = true;\n    _eip712_init(domainSeperator, domainVersion);\n  }\n\n  function toggleWorks(bool active) external {\n    _works = active;\n  }\n\n  function transferTokens(address payable token, address to, uint256 amount) external {\n    ERC20(token).transfer(to, amount);\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  function allowance(address account, address spender) public view returns (uint256) {\n    return _allowances[account][spender];\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function nonces(address account) public view returns (uint256) {\n    return _nonces[account];\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function burn(uint256 amount) public {\n    _burn(msg.sender, amount);\n  }\n\n  function burnFrom(address account, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[account][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n    unchecked {\n      _allowances[account][msg.sender] = currentAllowance - amount;\n    }\n    _burn(account, amount);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance - subtractedValue;\n    }\n    _approve(msg.sender, spender, newAllowance);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance + addedValue;\n    }\n    unchecked {\n      require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n    }\n    _approve(msg.sender, spender, newAllowance);\n    return true;\n  }\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function onERC20Received(\n    address account,\n    address /* sender*/,\n    uint256 amount,\n    bytes calldata /* data*/\n  ) public returns (bytes4) {\n    assembly {\n      // used to drop \"change function to view\" compiler warning\n      sstore(0x17fb676f92438402d8ef92193dd096c59ee1f4ba1bb57f67f3e6d2eef8aeed5e, amount)\n    }\n    if (_works) {\n      require(_isContract(account), \"ERC20: operator not contract\");\n      try ERC20(account).balanceOf(address(this)) returns (uint256 balance) {\n        require(balance >= amount, \"ERC20: balance check failed\");\n      } catch {\n        revert(\"ERC20: failed getting balance\");\n      }\n      return ERC20Receiver.onERC20Received.selector;\n    } else {\n      return 0x00000000;\n    }\n  }\n\n  function permit(\n    address account,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    //  == 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\n    bytes32 structHash = keccak256(\n      abi.encode(\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n        account,\n        spender,\n        amount,\n        _useNonce(account),\n        deadline\n      )\n    );\n    bytes32 hash = _hashTypedDataV4(structHash);\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == account, \"ERC20: invalid signature\");\n    _approve(account, spender, amount);\n  }\n\n  function safeTransfer(address recipient, uint256 amount) public returns (bool) {\n    return safeTransfer(recipient, amount, \"\");\n  }\n\n  function safeTransfer(address recipient, uint256 amount, bytes memory data) public returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    return true;\n  }\n\n  function safeTransferFrom(address account, address recipient, uint256 amount) public returns (bool) {\n    return safeTransferFrom(account, recipient, amount, \"\");\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      uint256 currentAllowance = _allowances[account][msg.sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[account][msg.sender] = currentAllowance - amount;\n      }\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    return true;\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function transferFrom(address account, address recipient, uint256 amount) public returns (bool) {\n    if (account != msg.sender) {\n      uint256 currentAllowance = _allowances[account][msg.sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[account][msg.sender] = currentAllowance - amount;\n      }\n    }\n    _transfer(account, recipient, amount);\n    return true;\n  }\n\n  function _approve(address account, address spender, uint256 amount) internal {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(spender != address(0), \"ERC20: spender is zero address\");\n    _allowances[account][spender] = amount;\n    emit Approval(account, spender, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    require(account != address(0), \"ERC20: account is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _checkOnERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) internal nonReentrant returns (bool) {\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(0x01ffc9a7) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(msg.sender, account, amount, data) returns (bytes4 retval) {\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @notice Mints tokens.\n   * @dev Mint a specific amount of tokens to a specific address.\n   * @param to Address to mint to.\n   * @param amount Amount of tokens to mint.\n   */\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: minting to burn address\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _transfer(address account, address recipient, uint256 amount) internal {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(recipient != address(0), \"ERC20: recipient is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _balances[recipient] += amount;\n    emit Transfer(account, recipient, amount);\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address account) internal returns (uint256 current) {\n    current = _nonces[account];\n    _nonces[account]++;\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n}\n"
    },
    "src/mock/LZEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/LayerZeroReceiverInterface.sol\";\nimport \"../interface/LayerZeroEndpointInterface.sol\";\n\n/**\nmocking multi endpoint connection.\n- send() will short circuit to lzReceive() directly\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\n*/\ncontract LZEndpointMock is LayerZeroEndpointInterface {\n  mapping(address => address) public lzEndpointLookup;\n\n  uint16 public mockChainId;\n  address payable public mockOracle;\n  address payable public mockRelayer;\n  uint256 public mockBlockConfirmations;\n  uint16 public mockLibraryVersion;\n  uint256 public mockStaticNativeFee;\n  uint16 public mockLayerZeroVersion;\n  uint256 public nativeFee;\n  uint256 public zroFee;\n  bool nextMsgBLocked;\n\n  struct StoredPayload {\n    uint64 payloadLength;\n    address dstAddress;\n    bytes32 payloadHash;\n  }\n\n  struct QueuedPayload {\n    address dstAddress;\n    uint64 nonce;\n    bytes payload;\n  }\n\n  // inboundNonce = [srcChainId][srcAddress].\n  mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n  // outboundNonce = [dstChainId][srcAddress].\n  mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n  // storedPayload = [srcChainId][srcAddress]\n  mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n  // msgToDeliver = [srcChainId][srcAddress]\n  mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\n\n  event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n  event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n  event PayloadStored(\n    uint16 srcChainId,\n    bytes srcAddress,\n    address dstAddress,\n    uint64 nonce,\n    bytes payload,\n    bytes reason\n  );\n\n  constructor(uint16 _chainId) {\n    mockStaticNativeFee = 42;\n    mockLayerZeroVersion = 1;\n    mockChainId = _chainId;\n  }\n\n  // mock helper to set the value returned by `estimateNativeFees`\n  function setEstimatedFees(uint256 _nativeFee, uint256 _zroFee) public {\n    nativeFee = _nativeFee;\n    zroFee = _zroFee;\n  }\n\n  function getChainId() external view override returns (uint16) {\n    return mockChainId;\n  }\n\n  function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\n    lzEndpointLookup[destAddr] = lzEndpointAddr;\n  }\n\n  function send(\n    uint16 _chainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable, // _refundAddress\n    address, // _zroPaymentAddress\n    bytes memory _adapterParams\n  ) external payable override {\n    address destAddr = packedBytesToAddr(_destination);\n    address lzEndpoint = lzEndpointLookup[destAddr];\n\n    require(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\n\n    uint64 nonce;\n    {\n      nonce = ++outboundNonce[_chainId][msg.sender];\n    }\n\n    // Mock the relayer paying the dstNativeAddr the amount of extra native token\n    {\n      uint256 extraGas;\n      uint256 dstNative;\n      address dstNativeAddr;\n      assembly {\n        extraGas := mload(add(_adapterParams, 34))\n        dstNative := mload(add(_adapterParams, 66))\n        dstNativeAddr := mload(add(_adapterParams, 86))\n      }\n\n      // to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\n    }\n\n    bytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\n\n    // not using the extra gas parameter because this is a single tx call, not split between different chains\n    // LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\n    LZEndpointMock(lzEndpoint).receivePayload(\n      mockChainId,\n      bytesSourceUserApplicationAddr,\n      destAddr,\n      nonce,\n      0,\n      _payload\n    );\n  }\n\n  function receivePayload(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    address _dstAddress,\n    uint64 _nonce,\n    uint256 /*_gasLimit*/,\n    bytes calldata _payload\n  ) external override {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\n    // assert and increment the nonce. no message shuffling\n    require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n    // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\n    if (sp.payloadHash != bytes32(0)) {\n      QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n      QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\n\n      // warning, might run into gas issues trying to forward through a bunch of queued msgs\n      // shift all the msgs over so we can treat this like a fifo via array.pop()\n      if (msgs.length > 0) {\n        // extend the array\n        msgs.push(newMsg);\n\n        // shift all the indexes up for pop()\n        for (uint256 i = 0; i < msgs.length - 1; i++) {\n          msgs[i + 1] = msgs[i];\n        }\n\n        // put the newMsg at the bottom of the stack\n        msgs[0] = newMsg;\n      } else {\n        msgs.push(newMsg);\n      }\n    } else if (nextMsgBLocked) {\n      storedPayload[_srcChainId][_srcAddress] = StoredPayload(\n        uint64(_payload.length),\n        _dstAddress,\n        keccak256(_payload)\n      );\n      emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\"\"));\n      // ensure the next msgs that go through are no longer blocked\n      nextMsgBLocked = false;\n    } else {\n      // we ignore the gas limit because this call is made in one tx due to being \"same chain\"\n      // LayerZeroReceiverInterface(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n      LayerZeroReceiverInterface(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n    }\n  }\n\n  // used to simulate messages received get stored as a payload\n  function blockNextMsg() external {\n    nextMsgBLocked = true;\n  }\n\n  function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint256) {\n    return msgsToDeliver[_srcChainId][_srcAddress].length;\n  }\n\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n  // @param _dstChainId - the destination chain identifier\n  // @param _userApplication - the user app address on this EVM chain\n  // @param _payload - the custom message to send over LayerZero\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n  function estimateFees(\n    uint16,\n    address,\n    bytes memory,\n    bool,\n    bytes memory\n  ) external view override returns (uint256 _nativeFee, uint256 _zroFee) {\n    _nativeFee = nativeFee;\n    _zroFee = zroFee;\n  }\n\n  // give 20 bytes, return the decoded address\n  function packedBytesToAddr(bytes calldata _b) public pure returns (address) {\n    address addr;\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\n      addr := mload(sub(ptr, 10))\n    }\n    return addr;\n  }\n\n  // given an address, return the 20 bytes\n  function addrToPackedBytes(address _a) public pure returns (bytes memory) {\n    bytes memory data = abi.encodePacked(_a);\n    return data;\n  }\n\n  function setConfig(\n    uint16 /*_version*/,\n    uint16 /*_chainId*/,\n    uint256 /*_configType*/,\n    bytes memory /*_config*/\n  ) external override {}\n\n  function getConfig(\n    uint16 /*_version*/,\n    uint16 /*_chainId*/,\n    address /*_ua*/,\n    uint256 /*_configType*/\n  ) external pure override returns (bytes memory) {\n    return \"\";\n  }\n\n  function setSendVersion(uint16 /*version*/) external override {}\n\n  function setReceiveVersion(uint16 /*version*/) external override {}\n\n  function getSendVersion(address /*_userApplication*/) external pure override returns (uint16) {\n    return 1;\n  }\n\n  function getReceiveVersion(address /*_userApplication*/) external pure override returns (uint16) {\n    return 1;\n  }\n\n  function getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\n    return inboundNonce[_chainID][_srcAddress];\n  }\n\n  function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\n    return outboundNonce[_chainID][_srcAddress];\n  }\n\n  // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\n  function _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\n    QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n\n    // warning, might run into gas issues trying to forward through a bunch of queued msgs\n    while (msgs.length > 0) {\n      QueuedPayload memory payload = msgs[msgs.length - 1];\n      LayerZeroReceiverInterface(payload.dstAddress).lzReceive(\n        _srcChainId,\n        _srcAddress,\n        payload.nonce,\n        payload.payload\n      );\n      msgs.pop();\n    }\n  }\n\n  function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n    // revert if no messages are cached. safeguard malicious UA behaviour\n    require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n    require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n    // empty the storedPayload\n    sp.payloadLength = 0;\n    sp.dstAddress = address(0);\n    sp.payloadHash = bytes32(0);\n\n    emit UaForceResumeReceive(_srcChainId, _srcAddress);\n\n    // resume the receiving of msgs after we force clear the \"stuck\" msg\n    _clearMsgQue(_srcChainId, _srcAddress);\n  }\n\n  function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n    require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n    require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\n\n    address dstAddress = sp.dstAddress;\n    // empty the storedPayload\n    sp.payloadLength = 0;\n    sp.dstAddress = address(0);\n    sp.payloadHash = bytes32(0);\n\n    uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n    LayerZeroReceiverInterface(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n    emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n  }\n\n  function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n    return sp.payloadHash != bytes32(0);\n  }\n\n  function isSendingPayload() external pure override returns (bool) {\n    return false;\n  }\n\n  function isReceivingPayload() external pure override returns (bool) {\n    return false;\n  }\n\n  function getSendLibraryAddress(address) external view override returns (address) {\n    return address(this);\n  }\n\n  function getReceiveLibraryAddress(address) external view override returns (address) {\n    return address(this);\n  }\n}\n"
    },
    "src/mock/Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\n\ncontract Mock is Initializable, Owner {\n  constructor() {}\n\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"MOCK: already initialized\");\n    bytes32 arbitraryData = abi.decode(initPayload, (bytes32));\n    bool shouldFail = false;\n    assembly {\n      // we leave slot 0 available for fallback calls\n      sstore(0x01, arbitraryData)\n      switch arbitraryData\n      case 0 {\n        shouldFail := 0x01\n      }\n      sstore(_ownerSlot, caller())\n    }\n    _setInitialized();\n    if (shouldFail) {\n      return bytes4(0x12345678);\n    } else {\n      return InitializableInterface.init.selector;\n    }\n  }\n\n  function getStorage(uint256 slot) public view returns (bytes32 data) {\n    assembly {\n      data := sload(slot)\n    }\n  }\n\n  function setStorage(uint256 slot, bytes32 data) public {\n    assembly {\n      sstore(slot, data)\n    }\n  }\n\n  function mockCall(address target, bytes calldata data) public payable {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function mockStaticCall(address target, bytes calldata data) public view returns (bytes memory) {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := staticcall(gas(), target, 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function mockDelegateCall(address target, bytes calldata data) public returns (bytes memory) {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := delegatecall(gas(), target, 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := call(gas(), sload(0), callvalue(), 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/mock/MockERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/ERC721.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC721TokenReceiver.sol\";\n\ncontract MockERC721Receiver is ERC165, ERC721TokenReceiver {\n  bool private _works;\n\n  constructor() {\n    _works = true;\n  }\n\n  function toggleWorks(bool active) external {\n    _works = active;\n  }\n\n  function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n    if (interfaceID == 0x01ffc9a7 || interfaceID == 0x150b7a02) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function onERC721Received(\n    address /*operator*/,\n    address /*from*/,\n    uint256 /*tokenId*/,\n    bytes calldata /*data*/\n  ) external view returns (bytes4) {\n    if (_works) {\n      return 0x150b7a02;\n    } else {\n      return 0x00000000;\n    }\n  }\n\n  function transferNFT(address payable token, uint256 tokenId, address to) external {\n    ERC721(token).safeTransferFrom(address(this), to, tokenId);\n  }\n}\n"
    },
    "src/mock/MockExternalCall.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ncontract MockExternalCall {\n  function callExternalFn(address contractAddress, bytes calldata encodedSignature) public {\n    (bool success, ) = address(contractAddress).call(encodedSignature);\n    require(success, \"Failed\");\n  }\n}\n"
    },
    "src/mock/MockHolographChild.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../Holograph.sol\";\n\ncontract MockHolographChild is Holograph {\n  constructor() {}\n\n  function emptyFunction() external pure returns (string memory) {\n    return \"on purpose to remove verification conflict\";\n  }\n}\n"
    },
    "src/mock/MockHolographGenesisChild.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../HolographGenesis.sol\";\n\ncontract MockHolographGenesisChild is HolographGenesis {\n  constructor() {}\n\n  function approveDeployerMock(address newDeployer, bool approve) external onlyDeployer {\n    // TODO: Implement mock signature recovery\n    bytes memory sig1 = new bytes(0);\n    bytes memory sig2 = new bytes(0);\n\n    return this.approveDeployer(1, newDeployer, approve, sig1, sig2);\n  }\n\n  function isApprovedDeployerMock(address deployer) external view returns (bool) {\n    return this.isApprovedDeployer(deployer);\n  }\n}\n"
    },
    "src/mock/MockLZEndpoint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\n\nimport \"../interface/HolographOperatorInterface.sol\";\nimport \"../interface/LayerZeroOverrides.sol\";\n\ncontract MockLZEndpoint is Admin {\n  event LzEvent(uint16 _dstChainId, bytes _destination, bytes _payload);\n\n  constructor() {\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n  }\n\n  function send(\n    uint16 _dstChainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable /* _refundAddress*/,\n    address /* _zroPaymentAddress*/,\n    bytes calldata /* _adapterParams*/\n  ) external payable {\n    // we really don't care about anything and just emit an event that we can leverage for multichain replication\n    emit LzEvent(_dstChainId, _destination, _payload);\n  }\n\n  function estimateFees(\n    uint16,\n    address,\n    bytes calldata,\n    bool,\n    bytes calldata\n  ) external pure returns (uint256 nativeFee, uint256 zroFee) {\n    nativeFee = 10 ** 15;\n    zroFee = 10 ** 7;\n  }\n\n  function defaultSendLibrary() external view returns (address) {\n    return address(this);\n  }\n\n  function getAppConfig(uint16, address) external view returns (LayerZeroOverrides.ApplicationConfiguration memory) {\n    return LayerZeroOverrides.ApplicationConfiguration(0, 0, address(this), 0, 0, address(this));\n  }\n\n  function dstPriceLookup(uint16) external pure returns (uint128 dstPriceRatio, uint128 dstGasPriceInWei) {\n    dstPriceRatio = 10 ** 10;\n    dstGasPriceInWei = 1000000000;\n  }\n\n  function dstConfigLookup(\n    uint16,\n    uint16\n  ) external pure returns (uint128 dstNativeAmtCap, uint64 baseGas, uint64 gasPerByte) {\n    dstNativeAmtCap = 10 ** 18;\n    baseGas = 50000;\n    gasPerByte = 25;\n  }\n\n  function crossChainMessage(address target, uint256 gasLimit, bytes calldata payload) external {\n    HolographOperatorInterface(target).crossChainMessage{gas: gasLimit}(payload);\n  }\n}\n"
    },
    "src/module/LayerZeroModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../enum/ChainIdType.sol\";\n\nimport \"../interface/CrossChainMessageInterface.sol\";\nimport \"../interface/HolographOperatorInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/LayerZeroModuleInterface.sol\";\nimport \"../interface/LayerZeroOverrides.sol\";\n\nimport \"../struct/GasParameters.sol\";\n\nimport \"./OVM_GasPriceOracle.sol\";\n\n/**\n * @title Holograph LayerZero Module\n * @author https://github.com/holographxyz\n * @notice Holograph module for enabling LayerZero cross-chain messaging\n * @dev This contract abstracts all of the LayerZero specific logic into an isolated module\n */\ncontract LayerZeroModule is Admin, Initializable, CrossChainMessageInterface, LayerZeroModuleInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.lZEndpoint')) - 1)\n   */\n  bytes32 constant _lZEndpointSlot = 0x56825e447adf54cdde5f04815fcf9b1dd26ef9d5c053625147c18b7c13091686;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.gasParameters')) - 1)\n   */\n  bytes32 constant _gasParametersSlot = 0x15eee82a0af3c04e4b65c3842105c973a6b0fb2a68728bf035809e13b38ce8cf;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.gasParameters')) - 1)\n   */\n  bytes32 constant _optimismGasPriceOracleSlot = 0x46043c284a96474ab4a54c741ea0d0fce54e98eea878b99d4b85808fa6f71a5f;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (\n      address bridge,\n      address interfaces,\n      address operator,\n      address optimismGasPriceOracle,\n      uint32[] memory chainIds,\n      GasParameters[] memory gasParameters\n    ) = abi.decode(initPayload, (address, address, address, address, uint32[], GasParameters[]));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_optimismGasPriceOracleSlot, optimismGasPriceOracle)\n    }\n    require(chainIds.length == gasParameters.length, \"HOLOGRAPH: wrong array lengths\");\n    for (uint256 i = 0; i < chainIds.length; i++) {\n      _setGasParameters(chainIds[i], gasParameters[i]);\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Receive cross-chain message from LayerZero\n   * @dev This function only allows calls from the configured LayerZero endpoint address\n   */\n  function lzReceive(\n    uint16 /* _srcChainId*/,\n    bytes calldata _srcAddress,\n    uint64 /* _nonce*/,\n    bytes calldata _payload\n  ) external payable {\n    assembly {\n      /**\n       * @dev check if msg.sender is LayerZero Endpoint\n       */\n      switch eq(sload(_lZEndpointSlot), caller())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: LZ only endpoint\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001b484f4c4f47524150483a204c5a206f6e6c7920656e64706f696e7400)\n        mstore(0xe0, 0x0000000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n      let ptr := mload(0x40)\n      calldatacopy(add(ptr, 0x0c), _srcAddress.offset, _srcAddress.length)\n      /**\n       * @dev check if LZ from address is same as address(this)\n       */\n      switch eq(mload(ptr), address())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: unauthorized sender\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001e484f4c4f47524150483a20756e617574686f72697a65642073656e64)\n        mstore(0xe0, 0x6572000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n    }\n    /**\n     * @dev if validation has passed, submit payload to Holograph Operator for converting into an operator job\n     */\n    _operator().crossChainMessage(_payload);\n  }\n\n  /**\n   * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n   */\n  function send(\n    uint256 /* gasLimit*/,\n    uint256 /* gasPrice*/,\n    uint32 toChain,\n    address msgSender,\n    uint256 msgValue,\n    bytes calldata crossChainPayload\n  ) external payable {\n    require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n    LayerZeroOverrides lZEndpoint;\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n    GasParameters memory gasParameters = _gasParameters(toChain);\n    // need to recalculate the gas amounts for LZ to deliver message\n    lZEndpoint.send{value: msgValue}(\n      uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n      abi.encodePacked(address(this), address(this)),\n      crossChainPayload,\n      payable(msgSender),\n      address(this),\n      abi.encodePacked(\n        uint16(1),\n        uint256(gasParameters.msgBaseGas + (crossChainPayload.length * gasParameters.msgGasPerByte))\n      )\n    );\n  }\n\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice) {\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    // convert holograph chain id to lz chain id\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    GasParameters memory gasParameters = _gasParameters(toChain);\n    require(gasPrice > gasParameters.minGasPrice, \"HOLOGRAPH: gas price too low\");\n    bytes memory adapterParams = abi.encodePacked(\n      uint16(1),\n      uint256(gasParameters.msgBaseGas + (crossChainPayload.length * gasParameters.msgGasPerByte))\n    );\n    gasLimit = gasLimit + gasParameters.jobBaseGas + (crossChainPayload.length * gasParameters.jobGasPerByte);\n    gasLimit = gasLimit + (gasLimit / 10);\n    require(gasLimit < gasParameters.maxGasLimit, \"HOLOGRAPH: gas limit over max\");\n    (uint256 nativeFee, ) = lz.estimateFees(lzDestChain, address(this), crossChainPayload, false, adapterParams);\n    hlgFee = ((gasPrice * gasLimit) * dstPriceRatio) / (10 ** 20);\n    /*\n     * @dev toChain is a ChainIdType.HOLOGRAPH, which can be found at https://github.com/holographxyz/networks/blob/main/src/networks.ts\n     *      chainId 7 == optimism\n     *      chainId 4000000015 == optimismTestnetSepolia\n     */\n    if (toChain == uint32(7) || toChain == uint32(4000000074)) {\n      hlgFee += (_optimismGasPriceOracle().getL1Fee(crossChainPayload) * dstPriceRatio) / (10 ** 20);\n    }\n    msgFee = nativeFee;\n    dstGasPrice = (dstGasPriceInWei * dstPriceRatio) / (10 ** 20);\n  }\n\n  function getHlgFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee) {\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    GasParameters memory gasParameters = _gasParameters(toChain);\n    require(gasPrice > gasParameters.minGasPrice, \"HOLOGRAPH: gas price too low\");\n    gasLimit = gasLimit + gasParameters.jobBaseGas + (crossChainPayload.length * gasParameters.jobGasPerByte);\n    gasLimit = gasLimit + (gasLimit / 10);\n    require(gasLimit < gasParameters.maxGasLimit, \"HOLOGRAPH: gas limit over max\");\n    hlgFee = ((gasPrice * gasLimit) * dstPriceRatio) / (10 ** 20);\n    /*\n     * @dev toChain is a ChainIdType.HOLOGRAPH, which can be found at https://github.com/holographxyz/networks/blob/main/src/networks.ts\n     *      chainId 7 == optimism\n     *      chainId 4000000015 == optimismTestnetSepolia\n     */\n    if (toChain == uint32(7) || toChain == uint32(4000000074)) {\n      hlgFee += (_optimismGasPriceOracle().getL1Fee(crossChainPayload) * dstPriceRatio) / (10 ** 20);\n    }\n  }\n\n  function _getPricing(\n    LayerZeroOverrides lz,\n    uint16 lzDestChain\n  ) private view returns (uint128 dstPriceRatio, uint128 dstGasPriceInWei) {\n    return\n      LayerZeroOverrides(LayerZeroOverrides(lz.defaultSendLibrary()).getAppConfig(lzDestChain, address(this)).relayer)\n        .dstPriceLookup(lzDestChain);\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the approved LayerZero Endpoint\n   * @dev All lzReceive function calls allow only requests from this address\n   */\n  function getLZEndpoint() external view returns (address lZEndpoint) {\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n  }\n\n  /**\n   * @notice Update the approved LayerZero Endpoint address\n   * @param lZEndpoint address of the LayerZero Endpoint to use\n   */\n  function setLZEndpoint(address lZEndpoint) external onlyAdmin {\n    assembly {\n      sstore(_lZEndpointSlot, lZEndpoint)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Optimism Gas Price Oracle module\n   * @dev Allows to properly calculate the L1 security fee for Optimism bridge transactions\n   */\n  function getOptimismGasPriceOracle() external view returns (address optimismGasPriceOracle) {\n    assembly {\n      optimismGasPriceOracle := sload(_optimismGasPriceOracleSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Optimism Gas Price Oracle module address\n   * @param optimismGasPriceOracle address of the Optimism Gas Price Oracle smart contract to use\n   */\n  function setOptimismGasPriceOracle(address optimismGasPriceOracle) external onlyAdmin {\n    assembly {\n      sstore(_optimismGasPriceOracleSlot, optimismGasPriceOracle)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Operator Interface\n   */\n  function _operator() private view returns (HolographOperatorInterface operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Optimism Gas Price Oracle Interface\n   */\n  function _optimismGasPriceOracle() private view returns (OVM_GasPriceOracle optimismGasPriceOracle) {\n    assembly {\n      optimismGasPriceOracle := sload(_optimismGasPriceOracleSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n\n  /**\n   * @notice Get the default or chain-specific GasParameters\n   * @param chainId the Holograph ChainId to get gas parameters for, set to 0 for default\n   */\n  function getGasParameters(uint32 chainId) external view returns (GasParameters memory gasParameters) {\n    return _gasParameters(chainId);\n  }\n\n  /**\n   * @notice Update the default or chain-specific GasParameters\n   * @param chainId the Holograph ChainId to set gas parameters for, set to 0 for default\n   * @param gasParameters struct of all the gas parameters to set\n   */\n  function setGasParameters(uint32 chainId, GasParameters memory gasParameters) external onlyAdmin {\n    _setGasParameters(chainId, gasParameters);\n  }\n\n  /**\n   * @notice Update the default or chain-specific GasParameters\n   * @param chainIds array of Holograph ChainId to set gas parameters for\n   * @param gasParameters array of all the gas parameters to set\n   */\n  function setGasParameters(uint32[] memory chainIds, GasParameters[] memory gasParameters) external onlyAdmin {\n    require(chainIds.length == gasParameters.length, \"HOLOGRAPH: wrong array lengths\");\n    for (uint256 i = 0; i < chainIds.length; i++) {\n      _setGasParameters(chainIds[i], gasParameters[i]);\n    }\n  }\n\n  /**\n   * @notice Internal function for setting the default or chain-specific GasParameters\n   * @param chainId the Holograph ChainId to set gas parameters for, set to 0 for default\n   * @param gasParameters struct of all the gas parameters to set\n   */\n  function _setGasParameters(uint32 chainId, GasParameters memory gasParameters) private {\n    bytes32 slot = chainId == 0 ? _gasParametersSlot : keccak256(abi.encode(chainId, _gasParametersSlot));\n    assembly {\n      let pos := gasParameters\n      for {\n        let i := 0\n      } lt(i, 6) {\n        i := add(i, 1)\n      } {\n        sstore(add(slot, i), mload(pos))\n        pos := add(pos, 32)\n      }\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the default or chain-specific GasParameters\n   * @param chainId the Holograph ChainId to get gas parameters for, set to 0 for default\n   */\n  function _gasParameters(uint32 chainId) private view returns (GasParameters memory gasParameters) {\n    bytes32 slot = chainId == 0 ? _gasParametersSlot : keccak256(abi.encode(chainId, _gasParametersSlot));\n    assembly {\n      let pos := gasParameters\n      for {\n        let i := 0\n      } lt(i, 6) {\n        i := add(i, 1)\n      } {\n        mstore(pos, sload(add(slot, i)))\n        pos := add(pos, 32)\n      }\n    }\n  }\n}\n"
    },
    "src/module/LayerZeroModuleProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\ncontract LayerZeroModuleProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.layerZeroModule')) - 1)\n   */\n  bytes32 constant _layerZeroModuleSlot = 0x7c89cf3f353cabaa2f43d6eba6b9682ecfdeedd31a3b76a8b3e17a61970fb7f0;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address layerZeroModule, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_layerZeroModuleSlot, layerZeroModule)\n    }\n    (bool success, bytes memory returnData) = layerZeroModule.delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getLayerZeroModule() external view returns (address layerZeroModule) {\n    assembly {\n      layerZeroModule := sload(_layerZeroModuleSlot)\n    }\n  }\n\n  function setLayerZeroModule(address layerZeroModule) external onlyAdmin {\n    assembly {\n      sstore(_layerZeroModuleSlot, layerZeroModule)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let layerZeroModule := sload(_layerZeroModuleSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), layerZeroModule, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/module/OVM_GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\n/**\n * @title OVM_GasPriceOracle\n * @dev This contract exposes the current l2 gas price, a measure of how congested the network\n * currently is. This measure is used by the Sequencer to determine what fee to charge for\n * transactions. When the system is more congested, the l2 gas price will increase and fees\n * will also increase as a result.\n *\n * All public variables are set while generating the initial L2 state. The\n * constructor doesn't run in practice as the L2 state generation script uses\n * the deployed bytecode instead of running the initcode.\n */\ncontract OVM_GasPriceOracle is Admin, Initializable {\n  // Current L2 gas price\n  uint256 public gasPrice;\n  // Current L1 base fee\n  uint256 public l1BaseFee;\n  // Amortized cost of batch submission per transaction\n  uint256 public overhead;\n  // Value to scale the fee up by\n  uint256 public scalar;\n  // Number of decimals of the scalar\n  uint256 public decimals;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (uint256 _gasPrice, uint256 _l1BaseFee, uint256 _overhead, uint256 _scalar, uint256 _decimals) = abi.decode(\n      initPayload,\n      (uint256, uint256, uint256, uint256, uint256)\n    );\n    gasPrice = _gasPrice;\n    l1BaseFee = _l1BaseFee;\n    overhead = _overhead;\n    scalar = _scalar;\n    decimals = _decimals;\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  event GasPriceUpdated(uint256);\n  event L1BaseFeeUpdated(uint256);\n  event OverheadUpdated(uint256);\n  event ScalarUpdated(uint256);\n  event DecimalsUpdated(uint256);\n\n  /**\n   * Allows the owner to modify the l2 gas price.\n   * @param _gasPrice New l2 gas price.\n   */\n  function setGasPrice(uint256 _gasPrice) external onlyAdmin {\n    gasPrice = _gasPrice;\n    emit GasPriceUpdated(_gasPrice);\n  }\n\n  /**\n   * Allows the owner to modify the l1 base fee.\n   * @param _baseFee New l1 base fee\n   */\n  function setL1BaseFee(uint256 _baseFee) external onlyAdmin {\n    l1BaseFee = _baseFee;\n    emit L1BaseFeeUpdated(_baseFee);\n  }\n\n  /**\n   * Allows the owner to modify the overhead.\n   * @param _overhead New overhead\n   */\n  function setOverhead(uint256 _overhead) external onlyAdmin {\n    overhead = _overhead;\n    emit OverheadUpdated(_overhead);\n  }\n\n  /**\n   * Allows the owner to modify the scalar.\n   * @param _scalar New scalar\n   */\n  function setScalar(uint256 _scalar) external onlyAdmin {\n    scalar = _scalar;\n    emit ScalarUpdated(_scalar);\n  }\n\n  /**\n   * Allows the owner to modify the decimals.\n   * @param _decimals New decimals\n   */\n  function setDecimals(uint256 _decimals) external onlyAdmin {\n    decimals = _decimals;\n    emit DecimalsUpdated(_decimals);\n  }\n\n  /**\n   * Computes the L1 portion of the fee\n   * based on the size of the RLP encoded tx\n   * and the current l1BaseFee\n   * @param _data Unsigned RLP encoded tx, 6 elements\n   * @return L1 fee that should be paid for the tx\n   */\n  function getL1Fee(bytes memory _data) external view returns (uint256) {\n    uint256 l1GasUsed = getL1GasUsed(_data);\n    uint256 l1Fee = l1GasUsed * l1BaseFee;\n    uint256 divisor = 10 ** decimals;\n    uint256 unscaled = l1Fee * scalar;\n    uint256 scaled = unscaled / divisor;\n    return scaled;\n  }\n\n  /**\n   * Computes the amount of L1 gas used for a transaction\n   * The overhead represents the per batch gas overhead of\n   * posting both transaction and state roots to L1 given larger\n   * batch sizes.\n   * 4 gas for 0 byte\n   * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L33\n   * 16 gas for non zero byte\n   * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L87\n   * This will need to be updated if calldata gas prices change\n   * Account for the transaction being unsigned\n   * Padding is added to account for lack of signature on transaction\n   * 1 byte for RLP V prefix\n   * 1 byte for V\n   * 1 byte for RLP R prefix\n   * 32 bytes for R\n   * 1 byte for RLP S prefix\n   * 32 bytes for S\n   * Total: 68 bytes of padding\n   * @param _data Unsigned RLP encoded tx, 6 elements\n   * @return Amount of L1 gas used for a transaction\n   */\n  function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n    uint256 total = 0;\n    for (uint256 i = 0; i < _data.length; i++) {\n      if (_data[i] == 0) {\n        total += 4;\n      } else {\n        total += 16;\n      }\n    }\n    uint256 unsigned = total + overhead;\n    return unsigned + (68 * 16);\n  }\n}\n"
    },
    "src/proxy/CountdownERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/HolographRegistryInterface.sol\";\n\ncontract CountdownERC721Proxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (bytes32 contractType, address registry, bytes memory initCode) = abi.decode(data, (bytes32, address, bytes));\n    assembly {\n      sstore(_contractTypeSlot, contractType)\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = getCountdownERC721Source().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getCountdownERC721Source() public view returns (address) {\n    HolographRegistryInterface registry;\n    bytes32 contractType;\n    assembly {\n      registry := sload(_registrySlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return registry.getContractTypeAddress(contractType);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    address CountdownERC721Source = getCountdownERC721Source();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), CountdownERC721Source, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/CustomERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/HolographRegistryInterface.sol\";\n\ncontract CustomERC721Proxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (bytes32 contractType, address registry, bytes memory initCode) = abi.decode(data, (bytes32, address, bytes));\n    assembly {\n      sstore(_contractTypeSlot, contractType)\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = getCustomERC721Source().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getCustomERC721Source() public view returns (address) {\n    HolographRegistryInterface registry;\n    bytes32 contractType;\n    assembly {\n      registry := sload(_registrySlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return registry.getContractTypeAddress(contractType);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    address CustomERC721Source = getCustomERC721Source();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), CustomERC721Source, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/CxipERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\n\ncontract CxipERC721Proxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (bytes32 contractType, address registry, bytes memory initCode) = abi.decode(data, (bytes32, address, bytes));\n    assembly {\n      sstore(_contractTypeSlot, contractType)\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = getCxipERC721Source().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function getCxipERC721Source() public view returns (address) {\n    HolographRegistryInterface registry;\n    bytes32 contractType;\n    assembly {\n      registry := sload(_registrySlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return registry.getContractTypeAddress(contractType);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    address cxipErc721Source = getCxipERC721Source();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), cxipErc721Source, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/HolographBridgeProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\n\ncontract HolographBridgeProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n    }\n    (bool success, bytes memory returnData) = bridge.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let bridge := sload(_bridgeSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), bridge, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/HolographFactoryProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\n\ncontract HolographFactoryProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.factory')) - 1)\n   */\n  bytes32 constant _factorySlot = 0xa49f20855ba576e09d13c8041c8039fa655356ea27f6c40f1ec46a4301cd5b23;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address factory, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_factorySlot, factory)\n    }\n    (bool success, bytes memory returnData) = factory.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function getFactory() external view returns (address factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  function setFactory(address factory) external onlyAdmin {\n    assembly {\n      sstore(_factorySlot, factory)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let factory := sload(_factorySlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), factory, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/HolographOperatorProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\n\ncontract HolographOperatorProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address operator, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_operatorSlot, operator)\n    }\n    (bool success, bytes memory returnData) = operator.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let operator := sload(_operatorSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), operator, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/HolographRegistryProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\n\ncontract HolographRegistryProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address registry, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = registry.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let registry := sload(_registrySlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), registry, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/HolographTreasuryProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/InitializableInterface.sol\";\n\ncontract HolographTreasuryProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.treasury')) - 1)\n   */\n  bytes32 constant _treasurySlot = 0x4215e7a38d75164ca078bbd61d0992cdeb1ba16f3b3ead5944966d3e4080e8b6;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address treasury, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_treasurySlot, treasury)\n    }\n    (bool success, bytes memory returnData) = treasury.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function getTreasury() external view returns (address treasury) {\n    assembly {\n      treasury := sload(_treasurySlot)\n    }\n  }\n\n  function setTreasury(address treasury) external onlyAdmin {\n    assembly {\n      sstore(_treasurySlot, treasury)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let treasury := sload(_treasurySlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), treasury, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/proxy/hTokenProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/HolographRegistryInterface.sol\";\n\ncontract hTokenProxy is Admin, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (bytes32 contractType, address registry, bytes memory initCode) = abi.decode(data, (bytes32, address, bytes));\n    assembly {\n      sstore(_contractTypeSlot, contractType)\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = getHTokenSource().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == Initializable.init.selector, \"initialization failed\");\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function getHTokenSource() public view returns (address) {\n    HolographRegistryInterface registry;\n    bytes32 contractType;\n    assembly {\n      registry := sload(_registrySlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return registry.getContractTypeAddress(contractType);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    address hTokenSource = getHTokenSource();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), hTokenSource, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/struct/BridgeSettings.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct BridgeSettings {\n  uint256 value;\n  uint256 gasLimit;\n  uint256 gasPrice;\n  uint32 toChain;\n}\n"
    },
    "src/struct/CountdownERC721Initializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {CustomERC721SalesConfiguration} from \"src/struct/CustomERC721SalesConfiguration.sol\";\n\n/// @title A struct for initializing a CountdownERC721 contract\n/// @dev This struct is used during the deployment of a CountdownERC721 to set initial configuration parameters.\n/// @param description The description of the token.\n/// @param startDate The maximum start date\n/// @param initialMaxSupply The maximum initial supply.\n/// @param mintInterval The maximum interval between mints\n/// @param initialOwner The user that owns the contract, can mint tokens, receives royalty and sales payouts, and can update the base URL if needed.\n/// @param initialMinter The user that is allowed to mint tokens on behalf of others, typically for offchain purchasers.\n/// @param fundsRecipient The wallet or user that receives funds from token sales.\n/// @param contractURI The URI for the contract metadata.\n/// @param salesConfiguration The initial sales configuration settings, defining how tokens are sold.\nstruct CountdownERC721Initializer {\n  string description; // The description of the token.\n  string imageURI; // The URI for the image associated with this contract.\n  string externalLink; // The URI for the external metadata associated with this contract.\n  string encryptedMediaURI; // The URI for the encrypted media associated with this contract.\n  uint40 startDate; // The starting date for the countdown\n  uint32 initialMaxSupply; // The theoretical initial maximum supply of tokens at the start of the countdown.\n  uint24 mintInterval; // The interval between possible mints,\n  address initialOwner; // Address of the initial owner, who has administrative privileges.\n  address initialMinter; // Address of the initial minter, who can mint new tokens for those who purchase offchain.\n  address payable fundsRecipient; // Address of the recipient for funds gathered from sales.\n  string contractURI; // URI for the metadata associated with this contract.\n  CustomERC721SalesConfiguration salesConfiguration; // Configuration of sales settings for this contract.\n}\n"
    },
    "src/struct/CustomERC721Initializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {CustomERC721SalesConfiguration} from \"src/struct/CustomERC721SalesConfiguration.sol\";\nimport {LazyMintConfiguration} from \"src/struct/LazyMintConfiguration.sol\";\n\n/// @param initialOwner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\n/// @param initialMinter User that can mint on behalf of those who purchase offchain\n/// @param fundsRecipient Wallet/user that receives funds from sale\n/// @param mintTimeCost The time to subtract from the countdownEnd on each mint\n/// @param countdownEnd The countdown end time\n/// @param royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\n/// @param salesConfiguration The initial SalesConfiguration\n/// @param lazyMintsConfigurations The initial Lazy mints configurations\nstruct CustomERC721Initializer {\n  uint40 startDate; // max start date in year 36_812\n  uint32 initialMaxSupply; // max initial supply 4_294_967_295 tokens\n  uint24 mintInterval; // max mint interval 16_777_215 seconds\n  address initialOwner;\n  address initialMinter;\n  address payable fundsRecipient;\n  string contractURI;\n  CustomERC721SalesConfiguration salesConfiguration;\n  LazyMintConfiguration[] lazyMintsConfigurations;\n}\n"
    },
    "src/struct/CustomERC721SaleDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return value for sales details to use with front-ends\nstruct CustomERC721SaleDetails {\n  // Sale state\n  bool publicSaleActive;\n  // Price for public sale\n  uint256 publicSalePrice;\n  // Timed sale actions for public sale\n  uint256 publicSaleStart;\n  // Limit public sale to a specific number of mints per wallet\n  uint256 maxSalePurchasePerAddress;\n  // Information about the rest of the supply\n  // Total that have been minted\n  uint256 totalMinted;\n  // The total supply available\n  uint256 maxSupply;\n}\n"
    },
    "src/struct/CustomERC721SalesConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Sales states and configuration\n/// @dev Uses 2 storage slots (Can be set by the owner)\nstruct CustomERC721SalesConfiguration {\n  /// @dev Public sale price (max ether value > 1000 ether with this value)\n  uint104 publicSalePrice;\n  /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n  /// @dev Max purchase number per txn (90+32 = 122)\n  uint24 maxSalePurchasePerAddress;\n}\n"
    },
    "src/struct/DeploymentConfig.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct DeploymentConfig {\n  bytes32 contractType;\n  uint32 chainType;\n  bytes32 salt;\n  bytes byteCode;\n  bytes initCode;\n}\n"
    },
    "src/struct/GasParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct GasParameters {\n  uint256 msgBaseGas;\n  uint256 msgGasPerByte;\n  uint256 jobBaseGas;\n  uint256 jobGasPerByte;\n  uint256 minGasPrice;\n  uint256 maxGasLimit;\n}\n"
    },
    "src/struct/LazyMintConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @notice LazyMint configuration\nstruct LazyMintConfiguration {\n  /// @dev _amount The amount of tokens to lazy mint (basically the batch size)\n  uint256 _amount;\n  /// @dev _baseURIForTokens The base URI for the tokens in this batch\n  string _baseURIForTokens;\n  /// @dev _data The data to be used to set the encrypted URI.\n  ///      A bytes containing a sub bytes and a bytes32 => abi.encode(bytes(0x00..0), bytes32(0x00..0));\n  bytes _data;\n}"
    },
    "src/struct/MetadataParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct MetadataParams {\n  string name;\n  string description;\n  string imageURI;\n  string animationURI;\n  string externalUrl;\n  string encryptedMediaUrl;\n  string decryptionKey;\n  string hash;\n  string decryptedMediaUrl;\n  uint256 tokenOfEdition;\n  uint256 editionSize;\n}\n"
    },
    "src/struct/OperatorJob.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct OperatorJob {\n  uint8 pod;\n  uint16 blockTimes;\n  address operator;\n  uint40 startBlock;\n  uint64 startTimestamp;\n  uint16[5] fallbackOperators;\n}\n\n/*\n\nuint\t\tDigits\tMax value\n-----------------------------\nuint8\t\t3\t\t255\nuint16\t\t5\t\t65,535\nuint24\t\t8\t\t16,777,215\nuint32\t\t10\t\t4,294,967,295\nuint40\t\t13\t\t1,099,511,627,775\nuint48\t\t15\t\t281,474,976,710,655\nuint56\t\t17\t\t72,057,594,037,927,935\nuint64\t\t20\t\t18,446,744,073,709,551,615\nuint72\t\t22\t\t4,722,366,482,869,645,213,695\nuint80\t\t25\t\t1,208,925,819,614,629,174,706,175\nuint88\t\t27\t\t309,485,009,821,345,068,724,781,055\nuint96\t\t29\t\t79,228,162,514,264,337,593,543,950,335\n...\nuint128\t\t39\t\t340,282,366,920,938,463,463,374,607,431,768,211,455\n...\nuint256\t\t78\t\t115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,935\n\n*/\n"
    },
    "src/struct/Verification.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct Verification {\n  bytes32 r;\n  bytes32 s;\n  uint8 v;\n}\n"
    },
    "src/struct/ZoraBidShares.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./ZoraDecimal.sol\";\n\nstruct HolographBidShares {\n  // % of sale value that goes to the _previous_ owner of the nft\n  HolographDecimal prevOwner;\n  // % of sale value that goes to the original creator of the nft\n  HolographDecimal creator;\n  // % of sale value that goes to the seller (current owner) of the nft\n  HolographDecimal owner;\n}\n"
    },
    "src/struct/ZoraDecimal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct HolographDecimal {\n  uint256 value;\n}\n"
    },
    "src/token/CountdownERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../abstract/NonReentrant.sol\";\nimport {ContractMetadata} from \"../abstract/ContractMetadata.sol\";\n\nimport {HolographERC721Interface} from \"../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../interface/HolographInterface.sol\";\nimport {ICustomERC721} from \"../interface/ICustomERC721.sol\";\nimport {IDropsPriceOracle} from \"../drops/interface/IDropsPriceOracle.sol\";\nimport {HolographTreasuryInterface} from \"../interface/HolographTreasuryInterface.sol\";\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CountdownERC721Initializer} from \"src/struct/CountdownERC721Initializer.sol\";\nimport {CustomERC721SaleDetails} from \"src/struct/CustomERC721SaleDetails.sol\";\nimport {CustomERC721SalesConfiguration} from \"src/struct/CustomERC721SalesConfiguration.sol\";\nimport {MetadataParams} from \"src/struct/MetadataParams.sol\";\n\nimport {Address} from \"../drops/library/Address.sol\";\nimport {MerkleProof} from \"../drops/library/MerkleProof.sol\";\nimport {Strings} from \"./../drops/library/Strings.sol\";\nimport {NFTMetadataRenderer} from \"../library/NFTMetadataRenderer.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified the source code for them.\n */\ncontract CountdownERC721 is NonReentrant, ContractMetadata, ERC721H, ICustomERC721 {\n  using Strings for uint256;\n\n  // TODO: Update the base image URI\n  string private constant BASE_IMAGE_URI = \"https://arweave.net/o8eyC27OuSZF0z-zIen5NTjJOKTzOQzKJzIe3F7Lmg0/1.png\";\n  string private constant BASE_ANIMATION_URI = \"\"; // Define if you have a specific animation URI\n\n  /* -------------------------------------------------------------------------- */\n  /*                             CONTRACT VARIABLES                             */\n  /*        all variables, without custom storage slots, are defined here       */\n  /* -------------------------------------------------------------------------- */\n\n  /// @notice Getter for the description\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  string public DESCRIPTION;\n\n  /// @notice Getter for the purchase start date\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public START_DATE;\n\n  /// @notice Getter for the initial max supply\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public INITIAL_MAX_SUPPLY;\n\n  /// @notice Getter for the mint interval\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public MINT_INTERVAL;\n\n  /// @notice Getter for the mint interval\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  address payable FUNDS_RECIPIENT;\n\n  /// @notice Getter for the initial end date\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public INITIAL_END_DATE;\n\n  /// @notice Getter for the end date\n  uint256 public END_DATE;\n\n  /// @notice Getter for the minter\n  /// @dev This account tokens on behalf of those that purchase them offchain\n  address public minter;\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev Internal reference to the base URI\n   */\n  string private _baseURI;\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Sales configuration\n   */\n  CustomERC721SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for the total mints by address\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  MODIFIERS                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Allows only the minter to call the function\n   */\n  modifier onlyMinter() {\n    if (msgSender() != minter) {\n      revert Access_OnlyMinter();\n    }\n    _;\n  }\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    /// @dev Check if the countdown has completed\n    ///      END_DATE - MINT_INTERVAL * (quantity - 1) represent the time when the last mint will be allowed\n    ///      (quantity - 1) because we want to allow the last mint to be available until the END_DATE\n    if (block.timestamp >= END_DATE - MINT_INTERVAL * (quantity - 1)) {\n      revert Purchase_CountdownCompleted();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n    _;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            CONTRACT INITIALIZERS                           */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/the factory when creating a contract\n   * @param initPayload abi encoded payload (CountdownERC721Initializer struct) to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    // Enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Decode the initializer payload to get the CountdownERC721Initializer struct\n    CountdownERC721Initializer memory initializer = abi.decode(initPayload, (CountdownERC721Initializer));\n\n    _setupContractURI(initializer.contractURI);\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // Setup the minter role\n    _setMinter(initializer.initialMinter);\n\n    // Setup the contract URI\n\n    // Set the description\n    /// @dev The description is a human-readable description of the token.\n    ///      The description is used like an immutable.\n    DESCRIPTION = initializer.description;\n\n    // Set the sale start date.\n    /// @dev The sale start date represents the date when the public sale starts.\n    ///      The sale start date is used like an immutable.\n    START_DATE = initializer.startDate;\n\n    // Set the initial max supply.\n    /// @dev The initial max supply represents the theoretical maximum supply at the start date timestamp.\n    ///      The sale start date is used like an immutable.\n    INITIAL_MAX_SUPPLY = initializer.initialMaxSupply;\n\n    // Set the mint interval.\n    /// @dev The mint interval specifies the duration by which the END_DATE is decreased after each mint operation.\n    ///      The sale start date is used like an immutable.\n    MINT_INTERVAL = initializer.mintInterval;\n\n    // Set the funds recipient\n    /// @dev The funds recipient is the address that receives the funds from the token sales.\n    ///      The funds recipient can be updated by the owner.\n    FUNDS_RECIPIENT = initializer.fundsRecipient;\n\n    // Set the end dates\n    /// @dev The END_DATE is calculated by adding the initial max supply times the mint interval to the start date.\n    ///      The END_DATE is decreased after each mint operation by the mint interval.\n    uint256 endDate = initializer.startDate + initializer.initialMaxSupply * initializer.mintInterval;\n    END_DATE = endDate;\n    /// @dev The sale start date is used like an immutable.\n    INITIAL_END_DATE = endDate;\n\n    // Set the sales configuration\n    salesConfig = initializer.salesConfiguration;\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                     PUBLIC NON STATE CHANGING FUNCTIONS                    */\n  /*                                   static                                   */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version of the contract\n   */\n  function version() external pure returns (uint32) {\n    return 1;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(ICustomERC721).interfaceId;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                     PUBLIC NON STATE CHANGING FUNCTIONS                    */\n  /*                                   dynamic                                  */\n  /* -------------------------------------------------------------------------- */\n\n  function owner() external view override(ERC721H, ICustomERC721) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  /**\n   * @notice Returns the theoretical maximum supply for the current time\n   * @dev The max supply is calculated based on the current time and the mint interval, by subtracting\n   *      the elapsed_mint intervals from the initial max supply.\n   *      - The max supply is the initial max supply if the current time is less than the start date.\n   *      - The max supply is zero if the current time is greater than the end date.\n   *      - The max supply is decreased by one for each mint interval that has passed.\n   *      - The max supply is calculated by subtracting the intervals elapsed from the initial max supply.\n   * @return max supply\n   */\n  function currentTheoricalMaxSupply() public view returns (uint256) {\n    if (block.timestamp <= START_DATE) {\n      return INITIAL_MAX_SUPPLY;\n    } else if (block.timestamp >= START_DATE + INITIAL_MAX_SUPPLY * MINT_INTERVAL) {\n      return 0; // All intervals have elapsed\n    } else {\n      // EVM division is floored\n      uint256 intervalsElapsed = (block.timestamp - START_DATE) / MINT_INTERVAL;\n      return INITIAL_MAX_SUPPLY - intervalsElapsed;\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of tokens minted in the contract.\n   */\n  function totalMinted() external view returns (uint256) {\n    return _currentTokenId;\n  }\n\n  /**\n   * @notice Sale details\n   * @dev Returns the sale details for the contract\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (CustomERC721SaleDetails memory) {\n    return\n      CustomERC721SaleDetails({\n        publicSaleActive: _publicSaleActive(), // Based on the current time\n        publicSalePrice: salesConfig.publicSalePrice, // Can be updated by the owner\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress, // Can be updated by the owner\n        publicSaleStart: START_DATE, // Immutable\n        totalMinted: _currentTokenId, // Updated after each mint\n        maxSupply: currentTheoricalMaxSupply() // Updated after each mint or after each interval\n      });\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: 0, // NOTE: Presale mints are not supported\n        publicMints: totalMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @dev Returns a base64 encoded metadata URI for a given tokenId.\n   * @param tokenId The ID of the token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 tokenId) public view returns (string memory) {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    require(H721.exists(tokenId), \"ERC721: token does not exist\");\n\n    string memory _name = H721.name();\n    MetadataParams memory params = MetadataParams({\n      name: _name,\n      description: DESCRIPTION,\n      imageURI: BASE_IMAGE_URI,\n      animationURI: BASE_ANIMATION_URI,\n      externalUrl: \"https://your-nft-project.com\", // This should be dynamically set or fetched\n      encryptedMediaUrl: \"ar://encryptedMediaUriHere\", // This should be dynamically set or fetched\n      decryptionKey: \"decryptionKeyHere\", // This should be dynamically set or fetched\n      hash: \"uniqueNftHashHere\", // This should be dynamically set or fetched\n      decryptedMediaUrl: \"ar://decryptedMediaUriHere\", // This should be dynamically set or fetched\n      tokenOfEdition: tokenId,\n      editionSize: 0 // Set or fetch dynamically if applicable\n    });\n\n    return NFTMetadataRenderer.createMetadataEdition(params);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                       PUBLIC STATE CHANGING FUNCTIONS                      */\n  /*                              available to all                              */\n  /* -------------------------------------------------------------------------- */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   * @param quantity quantity to purchase\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n\n    if (msg.value < (salePrice) * quantity) {\n      // The error will display what the correct price should be\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice) * quantity);\n    }\n\n    // Reducing the end date by removing the quantity of mints times the mint interval\n    END_DATE = END_DATE - quantity * MINT_INTERVAL;\n\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity > salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                       PUBLIC STATE CHANGING FUNCTIONS                      */\n  /*                                 admin only                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Minter account mints tokens to a recipient that has paid offchain\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function mintTo(address recipient, uint256 quantity) external onlyMinter canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   */\n  function setSaleConfiguration(uint104 publicSalePrice, uint24 maxSalePurchasePerAddress) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    FUNDS_RECIPIENT = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (FUNDS_RECIPIENT == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != FUNDS_RECIPIENT && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = FUNDS_RECIPIENT.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, FUNDS_RECIPIENT, funds);\n  }\n\n  /**\n   * @notice Set the minter address\n   * @param minterAddress new minter address\n   */\n  function setMinter(address minterAddress) external onlyOwner {\n    _setMinter(minterAddress);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             INTERNAL FUNCTIONS                             */\n  /*                             non state changing                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Internal function to return the base URI stored in the contract.\n   * Used to construct the URI for each token.\n   */\n  function baseURI() internal view returns (string memory) {\n    return _baseURI;\n  }\n\n  /// @notice Checks whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view override returns (bool) {\n    return msgSender() == _getOwner();\n  }\n\n  /**\n   * @dev Checks if the public sale is active\n   */\n  function _publicSaleActive() internal view returns (bool) {\n    return START_DATE <= block.timestamp;\n  }\n\n  /**\n   * @dev Converts the given amount in USD to the equivalent amount in wei using the price oracle.\n   * @param amount The amount in USD to convert to wei\n   */\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             INTERNAL FUNCTIONS                             */\n  /*                               state changing                               */\n  /* -------------------------------------------------------------------------- */\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n\n    for (uint256 i = 0; i != quantity; ) {\n      unchecked {\n        _currentTokenId += 1;\n      }\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        unchecked {\n          _currentTokenId += 1;\n        }\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n\n      uint256 id = chainPrepend + uint256(tokenId);\n      emit NFTMinted(recipient, tokenId, id);\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * @dev Set the minter address\n   * @param minterAddress new minter address\n   */\n  function _setMinter(address minterAddress) internal {\n    minter = minterAddress;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Fallback                                  */\n  /* -------------------------------------------------------------------------- */\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    },
    "src/token/CustomERC721.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../abstract/NonReentrant.sol\";\nimport {DelayedReveal} from \"../abstract/DelayedReveal.sol\";\nimport {ContractMetadata} from \"../abstract/ContractMetadata.sol\";\n\nimport {HolographERC721Interface} from \"../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../interface/HolographInterface.sol\";\nimport {ICustomERC721} from \"../interface/ICustomERC721.sol\";\nimport {IDropsPriceOracle} from \"../drops/interface/IDropsPriceOracle.sol\";\nimport {HolographTreasuryInterface} from \"../interface/HolographTreasuryInterface.sol\";\n\nimport {InitializableLazyMint} from \"../extension/InitializableLazyMint.sol\";\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CustomERC721Initializer} from \"../struct/CustomERC721Initializer.sol\";\nimport {CustomERC721SaleDetails} from \"src/struct/CustomERC721SaleDetails.sol\";\nimport {CustomERC721SalesConfiguration} from \"src/struct/CustomERC721SalesConfiguration.sol\";\n\nimport {Address} from \"../drops/library/Address.sol\";\nimport {MerkleProof} from \"../drops/library/MerkleProof.sol\";\nimport {Strings} from \"./../drops/library/Strings.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified the source code for them.\n */\ncontract CustomERC721 is NonReentrant, ContractMetadata, InitializableLazyMint, DelayedReveal, ERC721H, ICustomERC721 {\n  using Strings for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             CONTRACT VARIABLES                             */\n  /*        all variables, without custom storage slots, are defined here       */\n  /* -------------------------------------------------------------------------- */\n\n  /// @notice Getter for the purchase start date\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public START_DATE;\n\n  /// @notice Getter for the initial max supply\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public INITIAL_MAX_SUPPLY;\n\n  /// @notice Getter for the mint interval\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public MINT_INTERVAL;\n\n  /// @notice Getter for the mint interval\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  address payable public FUNDS_RECIPIENT;\n\n  /// @notice Getter for the initial end date\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public INITIAL_END_DATE;\n\n  /// @notice Getter for the end date\n  uint256 public END_DATE;\n\n  /// @notice Getter for the minter\n  /// @dev This account tokens on behalf of those that purchase them offchain\n  address public minter;\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Sales configuration\n   */\n  CustomERC721SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for the total mints by address\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  MODIFIERS                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Allows only the minter to call the function\n   */\n  modifier onlyMinter() {\n    if (msgSender() != minter) {\n      revert Access_OnlyMinter();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    /// @dev Check if the countdown has completed\n    ///      END_DATE - MINT_INTERVAL * (quantity - 1) represent the time when the last mint will be allowed\n    ///      (quantity - 1) because we want to allow the last mint to be available until the END_DATE\n    if (block.timestamp >= END_DATE - MINT_INTERVAL * (quantity - 1)) {\n      revert Purchase_CountdownCompleted();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n    _;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            CONTRACT INITIALIZERS                           */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/the factory when creating a contract\n   * @param initPayload abi encoded payload (CustomERC721Initializer struct) to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    // Enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Decode the initializer payload to get the CustomERC721Initializer struct\n    CustomERC721Initializer memory initializer = abi.decode(initPayload, (CustomERC721Initializer));\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // Setup the minter role\n    minter = initializer.initialMinter;\n\n    // Setup the contract URI\n    _setupContractURI(initializer.contractURI);\n\n    // Init all the the lazy mints.\n    /// @dev The CustomERC721Initializer struct contains the lazy mint configurations.\n    ///      You must know that:\n    ///      - Each lazy mint configuration contains the amount of tokens per batch, the batchs baseURI, and the batchs data.\n    ///      - The batchs data is an abi encoded payload containing the encryptedURI (string) and the provenanceHash (bytes32)\n    ///      - The provenanceHash is used to as a proof when decrypting the encryptedURI\n    for (uint256 i = 0; i < initializer.lazyMintsConfigurations.length; ) {\n      lazyMint(\n        initializer.lazyMintsConfigurations[i]._amount,\n        initializer.lazyMintsConfigurations[i]._baseURIForTokens,\n        initializer.lazyMintsConfigurations[i]._data\n      );\n\n      unchecked {\n        i++;\n      }\n    }\n\n    // Set the sale start date.\n    /// @dev The sale start date represents the date when the public sale starts.\n    ///      The sale start date is used like an immutable.\n    START_DATE = initializer.startDate;\n\n    // Set the initial max supply.\n    /// @dev The initial max supply represents the theoretical maximum supply at the start date timestamp.\n    ///      The sale start date is used like an immutable.\n    INITIAL_MAX_SUPPLY = initializer.initialMaxSupply;\n\n    // Set the mint interval.\n    /// @dev The mint interval specifies the duration by which the END_DATE is decreased after each mint operation.\n    ///      The sale start date is used like an immutable.\n    MINT_INTERVAL = initializer.mintInterval;\n    // Set the funds recipient\n    FUNDS_RECIPIENT = initializer.fundsRecipient;\n\n    // Set the end dates\n    /// @dev The END_DATE is calculated by adding the initial max supply times the mint interval to the start date.\n    ///      The END_DATE is decreased after each mint operation by the mint interval.\n    uint256 endDate = initializer.startDate + initializer.initialMaxSupply * initializer.mintInterval;\n    END_DATE = endDate;\n    /// @dev The sale start date is used like an immutable.\n    INITIAL_END_DATE = endDate;\n\n    // Set the sales configuration\n    salesConfig = initializer.salesConfiguration;\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /**\n   * @notice Sync the lazy minting with the prepended tokenID\n   * @dev This function is called after the lazy mints has all been done in the init funcition.\n   *      It aligns the lazy mint storage with a new token ID by applying the chain-specific token ID prepend.\n   * @return chainPrepend The chain prepend used to sync the lazy minting\n   */\n  function syncLazyMint() external override onlyOwner returns (uint256 chainPrepend) {\n    // Check if the contract has been initialized\n    if (!_isInitialized()) revert NotInitialized();\n    // Check if the lazy minting is not initialized yet\n    if (_isLazyMintInitialized()) revert LazyMint_AlreadyInitialized();\n\n    // Get the chain prepend\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    chainPrepend = H721.sourceGetChainPrepend() + 1;\n\n    // Set the lazy mint initialized status to true to prevent this function from being called again\n    _setLazyMintInitialized();\n\n    if (chainPrepend == 0) {\n      return 0;\n    }\n\n    // Sync batch metadata with the prepended tokenID\n    uint256 batchIdsLength = batchIds.length;\n    for (uint256 i = 0; i < batchIdsLength; i++) {\n      /* --------------------- Update storage with the prepend -------------------- */\n\n      // Store the baseURI for the prepended tokenID\n      baseURIs[batchIds[i] + chainPrepend] = baseURIs[batchIds[i]];\n      // Store the frozen status for the prepended tokenID\n      batchFrozen[batchIds[i] + chainPrepend] = batchFrozen[batchIds[i]];\n      // Store the encrypted data for the prepended tokenID\n      _setEncryptedData(batchIds[i] + chainPrepend, encryptedData[batchIds[i]]);\n      // Update the batchId to the prepended tokenID\n      batchIds[i] += chainPrepend;\n\n      /* ---------------------------- Clearing storage ---------------------------- */\n      /// @dev Clearing storage enables to obtain a gas refund\n\n      // Clear the baseURI for the original tokenID\n      delete baseURIs[batchIds[i]];\n      // Clear the frozen status for the original tokenID\n      delete batchFrozen[batchIds[i]];\n      // Clear the encrypted data for the original tokenID\n      _setEncryptedData(batchIds[i], \"\");\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                     PUBLIC NON STATE CHANGING FUNCTIONS                    */\n  /*                                   static                                   */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version of the contract\n   */\n  function version() external pure returns (uint32) {\n    return 1;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(ICustomERC721).interfaceId;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                     PUBLIC NON STATE CHANGING FUNCTIONS                    */\n  /*                                   dynamic                                  */\n  /* -------------------------------------------------------------------------- */\n\n  function owner() external view override(ERC721H, ICustomERC721) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  /**\n   * @notice Returns the theoretical maximum supply for the current time\n   * @dev The max supply is calculated based on the current time and the mint interval, by subtracting\n   *      the elapsed_mint intervals from the initial max supply.\n   *      - The max supply is the initial max supply if the current time is less than the start date.\n   *      - The max supply is zero if the current time is greater than the end date.\n   *      - The max supply is decreased by one for each mint interval that has passed.\n   *      - The max supply is calculated by subtracting the intervals elapsed from the initial max supply.\n   * @return max supply\n   */\n  function currentTheoricalMaxSupply() public view returns (uint256) {\n    if (block.timestamp <= START_DATE) {\n      return INITIAL_MAX_SUPPLY;\n    } else if (block.timestamp >= START_DATE + INITIAL_MAX_SUPPLY * MINT_INTERVAL) {\n      return 0; // All intervals have elapsed\n    } else {\n      // EVM division is floored\n      uint256 intervalsElapsed = (block.timestamp - START_DATE) / MINT_INTERVAL;\n      return INITIAL_MAX_SUPPLY - intervalsElapsed;\n    }\n  }\n\n  /**\n   * @notice Sale details\n   * @dev Returns the sale details for the contract\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (CustomERC721SaleDetails memory) {\n    return\n      CustomERC721SaleDetails({\n        publicSaleActive: _publicSaleActive(), // Based on the current time\n        publicSalePrice: salesConfig.publicSalePrice, // Can be updated by the owner\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress, // Can be updated by the owner\n        publicSaleStart: START_DATE, // Immutable\n        totalMinted: _currentTokenId, // Updated after each mint\n        maxSupply: currentTheoricalMaxSupply() // Updated after each mint or after each interval\n      });\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: 0, // NOTE: Presale mints are not supported\n        publicMints: totalMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @dev Returns the URI for a given tokenId.\n   * @param _tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 _tokenId) public view returns (string memory) {\n    // If the URI is encrypted, return the placeholder URI\n    // If not, return the revealed URI with the tokenId appended\n    string memory batchUri = _getBaseURI(_tokenId);\n\n    return string(abi.encodePacked(batchUri, _tokenId.toString()));\n  }\n\n  /**\n   * @dev Returns the base URI for a given tokenId. It return the base URI corresponding to the batch the tokenId\n   * belongs to.\n   * @param _tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function baseURI(uint256 _tokenId) public view returns (string memory) {\n    return _getBaseURI(_tokenId);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                       PUBLIC STATE CHANGING FUNCTIONS                      */\n  /*                              available to all                              */\n  /* -------------------------------------------------------------------------- */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   *  @notice Lets an authorized address reveal a batch of delayed reveal NFTs.\n   *  @param _index The ID for the batch of delayed-reveal NFTs to reveal.\n   *  @param _key The key with which the base URI for the relevant batch of NFTs was encrypted.\n   */\n  function reveal(uint256 _index, bytes calldata _key) public virtual override returns (string memory revealedURI) {\n    require(_canReveal(), \"Not authorized\");\n\n    // Get the batch ID at the given index\n    uint256 batchId = getBatchIdAtIndex(_index);\n\n    // Decrypt the base URI for the batch\n    revealedURI = getRevealURI(batchId, _key);\n\n    // Clear the encrypted data for the batch\n    _setEncryptedData(batchId, \"\");\n\n    // Update the decrypted base URI for the batch\n    // NOTE: It replace the initial placeholder uri with the revealed uri\n    _setBaseURI(batchId, revealedURI);\n\n    emit TokenURIRevealed(_index, revealedURI);\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   * @param quantity quantity to purchase\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n\n    if (msg.value < (salePrice) * quantity) {\n      // The error will display what the correct price should be\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice) * quantity);\n    }\n\n    // Reducing the end date by removing the quantity of mints times the mint interval\n    END_DATE = END_DATE - quantity * MINT_INTERVAL;\n\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity > salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                       PUBLIC STATE CHANGING FUNCTIONS                      */\n  /*                                 admin only                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Minter account mints tokens to a recipient that has paid offchain\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function mintTo(address recipient, uint256 quantity) external canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   */\n  function setSaleConfiguration(uint104 publicSalePrice, uint24 maxSalePurchasePerAddress) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    FUNDS_RECIPIENT = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (FUNDS_RECIPIENT == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != FUNDS_RECIPIENT && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = FUNDS_RECIPIENT.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, FUNDS_RECIPIENT, funds);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             INTERNAL FUNCTIONS                             */\n  /*                             non state changing                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Checks if the public sale is active\n   */\n  function _publicSaleActive() internal view returns (bool) {\n    return START_DATE <= block.timestamp;\n  }\n\n  /**\n   * @dev Converts the given amount in USD to the equivalent amount in wei using the price oracle.\n   * @param amount The amount in USD to convert to wei\n   */\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /// @notice Returns whether lazy minting can be done in the given execution context.\n  function _canLazyMint() internal view override returns (bool) {\n    return !_isInitialized() || ((msgSender() == _getOwner()) && _publicSaleActive());\n  }\n\n  /// @notice Checks whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view override returns (bool) {\n    return msgSender() == _getOwner();\n  }\n\n  /**\n   * @notice Returns the total amount of tokens minted in the contract.\n   */\n  function totalMinted() external view returns (uint256) {\n    return _currentTokenId;\n  }\n\n  /// @notice The tokenId of the next NFT that will be minted / lazy minted.\n  function nextTokenIdToMint() external view returns (uint256) {\n    return nextTokenIdToLazyMint;\n  }\n\n  /// @notice The next token ID of the NFT that can be claimed.\n  function nextTokenIdToClaim() external view returns (uint256) {\n    return _currentTokenId + 1;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             INTERNAL FUNCTIONS                             */\n  /*                               state changing                               */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev This function is used to set the placeholder base URI, the encrypted one and the provennance hashe for\n   *      a batch of tokens.\n   * @dev We override the `lazyMint` function, and use the `_data` parameter for storing encrypted metadata\n   *      for 'delayed reveal' NFTs.\n   * @param _amount The amount of tokens in the batch\n   * @param _baseURIForTokens The placeholder base URI for the batch\n   * @param _data The encrypted metadata for the batch, abi encoded payload containing the encryptedURI (string)\n   *              and the provenanceHash (bytes32).\n   */\n  function lazyMint(\n    uint256 _amount,\n    string memory _baseURIForTokens,\n    bytes memory _data\n  ) internal override returns (uint256 batchId) {\n    // If the data is not empty, set the encrypted base URI and the provenance hash for the batch\n    if (_data.length > 0) {\n      // Decode the data to get the encrypted URI and the provenance hash\n      (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(_data, (bytes, bytes32));\n\n      // If both the encrypted URI and the provenance hash are not empty, set the encrypted data for the batch\n      if (encryptedURI.length != 0 && provenanceHash != \"\") {\n        _setEncryptedData(nextTokenIdToLazyMint + _amount, _data);\n      }\n    }\n\n    // Call the parent lazy mint function\n    return super.lazyMint(_amount, _baseURIForTokens, _data);\n  }\n\n  /// @dev Checks whether NFTs can be revealed in the given execution context.\n  function _canReveal() internal view virtual returns (bool) {\n    return msgSender() == _getOwner();\n  }\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n\n    for (uint256 i = 0; i != quantity; ) {\n      unchecked {\n        _currentTokenId += 1;\n      }\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        unchecked {\n          _currentTokenId += 1;\n        }\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n\n      uint256 id = chainPrepend + uint256(tokenId);\n      emit NFTMinted(recipient, tokenId, id);\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Fallback                                  */\n  /* -------------------------------------------------------------------------- */\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    },
    "src/token/CxipERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/ERC721H.sol\";\n\nimport \"../enum/TokenUriType.sol\";\n\nimport \"../interface/HolographERC721Interface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\n\n/**\n * @title CXIP ERC-721 Collection that is bridgeable via Holograph\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract CxipERC721 is ERC721H {\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev Enum of type of token URI to use globally for the entire contract.\n   */\n  TokenUriType private _uriType;\n\n  /**\n   * @dev Enum mapping of type of token URI to use for specific tokenId.\n   */\n  mapping(uint256 => TokenUriType) private _tokenUriType;\n\n  /**\n   * @dev Mapping of IPFS URIs for tokenIds.\n   */\n  mapping(uint256 => mapping(TokenUriType => string)) private _tokenURIs;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    // we set this as default type since that's what Mint is currently using\n    _uriType = TokenUriType.IPFS;\n    address owner = abi.decode(initPayload, (address));\n    _setOwner(owner);\n    // run underlying initializer logic\n    return _init(initPayload);\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @return string The URI.\n   */\n  function tokenURI(uint256 _tokenId) external view onlyHolographer returns (string memory) {\n    TokenUriType uriType = _tokenUriType[_tokenId];\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    return\n      string(\n        abi.encodePacked(\n          HolographInterfacesInterface(\n            HolographInterface(HolographerInterface(holographer()).getHolograph()).getInterfaces()\n          ).getUriPrepend(uriType),\n          _tokenURIs[_tokenId][uriType]\n        )\n      );\n  }\n\n  function cxipMint(\n    uint224 tokenId,\n    TokenUriType uriType,\n    string calldata tokenUri\n  ) external onlyHolographer onlyOwner {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    if (tokenId == 0) {\n      _currentTokenId += 1;\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n    }\n    H721.sourceMint(msgSender(), tokenId);\n    uint256 id = chainPrepend + uint256(tokenId);\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    _tokenUriType[id] = uriType;\n    _tokenURIs[id][uriType] = tokenUri;\n  }\n\n  function bridgeIn(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external onlyHolographer returns (bool) {\n    (TokenUriType uriType, string memory tokenUri) = abi.decode(_data, (TokenUriType, string));\n    _tokenUriType[_tokenId] = uriType;\n    _tokenURIs[_tokenId][uriType] = tokenUri;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 _tokenId\n  ) external view onlyHolographer returns (bytes memory _data) {\n    TokenUriType uriType = _tokenUriType[_tokenId];\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    _data = abi.encode(uriType, _tokenURIs[_tokenId][uriType]);\n  }\n\n  function afterBurn(address /* _owner*/, uint256 _tokenId) external onlyHolographer returns (bool) {\n    TokenUriType uriType = _tokenUriType[_tokenId];\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    delete _tokenURIs[_tokenId][uriType];\n    return true;\n  }\n}\n"
    },
    "src/token/HolographUtilityToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/HLGERC20H.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\n\n/**\n * @title Holograph Utility Token.\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph's ERC20 Utility Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographUtilityToken is HLGERC20H {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    (address contractOwner, uint256 tokenAmount, uint256 targetChain, address tokenRecipient) = abi.decode(\n      initPayload,\n      (address, uint256, uint256, address)\n    );\n    _setOwner(contractOwner);\n    /*\n     * @dev Mint token only if target chain matches current chain. Or if no target chain has been selected.\n     *      Goal of this is to restrict minting on Ethereum only for mainnet deployment.\n     */\n    if (block.chainid == targetChain || targetChain == 0) {\n      if (tokenAmount > 0) {\n        HolographERC20Interface(msg.sender).sourceMint(tokenRecipient, tokenAmount);\n      }\n    }\n    // run underlying initializer logic\n    return _init(initPayload);\n  }\n\n  /**\n   * @dev Temporarily placed to bypass bytecode conflicts\n   */\n  function isHLG() external pure returns (bool) {\n    return true;\n  }\n}\n"
    },
    "src/token/hToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/ERC20H.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\n\n/**\n * @title Holograph token (aka hToken), used to wrap and bridge native tokens across blockchains.\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph's Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract hToken is ERC20H {\n  /**\n   * @dev Sample fee for unwrapping.\n   */\n  uint16 private _feeBp; // 10000 == 100.00%\n\n  /**\n   * @dev List of supported Wrapped Tokens (equivalent), on current-chain.\n   */\n  mapping(address => bool) private _supportedWrappers;\n\n  /**\n   * @dev List of supported chains.\n   */\n  mapping(uint256 => bool) private _supportedChains;\n\n  /**\n   * @dev Event that is triggered when native token is converted into hToken.\n   */\n  event Deposit(address indexed from, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when ERC20 token is converted into hToken.\n   */\n  event TokenDeposit(address indexed token, address indexed from, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when hToken is converted into native token.\n   */\n  event Withdrawal(address indexed to, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when hToken is converted into ERC20 token.\n   */\n  event TokenWithdrawal(address indexed token, address indexed to, uint256 amount);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    (address contractOwner, uint16 fee) = abi.decode(initPayload, (address, uint16));\n    assembly {\n      /**\n       * @dev bytes32(uint256(keccak256('eip1967.Holograph.admin')) - 1)\n       */\n      sstore(0x3f106594dc74eeef980dae234cde8324dc2497b13d27a0c59e55bd2ca10a07c9, contractOwner)\n    }\n    _setOwner(contractOwner);\n    _feeBp = fee;\n    // run underlying initializer logic\n    return _init(initPayload);\n  }\n\n  /**\n   * @dev Send native token value, get back hToken equivalent.\n   * @param recipient Address of where to send the hToken(s) to.\n   */\n  function holographNativeToken(address recipient) external payable {\n    require(_supportedChains[block.chainid], \"hToken: unsupported chain\");\n    require(msg.value > 0, \"hToken: no value received\");\n    address sender = msgSender();\n    if (recipient == address(0)) {\n      recipient = sender;\n    }\n    payable(holographer()).transfer(msg.value);\n    HolographERC20Interface(holographer()).sourceMint(recipient, msg.value);\n    emit Deposit(sender, msg.value);\n  }\n\n  /**\n   * @dev Send hToken, get back native token value equivalent.\n   * @param recipient Address of where to send the native token(s) to.\n   */\n  function extractNativeToken(address payable recipient, uint256 amount) external {\n    require(_supportedChains[block.chainid], \"hToken: unsupported chain\");\n    address sender = msgSender();\n    require(ERC20(holographer()).balanceOf(sender) >= amount, \"hToken: not enough hToken(s)\");\n    require(holographer().balance >= amount, \"hToken: not enough native tokens\");\n    HolographERC20Interface(holographer()).sourceBurn(sender, amount);\n    uint256 fee = _feeBp == 0 ? 0 : (amount / 10000) * _feeBp;\n    if (fee > 0) {\n      HolographERC20Interface(HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury())\n        .sourceTransfer(recipient, fee);\n    }\n    amount = amount - fee;\n    HolographERC20Interface(holographer()).sourceTransfer(recipient, amount);\n    emit Withdrawal(recipient, amount);\n  }\n\n  function isSupportedChain(uint256 chain) external view returns (bool) {\n    return _supportedChains[chain];\n  }\n\n  function isSupportedWrapper(address token) external view returns (bool) {\n    return _supportedWrappers[token];\n  }\n\n  function updateSupportedWrapper(address token, bool supported) external onlyOwner {\n    _supportedWrappers[token] = supported;\n  }\n\n  function updateSupportedChain(uint256 chain, bool supported) external onlyOwner {\n    _supportedChains[chain] = supported;\n  }\n}\n"
    },
    "src/token/SampleERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/StrictERC20H.sol\";\n\nimport \"../interface/HolographERC20Interface.sol\";\n\n/**\n * @title Sample ERC-20 token that is bridgeable via Holograph\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract SampleERC20 is StrictERC20H {\n  /**\n   * @dev Just a dummy value for now to test transferring of data.\n   */\n  mapping(address => bytes32) private _walletSalts;\n\n  /**\n   * @dev Temporary implementation to suppress compiler state mutability warnings.\n   */\n  bool private _dummy;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    // do your own custom logic here\n    address contractOwner = abi.decode(initPayload, (address));\n    _setOwner(contractOwner);\n    // run underlying initializer logic\n    return _init(initPayload);\n  }\n\n  /**\n   * @dev Sample mint where anyone can mint any amounts of tokens.\n   */\n  function mint(address to, uint256 amount) external onlyHolographer onlyOwner {\n    HolographERC20Interface(holographer()).sourceMint(to, amount);\n    if (_walletSalts[to] == bytes32(0)) {\n      _walletSalts[to] = keccak256(\n        abi.encodePacked(to, amount, block.timestamp, block.number, blockhash(block.number - 1))\n      );\n    }\n  }\n\n  function bridgeIn(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address _to,\n    uint256 /* _amount*/,\n    bytes calldata _data\n  ) external override onlyHolographer returns (bool) {\n    bytes32 salt = abi.decode(_data, (bytes32));\n    _walletSalts[_to] = salt;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address _to,\n    uint256 /* _amount*/\n  ) external override onlyHolographer returns (bytes memory _data) {\n    _dummy = false;\n    _data = abi.encode(_walletSalts[_to]);\n  }\n}\n"
    },
    "src/token/SampleERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/StrictERC721H.sol\";\n\nimport \"../interface/HolographERC721Interface.sol\";\n\n/**\n * @title Sample ERC-721 Collection that is bridgeable via Holograph\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract SampleERC721 is StrictERC721H {\n  /**\n   * @dev Mapping of all token URIs.\n   */\n  mapping(uint256 => string) private _tokenURIs;\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev Temporary implementation to suppress compiler state mutability warnings.\n   */\n  bool private _dummy;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    // do your own custom logic here\n    address contractOwner = abi.decode(initPayload, (address));\n    _setOwner(contractOwner);\n    // run underlying initializer logic\n    return _init(initPayload);\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @dev Defaults the the Arweave URI\n   * @return string The URI.\n   */\n  function tokenURI(uint256 _tokenId) external view onlyHolographer returns (string memory) {\n    return _tokenURIs[_tokenId];\n  }\n\n  /**\n   * @dev Sample mint where anyone can mint specific token, with a custom URI\n   */\n  function mint(address to, uint224 tokenId, string calldata URI) external onlyHolographer onlyOwner {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    if (tokenId == 0) {\n      _currentTokenId += 1;\n      while (H721.exists(uint256(_currentTokenId)) || H721.burned(uint256(_currentTokenId))) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n    }\n    H721.sourceMint(to, tokenId);\n    uint256 id = H721.sourceGetChainPrepend() + uint256(tokenId);\n    _tokenURIs[id] = URI;\n  }\n\n  function bridgeIn(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external override onlyHolographer returns (bool) {\n    string memory URI = abi.decode(_data, (string));\n    _tokenURIs[_tokenId] = URI;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32 /* _chainId*/,\n    address /* _from*/,\n    address /* _to*/,\n    uint256 _tokenId\n  ) external override onlyHolographer returns (bytes memory _data) {\n    _dummy = false;\n    _data = abi.encode(_tokenURIs[_tokenId]);\n  }\n\n  function afterBurn(address /* _owner*/, uint256 _tokenId) external override onlyHolographer returns (bool) {\n    delete _tokenURIs[_tokenId];\n    return true;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc721a-upgradeable/=erc721a-upgradeable/",
      "forge-std/=lib/forge-std/src/"
    ]
  }
}