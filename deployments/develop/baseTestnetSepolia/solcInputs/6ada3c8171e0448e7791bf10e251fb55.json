{
  "language": "Solidity",
  "sources": {
    "src/abstract/Admin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract Admin {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.admin')) - 1)\n   */\n  bytes32 constant _adminSlot = 0x3f106594dc74eeef980dae234cde8324dc2497b13d27a0c59e55bd2ca10a07c9;\n\n  modifier onlyAdmin() {\n    require(msg.sender == getAdmin(), \"HOLOGRAPH: admin only function\");\n    _;\n  }\n\n  constructor() {}\n\n  function admin() public view returns (address) {\n    return getAdmin();\n  }\n\n  function getAdmin() public view returns (address adminAddress) {\n    assembly {\n      adminAddress := sload(_adminSlot)\n    }\n  }\n\n  function setAdmin(address adminAddress) public onlyAdmin {\n    assembly {\n      sstore(_adminSlot, adminAddress)\n    }\n  }\n\n  function adminCall(address target, bytes calldata data) external payable onlyAdmin {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/ContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/IContractMetadata.sol\";\n\n/**\n *  @title   Contract Metadata\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *           for you contract.\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\nabstract contract ContractMetadata is IContractMetadata {\n  /// @notice Returns the contract metadata URI.\n  string public override contractURI;\n\n  /**\n   *  @notice         Lets a contract admin set the URI for contract-level metadata.\n   *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\n   *                  See {_canSetContractURI}.\n   *                  Emits {ContractURIUpdated Event}.\n   *\n   *  @param _uri     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n   */\n  function setContractURI(string memory _uri) external override {\n    if (!_canSetContractURI()) {\n      revert(\"Not authorized\");\n    }\n\n    _setupContractURI(_uri);\n  }\n\n  /// @dev Lets a contract admin set the URI for contract-level metadata.\n  function _setupContractURI(string memory _uri) internal {\n    string memory prevURI = contractURI;\n    contractURI = _uri;\n\n    emit ContractURIUpdated(prevURI, _uri);\n  }\n\n  /// @dev Returns whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view virtual returns (bool);\n}\n"
    },
    "src/abstract/DelayedReveal.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/IDelayedReveal.sol\";\n\n/**\n *  @title   Delayed Reveal\n *  @notice  Thirdweb's `DelayedReveal` is a contract extension for base NFT contracts. It lets you create batches of\n *           'delayed-reveal' NFTs. You can learn more about the usage of delayed reveal NFTs here - https://blog.thirdweb.com/delayed-reveal-nfts\n */\n\nabstract contract DelayedReveal is IDelayedReveal {\n  /// @dev The contract doesn't have any url to be delayed revealed\n  error DelayedRevealNothingToReveal();\n\n  /// @dev The result of the returned an incorrect hash\n  error DelayedRevealIncorrectResultHash(bytes32 expected, bytes32 actual);\n\n  /// @dev Mapping from tokenId of a batch of tokens => to delayed reveal data.\n  mapping(uint256 => bytes) public encryptedData;\n\n  /// @dev Sets the delayed reveal data for a batchId.\n  function _setEncryptedData(uint256 _batchId, bytes memory _encryptedData) internal {\n    encryptedData[_batchId] = _encryptedData;\n  }\n\n  /**\n   *  @notice             Returns revealed URI for a batch of NFTs.\n   *  @dev                Reveal encrypted base URI for `_batchId` with caller/admin's `_key` used for encryption.\n   *                      Reverts if there's no encrypted URI for `_batchId`.\n   *                      See {encryptDecrypt}.\n   *\n   *  @param _batchId     ID of the batch for which URI is being revealed.\n   *  @param _key         Secure key used by caller/admin for encryption of baseURI.\n   *\n   *  @return revealedURI Decrypted base URI.\n   */\n  function getRevealURI(uint256 _batchId, bytes calldata _key) public view returns (string memory revealedURI) {\n    bytes memory data = encryptedData[_batchId];\n    if (data.length == 0) {\n      revert DelayedRevealNothingToReveal();\n    }\n\n    (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(data, (bytes, bytes32));\n\n    revealedURI = string(encryptDecrypt(encryptedURI, _key));\n\n    if (keccak256(abi.encodePacked(revealedURI, _key, block.chainid)) != provenanceHash) {\n      revert DelayedRevealIncorrectResultHash(\n        provenanceHash,\n        keccak256(abi.encodePacked(revealedURI, _key, block.chainid))\n      );\n    }\n  }\n\n  /**\n   *  @notice         Encrypt/decrypt data on chain.\n   *  @dev            Encrypt/decrypt given `data` with `key`. Uses inline assembly.\n   *                  See: https://ethereum.stackexchange.com/questions/69825/decrypt-message-on-chain\n   *\n   *  @param data     Bytes of data to encrypt/decrypt.\n   *  @param key      Secure key used by caller for encryption/decryption.\n   *\n   *  @return result  Output after encryption/decryption of given data.\n   */\n  function encryptDecrypt(bytes memory data, bytes calldata key) public pure override returns (bytes memory result) {\n    // Store data length on stack for later use\n    uint256 length = data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Set result to free memory pointer\n      result := mload(0x40)\n      // Increase free memory pointer by lenght + 32\n      mstore(0x40, add(add(result, length), 32))\n      // Set result length\n      mstore(result, length)\n    }\n\n    // Iterate over the data stepping by 32 bytes\n    for (uint256 i = 0; i < length; i += 32) {\n      // Generate hash of the key and offset\n      bytes32 hash = keccak256(abi.encodePacked(key, i));\n\n      bytes32 chunk;\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        // Read 32-bytes data chunk\n        chunk := mload(add(data, add(i, 32)))\n      }\n      // XOR the chunk with hash\n      chunk ^= hash;\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        // Write 32-byte encrypted chunk\n        mstore(add(result, add(i, 32)), chunk)\n      }\n    }\n  }\n\n  /**\n   *  @notice         Returns whether the relvant batch of NFTs is subject to a delayed reveal.\n   *  @dev            Returns `true` if `_batchId`'s base URI is encrypted.\n   *  @param _batchId ID of a batch of NFTs.\n   */\n  function isEncryptedBatch(uint256 _batchId) public view returns (bool) {\n    return encryptedData[_batchId].length > 0;\n  }\n}\n"
    },
    "src/abstract/ERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/Initializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/InitializableInterface.sol\";\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need for a constructor\n */\nabstract contract Initializable is InitializableInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.initialized')) - 1)\n   */\n  bytes32 constant _initializedSlot = 0x4e5f991bca30eca2d4643aaefa807e88f96a4a97398933d572a3c0d973004a01;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual returns (bytes4);\n\n  function _isInitialized() internal view returns (bool initialized) {\n    assembly {\n      initialized := sload(_initializedSlot)\n    }\n  }\n\n  function _setInitialized() internal {\n    assembly {\n      sstore(_initializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "src/abstract/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract NonReentrant {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.reentrant')) - 1)\n   */\n  bytes32 constant _reentrantSlot = 0x04b524dd539523930d3901481aa9455d7752b49add99e1647adb8b09a3137279;\n\n  modifier nonReentrant() {\n    require(getStatus() != 2, \"HOLOGRAPH: reentrant call\");\n    setStatus(2);\n    _;\n    setStatus(1);\n  }\n\n  constructor() {}\n\n  function getStatus() internal view returns (uint256 status) {\n    assembly {\n      status := sload(_reentrantSlot)\n    }\n  }\n\n  function setStatus(uint256 status) internal {\n    assembly {\n      sstore(_reentrantSlot, status)\n    }\n  }\n}\n"
    },
    "src/drops/interface/IDropsPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IDropsPriceOracle {\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount);\n}\n"
    },
    "src/drops/library/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "src/drops/library/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary MerkleProof {\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n   * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n   * hash matches the root of the tree. When processing the proof, the pairs\n   * of leafs & pre-images are assumed to be sorted.\n   *\n   * _Available since v4.4._\n   */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n      if (computedHash <= proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = _efficientHash(computedHash, proofElement);\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = _efficientHash(proofElement, computedHash);\n      }\n    }\n    return computedHash;\n  }\n\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "src/drops/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBaseTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\nimport {IQuoterV2} from \"../../interface/IQuoterV2.sol\";\n\ncontract DropsPriceOracleBaseTestnetSepolia is Admin, Initializable {\n  IQuoterV2 public quoterV2; // Immutable reference to the Quoter V2 interface\n\n  address public constant WETH9 = 0x4200000000000000000000000000000000000006; // WETH address on Base mainnet\n  address public constant USDC = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913; // USDC address on Base mainnet\n\n  // Set the pool fee to 0.05% (the lowest option)\n  uint24 public constant poolFee = 500;\n\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  function setQuoter(address _quoterV2Address) public onlyAdmin {\n    quoterV2 = IQuoterV2(_quoterV2Address);\n  }\n\n  /**\n   * @notice Converts USDC value to native gas token value in wei\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount in USDC (6 decimal places)\n   */\n  function convertUsdToWei(uint256 usdAmount) external returns (uint256 weiAmount) {\n    require(address(quoterV2) != address(0), \"Quoter not set\");\n\n    IQuoterV2.QuoteExactOutputSingleParams memory params = IQuoterV2.QuoteExactOutputSingleParams({\n      tokenIn: WETH9, // WETH address\n      tokenOut: USDC, // USDC address\n      fee: poolFee, // Representing 0.05% pool fee\n      amount: usdAmount, // USDC (USDC has 6 decimals)\n      sqrtPriceLimitX96: 0 // No specific price limit\n    });\n\n    (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate) = quoterV2\n      .quoteExactOutputSingle(params);\n\n    return amountIn; // this is the amount in wei to convert to the USDC value\n  }\n\n  function version() external pure returns (uint32) {\n    return 1;\n  }\n}\n"
    },
    "src/drops/struct/AddressMintDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return type of specific mint counts and details per address\nstruct AddressMintDetails {\n  /// Number of total mints from the given address\n  uint256 totalMints;\n  /// Number of presale mints from the given address\n  uint256 presaleMints;\n  /// Number of public mints from the given address\n  uint256 publicMints;\n}\n"
    },
    "src/drops/struct/SaleDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return value for sales details to use with front-ends\nstruct SaleDetails {\n  // Synthesized status variables for sale and presale\n  bool publicSaleActive;\n  bool presaleActive;\n  // Price for public sale\n  uint256 publicSalePrice;\n  // Timed sale actions for public sale\n  uint64 publicSaleStart;\n  uint64 publicSaleEnd;\n  // Timed sale actions for presale\n  uint64 presaleStart;\n  uint64 presaleEnd;\n  // Merkle root (includes address, quantity, and price data for each entry)\n  bytes32 presaleMerkleRoot;\n  // Limit public sale to a specific number of mints per wallet\n  uint256 maxSalePurchasePerAddress;\n  // Information about the rest of the supply\n  // Total that have been minted\n  uint256 totalMinted;\n  // The total supply available\n  uint256 maxSupply;\n}\n"
    },
    "src/drops/struct/SalesConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Sales states and configuration\n/// @dev Uses 3 storage slots\nstruct SalesConfiguration {\n  /// @dev Public sale price (max ether value > 1000 ether with this value)\n  uint104 publicSalePrice;\n  /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n  /// @dev Max purchase number per txn (90+32 = 122)\n  uint32 maxSalePurchasePerAddress;\n  /// @dev uint64 type allows for dates into 292 billion years\n  /// @notice Public sale start timestamp (136+64 = 186)\n  uint64 publicSaleStart;\n  /// @notice Public sale end timestamp (186+64 = 250)\n  uint64 publicSaleEnd;\n  /// @notice Presale start timestamp\n  /// @dev new storage slot\n  uint64 presaleStart;\n  /// @notice Presale end timestamp\n  uint64 presaleEnd;\n  /// @notice Presale merkle root\n  bytes32 presaleMerkleRoot;\n}\n"
    },
    "src/extension/BatchMintMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  @title   Batch-mint Metadata\n *  @notice  The `BatchMintMetadata` is a contract extension for any base NFT contract. It lets the smart contract\n *           using this extension set metadata for `n` number of NFTs all at once. This is enabled by storing a single\n *           base URI for a batch of `n` NFTs, where the metadata for each NFT in a relevant batch is `baseURI/tokenId`.\n */\n\ncontract BatchMintMetadata {\n  /// @dev Invalid index for batch\n  error BatchMintInvalidBatchId(uint256 index);\n\n  /// @dev Invalid token\n  error BatchMintInvalidTokenId(uint256 tokenId);\n\n  /// @dev Metadata frozen\n  error BatchMintMetadataFrozen(uint256 batchId);\n\n  /// @dev Largest tokenId of each batch of tokens with the same baseURI + 1 {ex: batchId 100 at position 0 includes tokens 0-99}\n  uint256[] private batchIds;\n\n  /// @dev Mapping from id of a batch of tokens => to base URI for the respective batch of tokens.\n  mapping(uint256 => string) private baseURI;\n\n  /// @dev Mapping from id of a batch of tokens => to whether the base URI for the respective batch of tokens is frozen.\n  mapping(uint256 => bool) public batchFrozen;\n\n  /// @dev This event emits when the metadata of all tokens are frozen.\n  /// While not currently supported by marketplaces, this event allows\n  /// future indexing if desired.\n  event MetadataFrozen();\n\n  // @dev This event emits when the metadata of a range of tokens is updated.\n  /// So that the third-party platforms such as NFT market could\n  /// timely update the images and related attributes of the NFTs.\n  event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n\n  /**\n   *  @notice         Returns the count of batches of NFTs.\n   *  @dev            Each batch of tokens has an in ID and an associated `baseURI`.\n   *                  See {batchIds}.\n   */\n  function getBaseURICount() public view returns (uint256) {\n    return batchIds.length;\n  }\n\n  /**\n   *  @notice         Returns the ID for the batch of tokens at the given index.\n   *  @dev            See {getBaseURICount}.\n   *  @param _index   Index of the desired batch in batchIds array.\n   */\n  function getBatchIdAtIndex(uint256 _index) public view returns (uint256) {\n    if (_index >= getBaseURICount()) {\n      revert BatchMintInvalidBatchId(_index);\n    }\n    return batchIds[_index];\n  }\n\n  /// @dev Returns the id for the batch of tokens the given tokenId belongs to.\n  function _getBatchId(uint256 _tokenId) internal view returns (uint256 batchId, uint256 index) {\n    uint256 numOfTokenBatches = getBaseURICount();\n    uint256[] memory indices = batchIds;\n\n    for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\n      if (_tokenId < indices[i]) {\n        index = i;\n        batchId = indices[i];\n\n        return (batchId, index);\n      }\n    }\n\n    revert BatchMintInvalidTokenId(_tokenId);\n  }\n\n  /// @dev Returns the baseURI for a token. The intended metadata URI for the token is baseURI + tokenId.\n  function _getBaseURI(uint256 _tokenId) internal view returns (string memory) {\n    uint256 numOfTokenBatches = getBaseURICount();\n    uint256[] memory indices = batchIds;\n\n    for (uint256 i = 0; i < numOfTokenBatches; i += 1) {\n      if (_tokenId < indices[i]) {\n        return baseURI[indices[i]];\n      }\n    }\n\n    revert BatchMintInvalidTokenId(_tokenId);\n  }\n\n  /// @dev returns the starting tokenId of a given batchId.\n  function _getBatchStartId(uint256 _batchID) internal view returns (uint256) {\n    uint256 numOfTokenBatches = getBaseURICount();\n    uint256[] memory indices = batchIds;\n\n    for (uint256 i = 0; i < numOfTokenBatches; i++) {\n      if (_batchID == indices[i]) {\n        if (i > 0) {\n          return indices[i - 1];\n        }\n        return 0;\n      }\n    }\n\n    revert BatchMintInvalidBatchId(_batchID);\n  }\n\n  /// @dev Sets the base URI for the batch of tokens with the given batchId.\n  function _setBaseURI(uint256 _batchId, string memory _baseURI) internal {\n    if (batchFrozen[_batchId]) {\n      revert BatchMintMetadataFrozen(_batchId);\n    }\n    baseURI[_batchId] = _baseURI;\n    emit BatchMetadataUpdate(_getBatchStartId(_batchId), _batchId);\n  }\n\n  /// @dev Freezes the base URI for the batch of tokens with the given batchId.\n  function _freezeBaseURI(uint256 _batchId) internal {\n    string memory baseURIForBatch = baseURI[_batchId];\n    if (bytes(baseURIForBatch).length == 0) {\n      revert BatchMintInvalidBatchId(_batchId);\n    }\n    batchFrozen[_batchId] = true;\n    emit MetadataFrozen();\n  }\n\n  /// @dev Mints a batch of tokenIds and associates a common baseURI to all those Ids.\n  function _batchMintMetadata(\n    uint256 _startId,\n    uint256 _amountToMint,\n    string memory _baseURIForTokens\n  ) internal returns (uint256 nextTokenIdToMint, uint256 batchId) {\n    batchId = _startId + _amountToMint;\n    nextTokenIdToMint = batchId;\n\n    batchIds.push(batchId);\n\n    baseURI[batchId] = _baseURIForTokens;\n  }\n}\n"
    },
    "src/extension/InitializableLazyMint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/LazyMintInitializableInterface.sol\";\nimport \"./LazyMint.sol\";\n\n/**\n * @title Initializable Lazy Mint\n * @author https://github.com/holographxyz\n * @notice Allow to initialize a default nextTokenIdToLazyMint\n * @dev This allows to synchronize the nextTokenIdToLazyMint with a custom tokenId management\n */\nabstract contract InitializableLazyMint is LazyMint, LazyMintInitializableInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.lazyMintInitialized')) - 1)\n   */\n  bytes32 constant _lazyMintInitializedSlot = 0x48d0e47abf92fdd55242caeea30ef9b630788bb50b5c07884bc96bb0c942c6c1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function initLazyMint() external virtual returns (uint256);\n\n  function _isLazyMintInitialized() internal view returns (bool lazyMintInitialized) {\n    assembly {\n      lazyMintInitialized := sload(_lazyMintInitializedSlot)\n    }\n  }\n\n  function _setLazyMintInitialized() internal {\n    assembly {\n      sstore(_lazyMintInitializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "src/extension/LazyMint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/ILazyMint.sol\";\nimport \"./BatchMintMetadata.sol\";\n\n/**\n *  The `LazyMint` is a contract extension for any base NFT contract. It lets you 'lazy mint' any number of NFTs\n *  at once. Here, 'lazy mint' means defining the metadata for particular tokenIds of your NFT contract, without actually\n *  minting a non-zero balance of NFTs of those tokenIds.\n */\n\nabstract contract LazyMint is ILazyMint, BatchMintMetadata {\n  /// @dev The sender is not authorized to perform the action\n  error LazyMintUnauthorized();\n  error LazyMintInvalidAmount();\n\n  /// @notice The tokenId assigned to the next new NFT to be lazy minted.\n  uint256 internal nextTokenIdToLazyMint;\n\n  /**\n   *  @notice                  Lets an authorized address lazy mint a given amount of NFTs.\n   *\n   *  @param _amount           The number of NFTs to lazy mint.\n   *  @param _baseURIForTokens The base URI for the 'n' number of NFTs being lazy minted, where the metadata for each\n   *                           of those NFTs is `${baseURIForTokens}/${tokenId}`.\n   *  @param _data             Additional bytes data to be used at the discretion of the consumer of the contract.\n   *  @return batchId          A unique integer identifier for the batch of NFTs lazy minted together.\n   */\n  function lazyMint(\n    uint256 _amount,\n    string calldata _baseURIForTokens,\n    bytes calldata _data\n  ) public virtual override returns (uint256 batchId) {\n    if (!_canLazyMint()) {\n      revert LazyMintUnauthorized();\n    }\n\n    if (_amount == 0) {\n      revert LazyMintInvalidAmount();\n    }\n\n    uint256 startId = nextTokenIdToLazyMint;\n\n    (nextTokenIdToLazyMint, batchId) = _batchMintMetadata(startId, _amount, _baseURIForTokens);\n\n    emit TokensLazyMinted(startId, startId + _amount - 1, _baseURIForTokens, _data);\n\n    return batchId;\n  }\n\n  /// @dev Returns whether lazy minting can be performed in the given execution context.\n  function _canLazyMint() internal view virtual returns (bool);\n}\n"
    },
    "src/interface/CollectionURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CollectionURI {\n  function contractURI() external view returns (string memory);\n}\n"
    },
    "src/interface/ERC165.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/interface/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n/* is ERC165 */\ninterface ERC721 {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param _owner An address for whom to query the balance\n  /// @return The number of NFTs owned by `_owner`, possibly zero\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param _tokenId The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf(uint256 _tokenId) external view returns (address);\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `_to` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  /// @param data Additional data with no specified format, sent in call to `_to`\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param _approved The new approved NFT controller\n  /// @param _tokenId The NFT to approve\n  function approve(address _approved, uint256 _tokenId) external payable;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param _operator Address to add to the set of authorized operators\n  /// @param _approved True if the operator is approved, false to revoke approval\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `_tokenId` is not a valid NFT.\n  /// @param _tokenId The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved(uint256 _tokenId) external view returns (address);\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param _owner The address that owns the NFTs\n  /// @param _operator The address that acts on behalf of the owner\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "src/interface/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n/* is ERC721 */\ninterface ERC721Enumerable {\n  /// @notice Count NFTs tracked by this contract\n  /// @return A count of valid NFTs tracked by this contract, where each one of\n  ///  them has an assigned and queryable owner not equal to the zero address\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Enumerate valid NFTs\n  /// @dev Throws if `_index` >= `totalSupply()`.\n  /// @param _index A counter less than `totalSupply()`\n  /// @return The token identifier for the `_index`th NFT,\n  ///  (sort order not specified)\n  function tokenByIndex(uint256 _index) external view returns (uint256);\n\n  /// @notice Enumerate NFTs assigned to an owner\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n  ///  `_owner` is the zero address, representing invalid NFTs.\n  /// @param _owner An address where we are interested in NFTs owned by them\n  /// @param _index A counter less than `balanceOf(_owner)`\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n  ///   (sort order not specified)\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "src/interface/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface ERC721Metadata {\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n\n  /// @notice An abbreviated name for NFTs in this contract\n  function symbol() external view returns (string memory _symbol);\n\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n  ///  Metadata JSON Schema\".\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/interface/ERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n  /// @notice Handle the receipt of an NFT\n  /// @dev The ERC721 smart contract calls this function on the recipient\n  ///  after a `transfer`. This function MAY throw to revert and reject the\n  ///  transfer. Return of other than the magic value MUST result in the\n  ///  transaction being reverted.\n  ///  Note: the contract address is always the message sender.\n  /// @param _operator The address which called `safeTransferFrom` function\n  /// @param _from The address which previously owned the token\n  /// @param _tokenId The NFT identifier which is being transferred\n  /// @param _data Additional data with no specified format\n  /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  ///  unless throwing\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4);\n}\n"
    },
    "src/interface/Holographable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Holographable {\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external returns (bytes4);\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external returns (bytes4 selector, bytes memory data);\n}\n"
    },
    "src/interface/HolographERC721Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./CollectionURI.sol\";\nimport \"./ERC165.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\nimport \"./ERC721TokenReceiver.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographERC721Interface is\n  ERC165,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Metadata,\n  ERC721TokenReceiver,\n  CollectionURI,\n  Holographable\n{\n  function approve(address to, uint256 tokenId) external payable;\n\n  function burn(uint256 tokenId) external;\n\n  function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n  function setApprovalForAll(address to, bool approved) external;\n\n  function sourceBurn(uint256 tokenId) external;\n\n  function sourceMint(address to, uint224 tokenId) external;\n\n  function sourceGetChainPrepend() external view returns (uint256);\n\n  function sourceTransfer(address to, uint256 tokenId) external;\n\n  function sourceExternalCall(address target, bytes calldata data) external;\n\n  function transfer(address to, uint256 tokenId) external payable;\n\n  function contractURI() external view returns (string memory);\n\n  function getApproved(uint256 tokenId) external view returns (address);\n\n  function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function burned(uint256 tokenId) external view returns (bool);\n\n  function decimals() external pure returns (uint256);\n\n  function exists(uint256 tokenId) external view returns (bool);\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256);\n\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "src/interface/HolographerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographerInterface {\n  function getContractType() external view returns (bytes32 contractType);\n\n  function getDeploymentBlock() external view returns (uint256 deploymentBlock);\n\n  function getHolograph() external view returns (address holograph);\n\n  function getHolographEnforcer() external view returns (address);\n\n  function getOriginChain() external view returns (uint32 originChain);\n\n  function getSourceContract() external view returns (address sourceContract);\n}\n"
    },
    "src/interface/HolographInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Holograph Protocol\n * @author https://github.com/holographxyz\n * @notice This is the primary Holograph Protocol smart contract\n * @dev This contract stores a reference to all the primary modules and variables of the protocol\n */\ninterface HolographInterface {\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge);\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external;\n\n  /**\n   * @notice Get the chain ID that the Protocol was deployed on\n   * @dev Useful for checking if/when a hard fork occurs\n   */\n  function getChainId() external view returns (uint256 chainId);\n\n  /**\n   * @notice Update the chain ID\n   * @dev Useful for updating once a hard fork has been mitigated\n   * @param chainId EVM chain ID to use\n   */\n  function setChainId(uint256 chainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory);\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external;\n\n  /**\n   * @notice Get the Holograph chain Id\n   * @dev Holograph uses an internal chain id mapping\n   */\n  function getHolographChainId() external view returns (uint32 holographChainId);\n\n  /**\n   * @notice Update the Holograph chain ID\n   * @dev Useful for updating once a hard fork was mitigated\n   * @param holographChainId Holograph chain ID to use\n   */\n  function setHolographChainId(uint32 holographChainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces);\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external;\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator);\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n\n  /**\n   * @notice Get the Holograph Treasury module\n   * @dev All of the Holograph Protocol assets are stored and managed by this module\n   */\n  function getTreasury() external view returns (address treasury);\n\n  /**\n   * @notice Update the Holograph Treasury module address\n   * @param treasury address of the Holograph Treasury smart contract to use\n   */\n  function setTreasury(address treasury) external;\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken);\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external;\n}\n"
    },
    "src/interface/HolographTreasuryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographTreasuryInterface {\n  /**\n   * @notice Update the Holograph Mint Fee\n   * @param fee new fee to charge for minting holographable assets\n   */\n  function setHolographMintFee(uint256 fee) external;\n\n  /**\n   * @notice Withdraws native tokens from the contract\n   * @dev Can only be called by the admin\n   */\n  function withdraw() external;\n\n  /**\n   * @notice Withdraws native tokens from the contract to a specified address\n   * @dev Can only be called by the admin\n   * @param recipient The address to send the withdrawn funds to\n   */\n  function withdrawTo(address payable recipient) external;\n\n  /**\n   * @notice Get the Holograph Mint Fee\n   * @dev This fee is charged to mint holographable assets\n   * @return The current holograph mint fee\n   */\n  function getHolographMintFee() external view returns (uint256);\n}\n"
    },
    "src/interface/IContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *  for you contract.\n *\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\ninterface IContractMetadata {\n  /// @dev Returns the metadata URI of the contract.\n  function contractURI() external view returns (string memory);\n\n  /**\n   *  @dev Sets contract URI for the storefront-level metadata of the contract.\n   *       Only module admin can call this function.\n   */\n  function setContractURI(string calldata _uri) external;\n\n  /// @dev Emitted when the contract URI is updated.\n  event ContractURIUpdated(string prevURI, string newURI);\n}\n"
    },
    "src/interface/ICustomERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {SaleDetails} from \"../drops/struct/SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface ICustomERC721 {\n  // Access errors\n\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Presale is inactive\n  error Presale_Inactive();\n  /// @notice Presale merkle root is invalid\n  error Presale_MerkleNotApproved();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Too many presale for address\n  error Presale_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n  /// @notice The countdown has been completed\n  error Purchase_CountdownCompleted();\n\n  // Init errors\n  error CountdownEndMustBeDivisibleByMintTimeCost(uint128 countdownEnd, uint128 mintTimeCost);\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when an nfs is minted\n  /// @param recipient address that the nft was minted to\n  /// @param tokenId id of the minted nft\n  /// @param id id of the minted nft with chain id prefix\n  event NFTMinted(address indexed recipient, uint256 indexed tokenId, uint256 id);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  /// @param publicSaleStart unix timestamp when the public sale starts\n  /// @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n  /// @param presaleStart unix timestamp when the presale starts\n  /// @param presaleEnd unix timestamp when the presale ends\n  /// @param presaleMerkleRoot merkle root for the presale information\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n  /// @param quantity to purchase\n  /// @param maxQuantity can purchase (verified by merkle root)\n  /// @param pricePerToken price per token allowed (verified by merkle root)\n  /// @param merkleProof input for merkle proof leaf verified by merkle root\n  /// @return first minted token ID\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] memory merkleProof\n  ) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (SaleDetails memory);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @notice This is an admin mint function to mint a quantity to a specific address\n  /// @param to address to mint to\n  /// @param quantity quantity to mint\n  /// @return the id of the first minted NFT\n  function adminMint(address to, uint256 quantity) external returns (uint256);\n\n  /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n  /// @param to list of addresses to mint an NFT each to\n  /// @return the id of the first minted NFT\n  function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/interface/IDelayedReveal.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `DelayedReveal` is a contract extension for base NFT contracts. It lets you create batches of\n *  'delayed-reveal' NFTs. You can learn more about the usage of delayed reveal NFTs here - https://blog.thirdweb.com/delayed-reveal-nfts\n */\n\ninterface IDelayedReveal {\n  /// @dev Emitted when tokens are revealed.\n  event TokenURIRevealed(uint256 indexed index, string revealedURI);\n\n  /**\n   *  @notice Reveals a batch of delayed reveal NFTs.\n   *\n   *  @param identifier The ID for the batch of delayed-reveal NFTs to reveal.\n   *\n   *  @param key        The key with which the base URI for the relevant batch of NFTs was encrypted.\n   */\n  function reveal(uint256 identifier, bytes calldata key) external returns (string memory revealedURI);\n\n  /**\n   *  @notice Performs XOR encryption/decryption.\n   *\n   *  @param data The data to encrypt. In the case of delayed-reveal NFTs, this is the \"revealed\" state\n   *              base URI of the relevant batch of NFTs.\n   *\n   *  @param key  The key with which to encrypt data\n   */\n  function encryptDecrypt(bytes memory data, bytes calldata key) external pure returns (bytes memory result);\n}\n"
    },
    "src/interface/ILazyMint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `LazyMint` is a contract extension for any base NFT contract. It lets you 'lazy mint' any number of NFTs\n *  at once. Here, 'lazy mint' means defining the metadata for particular tokenIds of your NFT contract, without actually\n *  minting a non-zero balance of NFTs of those tokenIds.\n */\n\ninterface ILazyMint {\n  /// @dev Emitted when tokens are lazy minted.\n  event TokensLazyMinted(uint256 indexed startTokenId, uint256 endTokenId, string baseURI, bytes encryptedBaseURI);\n\n  /**\n   *  @notice Lazy mints a given amount of NFTs.\n   *\n   *  @param amount           The number of NFTs to lazy mint.\n   *\n   *  @param baseURIForTokens The base URI for the 'n' number of NFTs being lazy minted, where the metadata for each\n   *                          of those NFTs is `${baseURIForTokens}/${tokenId}`.\n   *\n   *  @param extraData        Additional bytes data to be used at the discretion of the consumer of the contract.\n   *\n   *  @return batchId         A unique integer identifier for the batch of NFTs lazy minted together.\n   */\n  function lazyMint(\n    uint256 amount,\n    string calldata baseURIForTokens,\n    bytes calldata extraData\n  ) external returns (uint256 batchId);\n}\n"
    },
    "src/interface/InitializableInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need of a constructor\n */\ninterface InitializableInterface {\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external returns (bytes4);\n}\n"
    },
    "src/interface/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.13;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n  // NOTE: At the moment we are only implementing the quoteExactOutputSingle function\n  // /// @notice Returns the amount out received for a given exact input swap without executing the swap\n  // /// @param path The path of the swap, i.e. each token pair and the pool fee\n  // /// @param amountIn The amount of the first token to swap\n  // /// @return amountOut The amount of the last token that would be received\n  // /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n  // /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n  // /// @return gasEstimate The estimate of the gas that the swap consumes\n  // function quoteExactInput(\n  //   bytes memory path,\n  //   uint256 amountIn\n  // )\n  //   external\n  //   returns (\n  //     uint256 amountOut,\n  //     uint160[] memory sqrtPriceX96AfterList,\n  //     uint32[] memory initializedTicksCrossedList,\n  //     uint256 gasEstimate\n  //   );\n\n  // struct QuoteExactInputSingleParams {\n  //   address tokenIn;\n  //   address tokenOut;\n  //   uint256 amountIn;\n  //   uint24 fee;\n  //   uint160 sqrtPriceLimitX96;\n  // }\n\n  // /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n  // /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n  // /// tokenIn The token being swapped in\n  // /// tokenOut The token being swapped out\n  // /// fee The fee of the token pool to consider for the pair\n  // /// amountIn The desired input amount\n  // /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  // /// @return amountOut The amount of `tokenOut` that would be received\n  // /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n  // /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n  // /// @return gasEstimate The estimate of the gas that the swap consumes\n  // function quoteExactInputSingle(\n  //   QuoteExactInputSingleParams memory params\n  // )\n  //   external\n  //   returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);\n\n  // /// @notice Returns the amount in required for a given exact output swap without executing the swap\n  // /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n  // /// @param amountOut The amount of the last token to receive\n  // /// @return amountIn The amount of first token required to be paid\n  // /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n  // /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n  // /// @return gasEstimate The estimate of the gas that the swap consumes\n  // function quoteExactOutput(\n  //   bytes memory path,\n  //   uint256 amountOut\n  // )\n  //   external\n  //   returns (\n  //     uint256 amountIn,\n  //     uint160[] memory sqrtPriceX96AfterList,\n  //     uint32[] memory initializedTicksCrossedList,\n  //     uint256 gasEstimate\n  //   );\n\n  struct QuoteExactOutputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    uint24 fee;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n  /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n  /// tokenIn The token being swapped in\n  /// tokenOut The token being swapped out\n  /// fee The fee of the token pool to consider for the pair\n  /// amountOut The desired output amount\n  /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n  /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n  /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n  /// @return gasEstimate The estimate of the gas that the swap consumes\n  function quoteExactOutputSingle(\n    QuoteExactOutputSingleParams memory params\n  ) external returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);\n}\n"
    },
    "src/interface/LazyMintInitializableInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Initializable Lazy Mint\n * @author https://github.com/holographxyz\n * @notice Allow to initialize a default nextTokenIdToLazyMint\n * @dev This allows to synchronize the nextTokenIdToLazyMint with a custom tokenId management\n */\ninterface LazyMintInitializableInterface {\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function initLazyMint() external returns (uint256);\n}\n"
    },
    "src/struct/CustomERC721Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice General configuration for NFT Minting and bookkeeping\nstruct CustomERC721Configuration {\n  /// @dev The time to subtract from the countdownEnd on each mint\n  uint64 mintTimeCost;\n  /// @dev The current countdown time\n  uint96 countdownEnd;\n  /// @dev The initial countdown end time\n  uint96 initialCountdownEnd;\n  /// @dev Royalty amount in bps (uint224+16 = 240)\n  uint160 royaltyBPS;\n  /// @dev Funds recipient for sale (new slot, uint160)\n  address payable fundsRecipient;\n}\n"
    },
    "src/struct/CustomERC721Initializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {SalesConfiguration} from \"../drops/struct/SalesConfiguration.sol\";\n\n/// @param initialOwner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\n/// @param fundsRecipient Wallet/user that receives funds from sale\n/// @param mintTimeCost The time to subtract from the countdownEnd on each mint\n/// @param countdownEnd The countdown end time\n/// @param royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\n/// @param salesConfiguration The initial SalesConfiguration\nstruct CustomERC721Initializer {\n  uint64 mintTimeCost;\n  uint96 countdownEnd;\n  address initialOwner;\n  address payable fundsRecipient;\n  string contractURI;\n  uint16 royaltyBPS;\n  SalesConfiguration salesConfiguration;\n}\n"
    },
    "src/token/CustomERC721.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../abstract/NonReentrant.sol\";\nimport {DelayedReveal} from \"../abstract/DelayedReveal.sol\";\nimport {ContractMetadata} from \"../abstract/ContractMetadata.sol\";\n\nimport {HolographERC721Interface} from \"../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../interface/HolographInterface.sol\";\nimport {ICustomERC721} from \"../interface/ICustomERC721.sol\";\nimport {IDropsPriceOracle} from \"../drops/interface/IDropsPriceOracle.sol\";\nimport {HolographTreasuryInterface} from \"../interface/HolographTreasuryInterface.sol\";\n\nimport {InitializableLazyMint} from \"../extension/InitializableLazyMint.sol\";\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CustomERC721Configuration} from \"../struct/CustomERC721Configuration.sol\";\nimport {CustomERC721Initializer} from \"../struct/CustomERC721Initializer.sol\";\nimport {SaleDetails} from \"../drops/struct/SaleDetails.sol\";\nimport {SalesConfiguration} from \"../drops/struct/SalesConfiguration.sol\";\n\nimport {Address} from \"../drops/library/Address.sol\";\nimport {MerkleProof} from \"../drops/library/MerkleProof.sol\";\nimport {Strings} from \"./../drops/library/Strings.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified the source code for them.\n */\ncontract CustomERC721 is NonReentrant, ContractMetadata, InitializableLazyMint, DelayedReveal, ERC721H, ICustomERC721 {\n  using Strings for uint256;\n\n  /**\n   * CONTRACT VARIABLES\n   * all variables, without custom storage slots, are defined here\n   */\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Configuration for NFT minting contract storage\n   */\n  CustomERC721Configuration public config;\n\n  /**\n   * @notice Sales configuration\n   */\n  SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public presaleMintsByAddress;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /**\n   * CUSTOM ERRORS\n   */\n\n  /**\n   * MODIFIERS\n   */\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    // NOTE: NEED TO DECIDE IF WE WANT TO RESTRICT MINTING UNDER CERTAIN CONDITIONS\n    _;\n  }\n\n  /**\n   * @notice Presale active\n   */\n  modifier onlyPresaleActive() {\n    if (!_presaleActive()) {\n      revert Presale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * CONTRACT INITIALIZERS\n   */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    // to enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    CustomERC721Initializer memory initializer = abi.decode(initPayload, (CustomERC721Initializer));\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // Setup the contract URI\n    _setupContractURI(initializer.contractURI);\n\n    if (initializer.countdownEnd % initializer.mintTimeCost != 0) {\n      revert CountdownEndMustBeDivisibleByMintTimeCost(initializer.countdownEnd, initializer.mintTimeCost);\n    }\n\n    // Setup config variables\n    config = CustomERC721Configuration({\n      mintTimeCost: initializer.mintTimeCost,\n      countdownEnd: initializer.countdownEnd,\n      initialCountdownEnd: initializer.countdownEnd,\n      royaltyBPS: initializer.royaltyBPS,\n      fundsRecipient: initializer.fundsRecipient\n    });\n\n    salesConfig = initializer.salesConfiguration;\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function initLazyMint() external override onlyOwner returns (uint256 chainPrepend) {\n    require(!_isLazyMintInitialized(), \"HOLOGRAPH: lazy mint already initialized\");\n\n    // Setup the lazy minting\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    chainPrepend = H721.sourceGetChainPrepend() + 1;\n    nextTokenIdToLazyMint = chainPrepend;\n\n    _setLazyMintInitialized();\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * static\n   */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version of the contract\n   */\n  function version() external pure returns (uint32) {\n    return 1;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(ICustomERC721).interfaceId;\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * dynamic\n   */\n\n  function owner() external view override(ERC721H, ICustomERC721) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  function maxSupply() public view returns (uint256) {\n    return config.initialCountdownEnd / config.mintTimeCost;\n  }\n\n  /**\n   * @notice Sale details\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (SaleDetails memory) {\n    return\n      SaleDetails({\n        publicSaleActive: _publicSaleActive(),\n        presaleActive: _presaleActive(),\n        publicSalePrice: salesConfig.publicSalePrice,\n        publicSaleStart: salesConfig.publicSaleStart,\n        publicSaleEnd: salesConfig.publicSaleEnd,\n        presaleStart: salesConfig.presaleStart,\n        presaleEnd: salesConfig.presaleEnd,\n        presaleMerkleRoot: salesConfig.presaleMerkleRoot,\n        totalMinted: _currentTokenId,\n        maxSupply: maxSupply(),\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress\n      });\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD and is controlled by the treasury\n  /// @dev Gets the flat Holograph protocol fee for a single mint in USD\n  function getHolographFeeFromTreasury() public view returns (uint256) {\n    address payable treasuryProxyAddress = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    HolographTreasuryInterface treasury = HolographTreasuryInterface(treasuryProxyAddress);\n    return treasury.getHolographMintFee();\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD\n  /// @dev Gets the Holograph protocol fee for amount of mints in USD\n  function getHolographFeeUsd(uint256 quantity) public view returns (uint256 fee) {\n    fee = getHolographFeeFromTreasury() * quantity;\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in wei after conversion\n  /// @dev Gets the Holograph protocol fee for amount of mints in wei\n  function getHolographFeeWei(uint256 quantity) public view returns (uint256) {\n    return _usdToWei(getHolographFeeFromTreasury() * quantity);\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: presaleMintsByAddress[minter],\n        publicMints: totalMintsByAddress[minter] - presaleMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @dev Returns the URI for a given tokenId.\n   * @param _tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 _tokenId) public view returns (string memory) {\n    // (uint256 batchId, ) = _getBatchId(_tokenId);\n    string memory batchUri = _getBaseURI(_tokenId);\n\n    // if (isEncryptedBatch(batchId)) {\n    //   return string(abi.encodePacked(batchUri, \"0\"));\n    // } else {\n    //   return string(abi.encodePacked(batchUri, _tokenId.toString()));\n    // }\n\n    return string(abi.encodePacked(batchUri, _tokenId.toString()));\n  }\n\n  /**\n   * @dev Returns the base URI for a given tokenId. It return the base URI corresponding to the batch the tokenId belongs to.\n   * @param _tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function baseURI(uint256 _tokenId) public view returns (string memory) {\n    return _getBaseURI(_tokenId);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * available to all\n   */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            Delayed Reveal Logic                            */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   *  @notice       Lets an authorized address reveal a batch of delayed reveal NFTs.\n   *\n   *  @param _index The ID for the batch of delayed-reveal NFTs to reveal.\n   *  @param _key   The key with which the base URI for the relevant batch of NFTs was encrypted.\n   */\n  function reveal(uint256 _index, bytes calldata _key) public virtual override returns (string memory revealedURI) {\n    require(_canReveal(), \"Not authorized\");\n\n    uint256 batchId = getBatchIdAtIndex(_index);\n    revealedURI = getRevealURI(batchId, _key);\n\n    _setEncryptedData(batchId, \"\");\n    _setBaseURI(batchId, revealedURI);\n\n    emit TokenURIRevealed(_index, revealedURI);\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n    uint256 holographMintFeeUsd = getHolographFeeFromTreasury();\n    uint256 holographMintFeeWei = _usdToWei(holographMintFeeUsd);\n\n    if (msg.value < (salePrice + holographMintFeeWei) * quantity) {\n      // The error will display what the correct price should be\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice + holographMintFeeUsd) * quantity);\n    }\n\n    if (config.countdownEnd < config.mintTimeCost * quantity) {\n      revert Purchase_CountdownCompleted();\n    }\n\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity - presaleMintsByAddress[msgSender()] >\n      salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * @notice Merkle-tree based presale purchase function\n   * @param quantity quantity to purchase\n   * @param maxQuantity max quantity that can be purchased via merkle proof #\n   * @param pricePerToken price that each token is purchased at\n   * @param merkleProof proof for presale mint\n   */\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] calldata merkleProof\n  ) external payable nonReentrant canMintTokens(quantity) onlyPresaleActive returns (uint256) {\n    if (\n      !// address, uint256, uint256\n      MerkleProof.verify(\n        merkleProof,\n        salesConfig.presaleMerkleRoot,\n        keccak256(abi.encode(msgSender(), maxQuantity, pricePerToken))\n      )\n    ) {\n      revert Presale_MerkleNotApproved();\n    }\n\n    uint256 weiPricePerToken = _usdToWei(pricePerToken);\n    if (msg.value < weiPricePerToken * quantity) {\n      revert Purchase_WrongPrice(pricePerToken * quantity);\n    }\n    uint256 remainder = msg.value - (weiPricePerToken * quantity);\n\n    presaleMintsByAddress[msgSender()] += quantity;\n    if (presaleMintsByAddress[msgSender()] > maxQuantity) {\n      revert Presale_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: weiPricePerToken,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * admin only\n   */\n\n  /**\n   *  We override the `lazyMint` function, and use the `_data` parameter for storing encrypted metadata\n   *  for 'delayed reveal' NFTs.\n   */\n  function lazyMint(\n    uint256 _amount,\n    string calldata _baseURIForTokens,\n    bytes calldata _data\n  ) public override returns (uint256 batchId) {\n    if (_data.length > 0) {\n      (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(_data, (bytes, bytes32));\n      if (encryptedURI.length != 0 && provenanceHash != \"\") {\n        _setEncryptedData(nextTokenIdToLazyMint + _amount, _data);\n      }\n    }\n\n    return super.lazyMint(_amount, _baseURIForTokens, _data);\n  }\n\n  /**\n   * @notice Admin mint tokens to a recipient for free\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function adminMint(address recipient, uint256 quantity) external onlyOwner canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev Mints multiple editions to the given list of addresses.\n   * @dev TODO: Double check if we need to use arrays for encryptedBaseUris and dataArray\n   * @param recipients list of addresses to send the newly minted editions to\n   */\n  function adminMintAirdrop(\n    address[] calldata recipients\n  ) external onlyOwner canMintTokens(recipients.length) returns (uint256) {\n    unchecked {\n      for (uint256 i = 0; i != recipients.length; i++) {\n        _mintNFTs(recipients[i], 1);\n      }\n    }\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   * @param publicSaleStart unix timestamp when the public sale starts\n   * @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n   * @param presaleStart unix timestamp when the presale starts\n   * @param presaleEnd unix timestamp when the presale ends\n   * @param presaleMerkleRoot merkle root for the presale information\n   */\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n    salesConfig.publicSaleStart = publicSaleStart;\n    salesConfig.publicSaleEnd = publicSaleEnd;\n    salesConfig.presaleStart = presaleStart;\n    salesConfig.presaleEnd = presaleEnd;\n    salesConfig.presaleMerkleRoot = presaleMerkleRoot;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    config.fundsRecipient = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (config.fundsRecipient == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != config.fundsRecipient && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = config.fundsRecipient.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, config.fundsRecipient, funds);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * non state changing\n   */\n\n  function getMintTimeCost() external view returns (uint64) {\n    return config.mintTimeCost;\n  }\n\n  function getCountdownEnd() external view returns (uint96) {\n    return config.countdownEnd;\n  }\n\n  function getInitialCountdownEnd() external view returns (uint96) {\n    return config.initialCountdownEnd;\n  }\n\n  function _presaleActive() internal view returns (bool) {\n    return salesConfig.presaleStart <= block.timestamp && salesConfig.presaleEnd > block.timestamp;\n  }\n\n  function _publicSaleActive() internal view returns (bool) {\n    return salesConfig.publicSaleStart <= block.timestamp && salesConfig.publicSaleEnd > block.timestamp;\n  }\n\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /// @dev Returns whether lazy minting can be done in the given execution context.\n  function _canLazyMint() internal view override returns (bool) {\n    return ((msgSender() == _getOwner()) && _publicSaleActive()) || _presaleActive();\n  }\n\n  /// @dev Checks whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view override returns (bool) {\n    return msgSender() == _getOwner();\n  }\n\n  // TODO: We need to recreate these functions in a way that is compatible with HolographERC721 internal indexes\n  // Please double check this logic\n  /**\n   * Returns the total amount of tokens minted in the contract.\n   */\n  function totalMinted() external view returns (uint256) {\n    return _currentTokenId;\n  }\n\n  /// @dev The tokenId of the next NFT that will be minted / lazy minted.\n  function nextTokenIdToMint() external view returns (uint256) {\n    return nextTokenIdToLazyMint;\n  }\n\n  /// @dev The next token ID of the NFT that can be claimed.\n  function nextTokenIdToClaim() external view returns (uint256) {\n    return _currentTokenId + 1;\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * state changing\n   */\n\n  /// @dev Checks whether NFTs can be revealed in the given execution context.\n  function _canReveal() internal view virtual returns (bool) {\n    return msgSender() == _getOwner();\n  }\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n\n    // Subtract the time cost from the countdown\n    config.countdownEnd -= uint96(config.mintTimeCost * quantity);\n\n    for (uint256 i = 0; i != quantity; ) {\n      unchecked {\n        _currentTokenId += 1;\n      }\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        unchecked {\n          _currentTokenId += 1;\n        }\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n\n      uint256 id = chainPrepend + uint256(tokenId);\n      emit NFTMinted(recipient, tokenId, id);\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc721a-upgradeable/=erc721a-upgradeable/",
      "forge-std/=lib/forge-std/src/"
    ]
  }
}