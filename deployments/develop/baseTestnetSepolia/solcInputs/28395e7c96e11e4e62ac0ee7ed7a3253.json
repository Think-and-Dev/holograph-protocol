{
  "language": "Solidity",
  "sources": {
    "src/abstract/ContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../interface/IContractMetadata.sol\";\n\n/**\n *  @title   Contract Metadata\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *           for you contract.\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\nabstract contract ContractMetadata is IContractMetadata {\n  /// @notice Returns the contract metadata URI.\n  string public override contractURI;\n\n  /**\n   *  @notice         Lets a contract admin set the URI for contract-level metadata.\n   *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\n   *                  See {_canSetContractURI}.\n   *                  Emits {ContractURIUpdated Event}.\n   *\n   *  @param _uri     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n   */\n  function setContractURI(string memory _uri) external override {\n    if (!_canSetContractURI()) {\n      revert(\"Not authorized\");\n    }\n\n    _setupContractURI(_uri);\n  }\n\n  /// @dev Lets a contract admin set the URI for contract-level metadata.\n  function _setupContractURI(string memory _uri) internal {\n    string memory prevURI = contractURI;\n    contractURI = _uri;\n\n    emit ContractURIUpdated(prevURI, _uri);\n  }\n\n  /// @dev Returns whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view virtual returns (bool);\n}\n"
    },
    "src/abstract/ERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/Initializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/InitializableInterface.sol\";\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need for a constructor\n */\nabstract contract Initializable is InitializableInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.initialized')) - 1)\n   */\n  bytes32 constant _initializedSlot = 0x4e5f991bca30eca2d4643aaefa807e88f96a4a97398933d572a3c0d973004a01;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual returns (bytes4);\n\n  function _isInitialized() internal view returns (bool initialized) {\n    assembly {\n      initialized := sload(_initializedSlot)\n    }\n  }\n\n  function _setInitialized() internal {\n    assembly {\n      sstore(_initializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "src/abstract/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract NonReentrant {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.reentrant')) - 1)\n   */\n  bytes32 constant _reentrantSlot = 0x04b524dd539523930d3901481aa9455d7752b49add99e1647adb8b09a3137279;\n\n  modifier nonReentrant() {\n    require(getStatus() != 2, \"HOLOGRAPH: reentrant call\");\n    setStatus(2);\n    _;\n    setStatus(1);\n  }\n\n  constructor() {}\n\n  function getStatus() internal view returns (uint256 status) {\n    assembly {\n      status := sload(_reentrantSlot)\n    }\n  }\n\n  function setStatus(uint256 status) internal {\n    assembly {\n      sstore(_reentrantSlot, status)\n    }\n  }\n}\n"
    },
    "src/drops/interface/IDropsPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IDropsPriceOracle {\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount);\n}\n"
    },
    "src/drops/library/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "src/drops/library/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary MerkleProof {\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n   * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n   * hash matches the root of the tree. When processing the proof, the pairs\n   * of leafs & pre-images are assumed to be sorted.\n   *\n   * _Available since v4.4._\n   */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n      if (computedHash <= proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = _efficientHash(computedHash, proofElement);\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = _efficientHash(proofElement, computedHash);\n      }\n    }\n    return computedHash;\n  }\n\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "src/drops/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"
    },
    "src/drops/struct/AddressMintDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return type of specific mint counts and details per address\nstruct AddressMintDetails {\n  /// Number of total mints from the given address\n  uint256 totalMints;\n  /// Number of presale mints from the given address\n  uint256 presaleMints;\n  /// Number of public mints from the given address\n  uint256 publicMints;\n}\n"
    },
    "src/interface/CollectionURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CollectionURI {\n  function contractURI() external view returns (string memory);\n}\n"
    },
    "src/interface/ERC165.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/interface/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n/* is ERC165 */\ninterface ERC721 {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param _owner An address for whom to query the balance\n  /// @return The number of NFTs owned by `_owner`, possibly zero\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param _tokenId The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf(uint256 _tokenId) external view returns (address);\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `_to` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  /// @param data Additional data with no specified format, sent in call to `_to`\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param _approved The new approved NFT controller\n  /// @param _tokenId The NFT to approve\n  function approve(address _approved, uint256 _tokenId) external payable;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param _operator Address to add to the set of authorized operators\n  /// @param _approved True if the operator is approved, false to revoke approval\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `_tokenId` is not a valid NFT.\n  /// @param _tokenId The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved(uint256 _tokenId) external view returns (address);\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param _owner The address that owns the NFTs\n  /// @param _operator The address that acts on behalf of the owner\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "src/interface/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n/* is ERC721 */\ninterface ERC721Enumerable {\n  /// @notice Count NFTs tracked by this contract\n  /// @return A count of valid NFTs tracked by this contract, where each one of\n  ///  them has an assigned and queryable owner not equal to the zero address\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Enumerate valid NFTs\n  /// @dev Throws if `_index` >= `totalSupply()`.\n  /// @param _index A counter less than `totalSupply()`\n  /// @return The token identifier for the `_index`th NFT,\n  ///  (sort order not specified)\n  function tokenByIndex(uint256 _index) external view returns (uint256);\n\n  /// @notice Enumerate NFTs assigned to an owner\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n  ///  `_owner` is the zero address, representing invalid NFTs.\n  /// @param _owner An address where we are interested in NFTs owned by them\n  /// @param _index A counter less than `balanceOf(_owner)`\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n  ///   (sort order not specified)\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "src/interface/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface ERC721Metadata {\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n\n  /// @notice An abbreviated name for NFTs in this contract\n  function symbol() external view returns (string memory _symbol);\n\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n  ///  Metadata JSON Schema\".\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/interface/ERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n  /// @notice Handle the receipt of an NFT\n  /// @dev The ERC721 smart contract calls this function on the recipient\n  ///  after a `transfer`. This function MAY throw to revert and reject the\n  ///  transfer. Return of other than the magic value MUST result in the\n  ///  transaction being reverted.\n  ///  Note: the contract address is always the message sender.\n  /// @param _operator The address which called `safeTransferFrom` function\n  /// @param _from The address which previously owned the token\n  /// @param _tokenId The NFT identifier which is being transferred\n  /// @param _data Additional data with no specified format\n  /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  ///  unless throwing\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4);\n}\n"
    },
    "src/interface/Holographable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Holographable {\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external returns (bytes4);\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external returns (bytes4 selector, bytes memory data);\n}\n"
    },
    "src/interface/HolographERC721Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./CollectionURI.sol\";\nimport \"./ERC165.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\nimport \"./ERC721TokenReceiver.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographERC721Interface is\n  ERC165,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Metadata,\n  ERC721TokenReceiver,\n  CollectionURI,\n  Holographable\n{\n  function approve(address to, uint256 tokenId) external payable;\n\n  function burn(uint256 tokenId) external;\n\n  function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n  function setApprovalForAll(address to, bool approved) external;\n\n  function sourceBurn(uint256 tokenId) external;\n\n  function sourceMint(address to, uint224 tokenId) external;\n\n  function sourceGetChainPrepend() external view returns (uint256);\n\n  function sourceTransfer(address to, uint256 tokenId) external;\n\n  function sourceExternalCall(address target, bytes calldata data) external;\n\n  function transfer(address to, uint256 tokenId) external payable;\n\n  function contractURI() external view returns (string memory);\n\n  function getApproved(uint256 tokenId) external view returns (address);\n\n  function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function burned(uint256 tokenId) external view returns (bool);\n\n  function decimals() external pure returns (uint256);\n\n  function exists(uint256 tokenId) external view returns (bool);\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256);\n\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "src/interface/HolographerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographerInterface {\n  function getContractType() external view returns (bytes32 contractType);\n\n  function getDeploymentBlock() external view returns (uint256 deploymentBlock);\n\n  function getHolograph() external view returns (address holograph);\n\n  function getHolographEnforcer() external view returns (address);\n\n  function getOriginChain() external view returns (uint32 originChain);\n\n  function getSourceContract() external view returns (address sourceContract);\n}\n"
    },
    "src/interface/HolographInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Holograph Protocol\n * @author https://github.com/holographxyz\n * @notice This is the primary Holograph Protocol smart contract\n * @dev This contract stores a reference to all the primary modules and variables of the protocol\n */\ninterface HolographInterface {\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge);\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external;\n\n  /**\n   * @notice Get the chain ID that the Protocol was deployed on\n   * @dev Useful for checking if/when a hard fork occurs\n   */\n  function getChainId() external view returns (uint256 chainId);\n\n  /**\n   * @notice Update the chain ID\n   * @dev Useful for updating once a hard fork has been mitigated\n   * @param chainId EVM chain ID to use\n   */\n  function setChainId(uint256 chainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory);\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external;\n\n  /**\n   * @notice Get the Holograph chain Id\n   * @dev Holograph uses an internal chain id mapping\n   */\n  function getHolographChainId() external view returns (uint32 holographChainId);\n\n  /**\n   * @notice Update the Holograph chain ID\n   * @dev Useful for updating once a hard fork was mitigated\n   * @param holographChainId Holograph chain ID to use\n   */\n  function setHolographChainId(uint32 holographChainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces);\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external;\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator);\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n\n  /**\n   * @notice Get the Holograph Treasury module\n   * @dev All of the Holograph Protocol assets are stored and managed by this module\n   */\n  function getTreasury() external view returns (address treasury);\n\n  /**\n   * @notice Update the Holograph Treasury module address\n   * @param treasury address of the Holograph Treasury smart contract to use\n   */\n  function setTreasury(address treasury) external;\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken);\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external;\n}\n"
    },
    "src/interface/HolographTreasuryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographTreasuryInterface {\n  /**\n   * @notice Update the Holograph Mint Fee\n   * @param fee new fee to charge for minting holographable assets\n   */\n  function setHolographMintFee(uint256 fee) external;\n\n  /**\n   * @notice Withdraws native tokens from the contract\n   * @dev Can only be called by the admin\n   */\n  function withdraw() external;\n\n  /**\n   * @notice Withdraws native tokens from the contract to a specified address\n   * @dev Can only be called by the admin\n   * @param recipient The address to send the withdrawn funds to\n   */\n  function withdrawTo(address payable recipient) external;\n\n  /**\n   * @notice Get the Holograph Mint Fee\n   * @dev This fee is charged to mint holographable assets\n   * @return The current holograph mint fee\n   */\n  function getHolographMintFee() external view returns (uint256);\n}\n"
    },
    "src/interface/IContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *  for you contract.\n *\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\ninterface IContractMetadata {\n  /// @dev Returns the metadata URI of the contract.\n  function contractURI() external view returns (string memory);\n\n  /**\n   *  @dev Sets contract URI for the storefront-level metadata of the contract.\n   *       Only module admin can call this function.\n   */\n  function setContractURI(string calldata _uri) external;\n\n  /// @dev Emitted when the contract URI is updated.\n  event ContractURIUpdated(string prevURI, string newURI);\n}\n"
    },
    "src/interface/ICustomERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CustomERC721SaleDetails} from \"src/struct/CustomERC721SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface ICustomERC721 {\n  // Access errors\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Only minter can access this function\n  error Access_OnlyMinter();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n  /// @notice Lazy mint initialization failed\n  error LazyMint_AlreadyInitialized();\n  /// @notice Contract is not initialized yet\n  error NotInitialized();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n  /// @notice The countdown has been completed\n  error Purchase_CountdownCompleted();\n\n  // Init errors\n  error CountdownEndMustBeDivisibleByMintTimeCost(uint128 countdownEnd, uint128 mintTimeCost);\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when an nfs is minted\n  /// @param recipient address that the nft was minted to\n  /// @param tokenId id of the minted nft\n  /// @param id id of the minted nft with chain id prefix\n  event NFTMinted(address indexed recipient, uint256 indexed tokenId, uint256 id);\n\n  /// @notice Getter for the sale start date\n  function START_DATE() external view returns (uint256);\n\n  /// @notice Getter for the initial max supply\n  function INITIAL_MAX_SUPPLY() external view returns (uint256);\n\n  /// @notice Getter for the mint interval\n  function MINT_INTERVAL() external view returns (uint256);\n\n  /// @notice Getter for the minter role\n  function minter() external view returns (address);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  function setSaleConfiguration(uint104 publicSalePrice, uint24 maxSalePurchasePerAddress) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (CustomERC721SaleDetails memory);\n\n  /// @notice Function to return the current max supply\n  function currentTheoricalMaxSupply() external view returns (uint256);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/interface/InitializableInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need of a constructor\n */\ninterface InitializableInterface {\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external returns (bytes4);\n}\n"
    },
    "src/library/NFTMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {MetadataParams} from \"../struct/MetadataParams.sol\";\n\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n   * with further edits by Uniswap Labs also under MIT license.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        return prod0 / denominator;\n      }\n\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n        // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n      // See https://cs.stackexchange.com/q/138556/92363.\n\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\n      uint256 twos = denominator & (~denominator + 1);\n      assembly {\n        // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n      // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n      // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n      // in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n   *\n   * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n   */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n   */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = sqrt(a);\n      return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 128;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 64;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 32;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 16;\n      }\n      if (value >> 8 > 0) {\n        value >>= 8;\n        result += 8;\n      }\n      if (value >> 4 > 0) {\n        value >>= 4;\n        result += 4;\n      }\n      if (value >> 2 > 0) {\n        value >>= 2;\n        result += 2;\n      }\n      if (value >> 1 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log2(value);\n      return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >= 10 ** 64) {\n        value /= 10 ** 64;\n        result += 64;\n      }\n      if (value >= 10 ** 32) {\n        value /= 10 ** 32;\n        result += 32;\n      }\n      if (value >= 10 ** 16) {\n        value /= 10 ** 16;\n        result += 16;\n      }\n      if (value >= 10 ** 8) {\n        value /= 10 ** 8;\n        result += 8;\n      }\n      if (value >= 10 ** 4) {\n        value /= 10 ** 4;\n        result += 4;\n      }\n      if (value >= 10 ** 2) {\n        value /= 10 ** 2;\n        result += 2;\n      }\n      if (value >= 10 ** 1) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log10(value);\n      return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   *\n   * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n   */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 16;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 8;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 4;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 2;\n      }\n      if (value >> 8 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log256(value);\n      return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n    }\n  }\n}\n\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      uint256 length = Math.log10(value) + 1;\n      string memory buffer = new string(length);\n      uint256 ptr;\n      /// @solidity memory-safe-assembly\n      assembly {\n        ptr := add(buffer, add(32, length))\n      }\n      while (true) {\n        ptr--;\n        /// @solidity memory-safe-assembly\n        assembly {\n          mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n        }\n        value /= 10;\n        if (value == 0) break;\n      }\n      return buffer;\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n      return toHexString(value, Math.log256(value) + 1);\n    }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n\nlibrary Base64 {\n  /**\n   * @dev Base64 Encoding/Decoding Table\n   */\n  string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /**\n   * @dev Converts a `bytes` to its Bytes64 `string` representation.\n   */\n  function encode(bytes memory data) internal pure returns (string memory) {\n    /**\n     * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n     * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n     */\n    if (data.length == 0) return \"\";\n\n    // Loads the table into memory\n    string memory table = _TABLE;\n\n    // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n    // and split into 4 numbers of 6 bits.\n    // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n    // - `data.length + 2`  -> Round up\n    // - `/ 3`              -> Number of 3-bytes chunks\n    // - `4 *`              -> 4 characters for each chunk\n    string memory result = new string(4 * ((data.length + 2) / 3));\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Prepare the lookup table (skip the first \"length\" byte)\n      let tablePtr := add(table, 1)\n\n      // Prepare result pointer, jump over length\n      let resultPtr := add(result, 32)\n\n      // Run over the input, 3 bytes at a time\n      for {\n        let dataPtr := data\n        let endPtr := add(data, mload(data))\n      } lt(dataPtr, endPtr) {\n\n      } {\n        // Advance 3 bytes\n        dataPtr := add(dataPtr, 3)\n        let input := mload(dataPtr)\n\n        // To write each character, shift the 3 bytes (18 bits) chunk\n        // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n        // and apply logical AND with 0x3F which is the number of\n        // the previous character in the ASCII table prior to the Base64 Table\n        // The result is then added to the table to get the character to write,\n        // and finally write it in the result pointer but with a left shift\n        // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n      }\n\n      // When data `bytes` is not exactly 3 bytes long\n      // it is padded with `=` characters at the end\n      switch mod(mload(data), 3)\n      case 1 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n        mstore8(sub(resultPtr, 2), 0x3d)\n      }\n      case 2 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n      }\n    }\n\n    return result;\n  }\n}\n\n/// NFT metadata library for rendering metadata associated with editions\nlibrary NFTMetadataRenderer {\n  /// Function to create the metadata for an edition\n  /// @param params MetadataParams struct containing all metadata information\n  function createMetadataEdition(MetadataParams memory params) internal pure returns (string memory) {\n    bytes memory json = createMetadataJSON(params);\n    return encodeMetadataJSON(json);\n  }\n\n  function encodeContractURIJSON(\n    string memory name,\n    string memory description,\n    string memory imageURI,\n    string memory animationURI,\n    uint256 royaltyBPS,\n    address royaltyRecipient\n  ) internal pure returns (string memory) {\n    bytes memory imageSpace = bytes(\"\");\n    if (bytes(imageURI).length > 0) {\n      imageSpace = abi.encodePacked('\", \"image\": \"', imageURI);\n    }\n    bytes memory animationSpace = bytes(\"\");\n    if (bytes(animationURI).length > 0) {\n      animationSpace = abi.encodePacked('\", \"animation_url\": \"', animationURI);\n    }\n\n    return\n      string(\n        encodeMetadataJSON(\n          abi.encodePacked(\n            '{\"name\": \"',\n            name,\n            '\", \"description\": \"',\n            description,\n            // this is for opensea since they don't respect ERC2981 right now\n            '\", \"seller_fee_basis_points\": ',\n            Strings.toString(royaltyBPS),\n            ', \"fee_recipient\": \"',\n            Strings.toHexString(uint256(uint160(royaltyRecipient)), 20),\n            imageSpace,\n            animationSpace,\n            '\"}'\n          )\n        )\n      );\n  }\n\n  /// Function to create the metadata json string for the nft edition\n  /// @param params MetadataParams struct containing all metadata information\n  function createMetadataJSON(MetadataParams memory params) internal pure returns (bytes memory) {\n    bytes memory editionSizeText;\n    string memory tokenOfEditionString;\n    {\n      if (params.editionSize > 0) {\n        editionSizeText = abi.encodePacked(\"/\", Strings.toString(params.editionSize));\n      }\n\n      tokenOfEditionString = Strings.toString(params.tokenOfEdition);\n    }\n\n    return\n      abi.encodePacked(\n        abi.encodePacked(\n          '{\"name\": \"',\n          params.name,\n          \" \",\n          tokenOfEditionString,\n          editionSizeText,\n          '\", \"description\": \"',\n          params.description,\n          '\", \"external_url\": \"',\n          params.externalUrl,\n          '\", \"image\": \"',\n          params.imageURI,\n          '\", \"encrypted_media_url\": \"',\n          params.encryptedMediaUrl\n        ),\n        abi.encodePacked(\n          '\", \"decryption_key\": \"',\n          params.decryptionKey,\n          '\", \"hash\": \"',\n          params.hash,\n          '\", \"decrypted_media_url\": \"',\n          params.decryptedMediaUrl,\n          '\", \"animation_url\": \"',\n          params.animationURI,\n          '\", \"properties\": {\"number\": ',\n          tokenOfEditionString,\n          ', \"name\": \"',\n          params.name,\n          '\"}}'\n        )\n      );\n  }\n\n  /// Encodes the argument json bytes into base64-data uri format\n  /// @param json Raw json to base64 and turn into a data-uri\n  function encodeMetadataJSON(bytes memory json) internal pure returns (string memory) {\n    return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(json)));\n  }\n\n  /// Generates edition metadata from storage information as base64-json blob\n  /// Combines the media data and metadata\n  /// @param imageUrl URL of image to render for edition\n  /// @param animationUrl URL of animation to render for edition\n  function tokenMediaData(string memory imageUrl, string memory animationUrl) internal pure returns (string memory) {\n    bool hasImage = bytes(imageUrl).length > 0;\n    bool hasAnimation = bytes(animationUrl).length > 0;\n    if (hasImage && hasAnimation) {\n      return string(abi.encodePacked('image\": \"', imageUrl, '\", \"animation_url\": \"', animationUrl, '\", \"'));\n    }\n    if (hasImage) {\n      return string(abi.encodePacked('image\": \"', imageUrl, '\", \"'));\n    }\n    if (hasAnimation) {\n      return string(abi.encodePacked('animation_url\": \"', animationUrl, '\", \"'));\n    }\n\n    return \"\";\n  }\n\n  /// @dev Generates a metadata string from provided URLs and keys\n  /// This function checks for the presence of media-related information and formats them into a JSON-like string.\n  /// @param params MetadataParams struct containing all metadata information\n  /// @return A string that concatenates all provided and non-empty fields into a JSON-like format for NFT metadata.\n  function tokenMediaData(MetadataParams memory params) internal pure returns (string memory) {\n    // Initialize boolean variables to check if each parameter contains data.\n    bool hasImage = bytes(params.imageURI).length > 0;\n    bool hasAnimation = bytes(params.animationURI).length > 0;\n    bool hasExternal = bytes(params.externalUrl).length > 0;\n    bool hasEncryptedMedia = bytes(params.encryptedMediaUrl).length > 0;\n    bool hasDecryptionKey = bytes(params.decryptionKey).length > 0;\n    bool hasHash = bytes(params.hash).length > 0;\n    bool hasDecryptedMedia = bytes(params.decryptedMediaUrl).length > 0;\n\n    // Check if all parameters are provided and concatenate them into a JSON-like string.\n    if (\n      hasImage && hasAnimation && hasExternal && hasEncryptedMedia && hasDecryptionKey && hasHash && hasDecryptedMedia\n    ) {\n      return\n        string(\n          abi.encodePacked(\n            '\"image\": \"',\n            params.imageURI,\n            '\", ',\n            '\"animation_url\": \"',\n            params.animationURI,\n            '\", ',\n            '\"external_url\": \"',\n            params.externalUrl,\n            '\", ',\n            '\"encrypted_media_url\": \"',\n            params.encryptedMediaUrl,\n            '\", ',\n            '\"decryption_key\": \"',\n            params.decryptionKey,\n            '\", ',\n            '\"hash\": \"',\n            params.hash,\n            '\", ',\n            '\"decrypted_media_url\": \"',\n            params.decryptedMediaUrl,\n            '\", '\n          )\n        );\n    }\n\n    // Individual checks for each field, appending them to the result if they contain data.\n    if (hasImage) {\n      return string(abi.encodePacked('\"image\": \"', params.imageURI, '\", '));\n    }\n    if (hasAnimation) {\n      return string(abi.encodePacked('\"animation_url\": \"', params.animationURI, '\", '));\n    }\n    if (hasExternal) {\n      return string(abi.encodePacked('\"external_url\": \"', params.externalUrl, '\", '));\n    }\n    if (hasEncryptedMedia) {\n      return string(abi.encodePacked('\"encrypted_media_url\": \"', params.encryptedMediaUrl, '\", '));\n    }\n    if (hasDecryptionKey) {\n      return string(abi.encodePacked('\"decryption_key\": \"', params.decryptionKey, '\", '));\n    }\n    if (hasHash) {\n      return string(abi.encodePacked('\"hash\": \"', params.hash, '\", '));\n    }\n    if (hasDecryptedMedia) {\n      return string(abi.encodePacked('\"decrypted_media_url\": \"', params.decryptedMediaUrl, '\", '));\n    }\n\n    // Return an empty string if none of the fields are provided.\n    return \"\";\n  }\n}\n"
    },
    "src/struct/CountdownERC721Initializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {CustomERC721SalesConfiguration} from \"src/struct/CustomERC721SalesConfiguration.sol\";\n\nstruct CountdownERC721Initializer {\n  string description; // The description of the token.\n  string imageURI; // The URI for the image associated with this contract.\n  string animationURI; // The URI for the animation associated with this contract.\n  string externalLink; // The URI for the external metadata associated with this contract.\n  string encryptedMediaURI; // The URI for the encrypted media associated with this contract.\n  uint40 startDate; // The starting date for the countdown\n  uint32 initialMaxSupply; // The theoretical initial maximum supply of tokens at the start of the countdown.\n  uint24 mintInterval; // The interval between possible mints,\n  address initialOwner; // Address of the initial owner, who has administrative privileges.\n  address initialMinter; // Address of the initial minter, who can mint new tokens for those who purchase offchain.\n  address payable fundsRecipient; // Address of the recipient for funds gathered from sales.\n  string contractURI; // URI for the metadata associated with this contract.\n  CustomERC721SalesConfiguration salesConfiguration; // Configuration of sales settings for this contract.\n}\n"
    },
    "src/struct/CustomERC721SaleDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return value for sales details to use with front-ends\nstruct CustomERC721SaleDetails {\n  // Sale state\n  bool publicSaleActive;\n  // Price for public sale\n  uint256 publicSalePrice;\n  // Timed sale actions for public sale\n  uint256 publicSaleStart;\n  // Limit public sale to a specific number of mints per wallet\n  uint256 maxSalePurchasePerAddress;\n  // Information about the rest of the supply\n  // Total that have been minted\n  uint256 totalMinted;\n  // The total supply available\n  uint256 maxSupply;\n}\n"
    },
    "src/struct/CustomERC721SalesConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Sales states and configuration\n/// @dev Uses 2 storage slots (Can be set by the owner)\nstruct CustomERC721SalesConfiguration {\n  /// @dev Public sale price (max ether value > 1000 ether with this value)\n  uint104 publicSalePrice;\n  /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n  /// @dev Max purchase number per txn (90+32 = 122)\n  uint24 maxSalePurchasePerAddress;\n}\n"
    },
    "src/struct/MetadataParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct MetadataParams {\n  string name;\n  string description;\n  string imageURI;\n  string animationURI;\n  string externalUrl;\n  string encryptedMediaUrl;\n  string decryptionKey;\n  string hash;\n  string decryptedMediaUrl;\n  uint256 tokenOfEdition;\n  uint256 editionSize;\n}\n"
    },
    "src/token/CountdownERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../abstract/NonReentrant.sol\";\nimport {ContractMetadata} from \"../abstract/ContractMetadata.sol\";\n\nimport {HolographERC721Interface} from \"../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../interface/HolographInterface.sol\";\nimport {ICustomERC721} from \"../interface/ICustomERC721.sol\";\nimport {IDropsPriceOracle} from \"../drops/interface/IDropsPriceOracle.sol\";\nimport {HolographTreasuryInterface} from \"../interface/HolographTreasuryInterface.sol\";\n\nimport {AddressMintDetails} from \"../drops/struct/AddressMintDetails.sol\";\nimport {CountdownERC721Initializer} from \"src/struct/CountdownERC721Initializer.sol\";\nimport {CustomERC721SaleDetails} from \"src/struct/CustomERC721SaleDetails.sol\";\nimport {CustomERC721SalesConfiguration} from \"src/struct/CustomERC721SalesConfiguration.sol\";\nimport {MetadataParams} from \"src/struct/MetadataParams.sol\";\n\nimport {Address} from \"../drops/library/Address.sol\";\nimport {MerkleProof} from \"../drops/library/MerkleProof.sol\";\nimport {Strings} from \"./../drops/library/Strings.sol\";\nimport {NFTMetadataRenderer} from \"../library/NFTMetadataRenderer.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified the source code for them.\n */\ncontract CountdownERC721 is NonReentrant, ContractMetadata, ERC721H, ICustomERC721 {\n  using Strings for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             CONTRACT VARIABLES                             */\n  /*        all variables, without custom storage slots, are defined here       */\n  /* -------------------------------------------------------------------------- */\n\n  /// @notice Getter for the purchase start date\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public START_DATE;\n\n  /// @notice Getter for the initial max supply\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public INITIAL_MAX_SUPPLY;\n\n  /// @notice Getter for the mint interval\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public MINT_INTERVAL;\n\n  /// @notice Getter for the mint interval\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  address payable FUNDS_RECIPIENT;\n\n  /// @notice Getter for the initial end date\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  uint256 public INITIAL_END_DATE;\n\n  /// @notice Getter for the end date\n  uint256 public END_DATE;\n\n  /// @notice Getter for the minter\n  /// @dev This account tokens on behalf of those that purchase them offchain\n  address public minter;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             METADATA VARAIBLES                             */\n  /* -------------------------------------------------------------------------- */\n\n  /// @notice Getter for the description\n  /// @dev This storage variable is set only once in the init and can be considered as immutable\n  string public DESCRIPTION;\n\n  /// @notice Getter for the base image URI\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public IMAGE_URI;\n\n  /// @notice Getter for the base animation URI\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public ANIMATION_URI;\n\n  /// @notice Getter for the external url\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public EXTERNAL_URL;\n\n  /// @notice Getter for the encrypted media URI\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public ENCRYPTED_MEDIA_URL;\n\n  /// @notice Getter for the decryption key\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public DECRYPTION_KEY;\n\n  /// @notice Getter for the hash\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public HASH;\n\n  /// @notice Getter for the decrypted media URI\n  /// @dev This storage variable is set during the init and can be updated by the owner\n  string public DECRYPTED_MEDIA_URI;\n\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Sales configuration\n   */\n  CustomERC721SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for the total mints by address\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  MODIFIERS                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Allows only the minter to call the function\n   */\n  modifier onlyMinter() {\n    if (msgSender() != minter) {\n      revert Access_OnlyMinter();\n    }\n    _;\n  }\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    /// @dev Check if the countdown has completed\n    ///      END_DATE - MINT_INTERVAL * (quantity - 1) represent the time when the last mint will be allowed\n    ///      (quantity - 1) because we want to allow the last mint to be available until the END_DATE\n    if (block.timestamp >= END_DATE - MINT_INTERVAL * (quantity - 1)) {\n      revert Purchase_CountdownCompleted();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n    _;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            CONTRACT INITIALIZERS                           */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/the factory when creating a contract\n   * @param initPayload abi encoded payload (CountdownERC721Initializer struct) to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    // Enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Decode the initializer payload to get the CountdownERC721Initializer struct\n    CountdownERC721Initializer memory initializer = abi.decode(initPayload, (CountdownERC721Initializer));\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    ADMIN                                   */\n    /* -------------------------------------------------------------------------- */\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // Setup the minter role\n    _setMinter(initializer.initialMinter);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                SALES CONFIG                                */\n    /* -------------------------------------------------------------------------- */\n\n    // Set the sale start date.\n    /// @dev The sale start date represents the date when the public sale starts.\n    ///      The sale start date is used like an immutable.\n    START_DATE = initializer.startDate;\n\n    // Set the initial max supply.\n    /// @dev The initial max supply represents the theoretical maximum supply at the start date timestamp.\n    ///      The sale start date is used like an immutable.\n    INITIAL_MAX_SUPPLY = initializer.initialMaxSupply;\n\n    // Set the mint interval.\n    /// @dev The mint interval specifies the duration by which the END_DATE is decreased after each mint operation.\n    ///      The sale start date is used like an immutable.\n    MINT_INTERVAL = initializer.mintInterval;\n\n    // Set the funds recipient\n    /// @dev The funds recipient is the address that receives the funds from the token sales.\n    ///      The funds recipient can be updated by the owner.\n    FUNDS_RECIPIENT = initializer.fundsRecipient;\n\n    // Set the end dates\n    /// @dev The END_DATE is calculated by adding the initial max supply times the mint interval to the start date.\n    ///      The END_DATE is decreased after each mint operation by the mint interval.\n    uint256 endDate = initializer.startDate + initializer.initialMaxSupply * initializer.mintInterval;\n    END_DATE = endDate;\n    /// @dev The sale start date is used like an immutable.\n    INITIAL_END_DATE = endDate;\n\n    // Set the sales configuration\n    salesConfig = initializer.salesConfiguration;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  METADATA                                  */\n    /* -------------------------------------------------------------------------- */\n\n    _setupContractURI(initializer.contractURI);\n\n    // Set the description\n    /// @dev The description is a human-readable description of the token.\n    ///      The description is used like an immutable.\n    DESCRIPTION = initializer.description;\n\n    // Set the image URI\n    /// @dev The image URI is the base URI for the images associated with the tokens.\n    IMAGE_URI = initializer.imageURI;\n\n    // Set the animation URI\n    /// @dev The animation URI is the base URI for the animations associated with the tokens.\n    ANIMATION_URI = initializer.animationURI;\n\n    // Set the external link\n    /// @dev The external link is the base URI for the external metadata associated with the tokens.\n    EXTERNAL_URL = initializer.externalLink;\n\n    // Set the hash\n    /// @dev The hash is a unique hash associated with the tokens.\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                     PUBLIC NON STATE CHANGING FUNCTIONS                    */\n  /*                                   static                                   */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version of the contract\n   */\n  function version() external pure returns (uint32) {\n    return 1;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(ICustomERC721).interfaceId;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                     PUBLIC NON STATE CHANGING FUNCTIONS                    */\n  /*                                   dynamic                                  */\n  /* -------------------------------------------------------------------------- */\n\n  function owner() external view override(ERC721H, ICustomERC721) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  /**\n   * @notice Returns the theoretical maximum supply for the current time\n   * @dev The max supply is calculated based on the current time and the mint interval, by subtracting\n   *      the elapsed_mint intervals from the initial max supply.\n   *      - The max supply is the initial max supply if the current time is less than the start date.\n   *      - The max supply is zero if the current time is greater than the end date.\n   *      - The max supply is decreased by one for each mint interval that has passed.\n   *      - The max supply is calculated by subtracting the intervals elapsed from the initial max supply.\n   * @return max supply\n   */\n  function currentTheoricalMaxSupply() public view returns (uint256) {\n    if (block.timestamp <= START_DATE) {\n      return INITIAL_MAX_SUPPLY;\n    } else if (block.timestamp >= START_DATE + INITIAL_MAX_SUPPLY * MINT_INTERVAL) {\n      return 0; // All intervals have elapsed\n    } else {\n      // EVM division is floored\n      uint256 intervalsElapsed = (block.timestamp - START_DATE) / MINT_INTERVAL;\n      return INITIAL_MAX_SUPPLY - intervalsElapsed;\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of tokens minted in the contract.\n   */\n  function totalMinted() external view returns (uint256) {\n    return _currentTokenId;\n  }\n\n  /**\n   * @notice Sale details\n   * @dev Returns the sale details for the contract\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (CustomERC721SaleDetails memory) {\n    return\n      CustomERC721SaleDetails({\n        publicSaleActive: _publicSaleActive(), // Based on the current time\n        publicSalePrice: salesConfig.publicSalePrice, // Can be updated by the owner\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress, // Can be updated by the owner\n        publicSaleStart: START_DATE, // Immutable\n        totalMinted: _currentTokenId, // Updated after each mint\n        maxSupply: currentTheoricalMaxSupply() // Updated after each mint or after each interval\n      });\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: 0, // NOTE: Presale mints are not supported\n        publicMints: totalMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @dev Returns a base64 encoded metadata URI for a given tokenId.\n   * @param tokenId The ID of the token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 tokenId) public view returns (string memory) {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    require(H721.exists(tokenId), \"ERC721: token does not exist\");\n\n    string memory _name = H721.name();\n    MetadataParams memory params = MetadataParams({\n      name: _name,\n      description: DESCRIPTION,\n      imageURI: IMAGE_URI,\n      animationURI: ANIMATION_URI,\n      externalUrl: EXTERNAL_URL,\n      encryptedMediaUrl: ENCRYPTED_MEDIA_URL,\n      decryptionKey: DECRYPTION_KEY,\n      hash: HASH,\n      decryptedMediaUrl: DECRYPTED_MEDIA_URI,\n      tokenOfEdition: tokenId,\n      editionSize: 0 // Set or fetch dynamically if applicable\n    });\n\n    return NFTMetadataRenderer.createMetadataEdition(params);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                       PUBLIC STATE CHANGING FUNCTIONS                      */\n  /*                              available to all                              */\n  /* -------------------------------------------------------------------------- */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   * @param quantity quantity to purchase\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n\n    if (msg.value < (salePrice) * quantity) {\n      // The error will display what the correct price should be\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice) * quantity);\n    }\n\n    // Reducing the end date by removing the quantity of mints times the mint interval\n    END_DATE = END_DATE - quantity * MINT_INTERVAL;\n\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity > salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                       PUBLIC STATE CHANGING FUNCTIONS                      */\n  /*                                 admin only                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the metadata params for the contract\n   * @notice This only sets the subset of metadata params that are settable by the owner\n   */\n  function setMetadataParams(MetadataParams memory params) external onlyOwner {\n    IMAGE_URI = params.imageURI;\n    ANIMATION_URI = params.animationURI;\n    EXTERNAL_URL = params.externalUrl;\n    ENCRYPTED_MEDIA_URL = params.encryptedMediaUrl;\n    DECRYPTION_KEY = params.decryptionKey;\n    HASH = params.hash;\n    DECRYPTED_MEDIA_URI = params.decryptedMediaUrl;\n  }\n\n  /**\n   * @notice Minter account mints tokens to a recipient that has paid offchain\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function mintTo(address recipient, uint256 quantity) external onlyMinter canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   */\n  function setSaleConfiguration(uint104 publicSalePrice, uint24 maxSalePurchasePerAddress) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    FUNDS_RECIPIENT = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (FUNDS_RECIPIENT == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != FUNDS_RECIPIENT && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = FUNDS_RECIPIENT.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, FUNDS_RECIPIENT, funds);\n  }\n\n  /**\n   * @notice Set the minter address\n   * @param minterAddress new minter address\n   */\n  function setMinter(address minterAddress) external onlyOwner {\n    _setMinter(minterAddress);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             INTERNAL FUNCTIONS                             */\n  /*                             non state changing                             */\n  /* -------------------------------------------------------------------------- */\n\n  /// @notice Checks whether contract metadata can be set in the given execution context.\n  function _canSetContractURI() internal view override returns (bool) {\n    return msgSender() == _getOwner();\n  }\n\n  /**\n   * @dev Checks if the public sale is active\n   */\n  function _publicSaleActive() internal view returns (bool) {\n    return START_DATE <= block.timestamp;\n  }\n\n  /**\n   * @dev Converts the given amount in USD to the equivalent amount in wei using the price oracle.\n   * @param amount The amount in USD to convert to wei\n   */\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             INTERNAL FUNCTIONS                             */\n  /*                               state changing                               */\n  /* -------------------------------------------------------------------------- */\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n\n    for (uint256 i = 0; i != quantity; ) {\n      unchecked {\n        _currentTokenId += 1;\n      }\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        unchecked {\n          _currentTokenId += 1;\n        }\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n\n      uint256 id = chainPrepend + uint256(tokenId);\n      emit NFTMinted(recipient, tokenId, id);\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * @dev Set the minter address\n   * @param minterAddress new minter address\n   */\n  function _setMinter(address minterAddress) internal {\n    minter = minterAddress;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Fallback                                  */\n  /* -------------------------------------------------------------------------- */\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc721a-upgradeable/=erc721a-upgradeable/",
      "forge-std/=lib/forge-std/src/"
    ]
  }
}