{
  "language": "Solidity",
  "sources": {
    "src/abstract/Admin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract Admin {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.admin')) - 1)\n   */\n  bytes32 constant _adminSlot = 0x3f106594dc74eeef980dae234cde8324dc2497b13d27a0c59e55bd2ca10a07c9;\n\n  modifier onlyAdmin() {\n    require(msg.sender == getAdmin(), \"HOLOGRAPH: admin only function\");\n    _;\n  }\n\n  constructor() {}\n\n  function admin() public view returns (address) {\n    return getAdmin();\n  }\n\n  function getAdmin() public view returns (address adminAddress) {\n    assembly {\n      adminAddress := sload(_adminSlot)\n    }\n  }\n\n  function setAdmin(address adminAddress) public onlyAdmin {\n    assembly {\n      sstore(_adminSlot, adminAddress)\n    }\n  }\n\n  function adminCall(address target, bytes calldata data) external payable onlyAdmin {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/ERC20H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC20H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC20: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC20: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC20 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the token contract.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/ERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(bytes memory /* initPayload*/) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    address currentOwner;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n      currentOwner := sload(_ownerSlot)\n    }\n    require(currentOwner != address(0), \"HOLOGRAPH: owner not set\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal view returns (address sender) {\n    assembly {\n      switch eq(caller(), sload(_holographerSlot))\n      case 0 {\n        sender := caller()\n      }\n      default {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure virtual returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view virtual returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    return (msgSender() == _getOwner());\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  function withdraw() external virtual onlyOwner {\n    payable(_getOwner()).transfer(address(this).balance);\n  }\n\n  event FundsReceived(address indexed source, uint256 amount);\n\n  /**\n   * @dev This function emits an event to indicate native gas token receipt. Do not rely on this to work.\n   *      Please use custom payable functions for accepting native value.\n   */\n  receive() external payable virtual {\n    emit FundsReceived(msgSender(), msg.value);\n  }\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable virtual {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "src/abstract/Initializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/InitializableInterface.sol\";\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need for a constructor\n */\nabstract contract Initializable is InitializableInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.initialized')) - 1)\n   */\n  bytes32 constant _initializedSlot = 0x4e5f991bca30eca2d4643aaefa807e88f96a4a97398933d572a3c0d973004a01;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual returns (bytes4);\n\n  function _isInitialized() internal view returns (bool initialized) {\n    assembly {\n      initialized := sload(_initializedSlot)\n    }\n  }\n\n  function _setInitialized() internal {\n    assembly {\n      sstore(_initializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "src/abstract/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract NonReentrant {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.reentrant')) - 1)\n   */\n  bytes32 constant _reentrantSlot = 0x04b524dd539523930d3901481aa9455d7752b49add99e1647adb8b09a3137279;\n\n  modifier nonReentrant() {\n    require(getStatus() != 2, \"HOLOGRAPH: reentrant call\");\n    setStatus(2);\n    _;\n    setStatus(1);\n  }\n\n  constructor() {}\n\n  function getStatus() internal view returns (uint256 status) {\n    assembly {\n      status := sload(_reentrantSlot)\n    }\n  }\n\n  function setStatus(uint256 status) internal {\n    assembly {\n      sstore(_reentrantSlot, status)\n    }\n  }\n}\n"
    },
    "src/drops/interface/IDropsPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IDropsPriceOracle {\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount);\n}\n"
    },
    "src/drops/interface/IHolographDropERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IMetadataRenderer} from \"./IMetadataRenderer.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface IHolographDropERC721 {\n  // Access errors\n\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  /// @notice Thrown when the operator for the contract is not allowed\n  /// @dev Used when strict enforcement of marketplaces for creator royalties is desired.\n  error OperatorNotAllowed(address operator);\n\n  /// @notice Thrown when there is no active market filter DAO address supported for the current chain\n  /// @dev Used for enabling and disabling filter for the given chain.\n  error MarketFilterDAOAddressNotSupportedForChain();\n\n  /// @notice Used when the operator filter registry external call fails\n  /// @dev Used for bubbling error up to clients.\n  error RemoteOperatorFilterRegistryCallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Presale is inactive\n  error Presale_Inactive();\n  /// @notice Presale merkle root is invalid\n  error Presale_MerkleNotApproved();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Too many presale for address\n  error Presale_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when metadata renderer is updated.\n  /// @param sender address of the updater\n  /// @param renderer new metadata renderer address\n  event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  /// @param publicSaleStart unix timestamp when the public sale starts\n  /// @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n  /// @param presaleStart unix timestamp when the presale starts\n  /// @param presaleEnd unix timestamp when the presale ends\n  /// @param presaleMerkleRoot merkle root for the presale information\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n  /// @param quantity to purchase\n  /// @param maxQuantity can purchase (verified by merkle root)\n  /// @param pricePerToken price per token allowed (verified by merkle root)\n  /// @param merkleProof input for merkle proof leaf verified by merkle root\n  /// @return first minted token ID\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] memory merkleProof\n  ) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (SaleDetails memory);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @notice Update the metadata renderer\n  /// @param newRenderer new address for renderer\n  /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external;\n\n  /// @notice This is an admin mint function to mint a quantity to a specific address\n  /// @param to address to mint to\n  /// @param quantity quantity to mint\n  /// @return the id of the first minted NFT\n  function adminMint(address to, uint256 quantity) external returns (uint256);\n\n  /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n  /// @param to list of addresses to mint an NFT each to\n  /// @return the id of the first minted NFT\n  function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/drops/interface/IHolographDropERC721V2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IMetadataRenderer} from \"./IMetadataRenderer.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\n\n/// @notice Interface for HOLOGRAPH Drops contract\ninterface IHolographDropERC721V2 {\n  // Access errors\n\n  /// @notice Only admin can access this function\n  error Access_OnlyAdmin();\n  /// @notice Missing the given role or admin access\n  error Access_MissingRoleOrAdmin(bytes32 role);\n  /// @notice Withdraw is not allowed by this user\n  error Access_WithdrawNotAllowed();\n  /// @notice Cannot withdraw funds due to ETH send failure.\n  error Withdraw_FundsSendFailure();\n  /// @notice Mint fee send failure\n  error MintFee_FundsSendFailure();\n\n  /// @notice Call to external metadata renderer failed.\n  error ExternalMetadataRenderer_CallFailed();\n\n  // Sale/Purchase errors\n  /// @notice Sale is inactive\n  error Sale_Inactive();\n  /// @notice Presale is inactive\n  error Presale_Inactive();\n  /// @notice Presale merkle root is invalid\n  error Presale_MerkleNotApproved();\n  /// @notice Wrong price for purchase\n  error Purchase_WrongPrice(uint256 correctPrice);\n  /// @notice NFT sold out\n  error Mint_SoldOut();\n  /// @notice Too many purchase for address\n  error Purchase_TooManyForAddress();\n  /// @notice Too many presale for address\n  error Presale_TooManyForAddress();\n  /// @notice Fee payout failed\n  error FeePaymentFailed();\n\n  // Admin errors\n  /// @notice Royalty percentage too high\n  error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n  /// @notice Invalid admin upgrade address\n  error Admin_InvalidUpgradeAddress(address proposedAddress);\n  /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n  error Admin_UnableToFinalizeNotOpenEdition();\n\n  /// @notice Event emitted for mint fee payout\n  /// @param mintFeeAmount amount of the mint fee\n  /// @param mintFeeRecipient recipient of the mint fee\n  /// @param success if the payout succeeded\n  event MintFeePayout(uint256 mintFeeAmount, address mintFeeRecipient, bool success);\n\n  /// @notice Event emitted for each sale\n  /// @param to address sale was made to\n  /// @param quantity quantity of the minted nfts\n  /// @param pricePerToken price for each token\n  /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n  event Sale(\n    address indexed to,\n    uint256 indexed quantity,\n    uint256 indexed pricePerToken,\n    uint256 firstPurchasedTokenId\n  );\n\n  /// @notice Sales configuration has been changed\n  /// @dev To access new sales configuration, use getter function.\n  /// @param changedBy Changed by user\n  event SalesConfigChanged(address indexed changedBy);\n\n  /// @notice Event emitted when the funds recipient is changed\n  /// @param newAddress new address for the funds recipient\n  /// @param changedBy address that the recipient is changed by\n  event FundsRecipientChanged(address indexed newAddress, address indexed changedBy);\n\n  /// @notice Event emitted when the funds are withdrawn from the minting contract\n  /// @param withdrawnBy address that issued the withdraw\n  /// @param withdrawnTo address that the funds were withdrawn to\n  /// @param amount amount that was withdrawn\n  event FundsWithdrawn(address indexed withdrawnBy, address indexed withdrawnTo, uint256 amount);\n\n  /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n  /// @param sender address sending close mint\n  /// @param numberOfMints number of mints the contract is finalized at\n  event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n  /// @notice Event emitted when metadata renderer is updated.\n  /// @param sender address of the updater\n  /// @param renderer new metadata renderer address\n  event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n  /// @notice Event emitted when an nfs is minted\n  /// @param recipient address that the nft was minted to\n  /// @param tokenId id of the minted nft\n  /// @param id id of the minted nft with chain id prefix\n  event NFTMinted(address indexed recipient, uint256 indexed tokenId, uint256 id);\n\n  /// @notice Admin function to update the sales configuration settings\n  /// @param publicSalePrice public sale price in ether\n  /// @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n  /// @param publicSaleStart unix timestamp when the public sale starts\n  /// @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n  /// @param presaleStart unix timestamp when the presale starts\n  /// @param presaleEnd unix timestamp when the presale ends\n  /// @param presaleMerkleRoot merkle root for the presale information\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external;\n\n  /// @notice External purchase function (payable in eth)\n  /// @param quantity to purchase\n  /// @return first minted token ID\n  function purchase(uint256 quantity) external payable returns (uint256);\n\n  /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n  /// @param quantity to purchase\n  /// @param maxQuantity can purchase (verified by merkle root)\n  /// @param pricePerToken price per token allowed (verified by merkle root)\n  /// @param merkleProof input for merkle proof leaf verified by merkle root\n  /// @return first minted token ID\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] memory merkleProof\n  ) external payable returns (uint256);\n\n  /// @notice Function to return the global sales details for the given drop\n  function saleDetails() external view returns (SaleDetails memory);\n\n  /// @notice Function to return the specific sales details for a given address\n  /// @param minter address for minter to return mint information for\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory);\n\n  /// @notice This is the opensea/public owner setting that can be set by the contract admin\n  function owner() external view returns (address);\n\n  /// @notice Update the metadata renderer\n  /// @param newRenderer new address for renderer\n  /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external;\n\n  /// @notice This is an admin mint function to mint a quantity to a specific address\n  /// @param to address to mint to\n  /// @param quantity quantity to mint\n  /// @return the id of the first minted NFT\n  function adminMint(address to, uint256 quantity) external returns (uint256);\n\n  /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n  /// @param to list of addresses to mint an NFT each to\n  /// @return the id of the first minted NFT\n  function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n  /// @dev Getter for admin role associated with the contract to handle metadata\n  /// @return boolean if address is admin\n  function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/drops/interface/IMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IMetadataRenderer {\n  function tokenURI(uint256) external view returns (string memory);\n\n  function contractURI() external view returns (string memory);\n\n  function initializeWithData(bytes memory initData) external;\n}\n"
    },
    "src/drops/interface/IOperatorFilterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IOperatorFilterRegistry {\n  function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n  function register(address registrant) external;\n\n  function registerAndSubscribe(address registrant, address subscription) external;\n\n  function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n  function updateOperator(address registrant, address operator, bool filtered) external;\n\n  function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n\n  function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n\n  function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n\n  function subscribe(address registrant, address registrantToSubscribe) external;\n\n  function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n  function subscriptionOf(address addr) external returns (address registrant);\n\n  function subscribers(address registrant) external returns (address[] memory);\n\n  function subscriberAt(address registrant, uint256 index) external returns (address);\n\n  function copyEntriesOf(address registrant, address registrantToCopy) external;\n\n  function isOperatorFiltered(address registrant, address operator) external returns (bool);\n\n  function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n\n  function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n\n  function filteredOperators(address addr) external returns (address[] memory);\n\n  function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n\n  function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n\n  function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n\n  function isRegistered(address addr) external returns (bool);\n\n  function codeHashOf(address addr) external returns (bytes32);\n\n  function unregister(address registrant) external;\n}\n"
    },
    "src/drops/library/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "src/drops/library/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nlibrary MerkleProof {\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n   * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n   * hash matches the root of the tree. When processing the proof, the pairs\n   * of leafs & pre-images are assumed to be sorted.\n   *\n   * _Available since v4.4._\n   */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n      if (computedHash <= proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = _efficientHash(computedHash, proofElement);\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = _efficientHash(proofElement, computedHash);\n      }\n    }\n    return computedHash;\n  }\n\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleArbitrumTestnetGoerli.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleArbitrumTestnetGoerli is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0x0000000000000000000000000000000000000000; // 18 decimals\n  address constant USDC = 0x0000000000000000000000000000000000000000; // 6 decimals\n  address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount)) / 2;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleArbitrumTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleArbitrumTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n// TODO: add correct addresses for Sepolia. These might not all be available at the moment so they're hardcoded values from Goerli\n//   address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n//   address constant USDC = 0x8267cF9254734C6Eb452a7bb9AAF97B392258b21; // 6 decimals\n//   address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n//   IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n//   IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n//   IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n//   IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleBase is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.tokenPriceRatio')) - 1)\n   */\n  bytes32 constant _tokenPriceRatioSlot = 0x562ce994878444f1ca8bcf3afcea513b950965abed659462312e8fdd38c020a1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_tokenPriceRatioSlot, 0x0000000000000000000000000000000000000000000000878678326eac900000)\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    // USD is with 6 decimal places\n    // WETH  is with 18 decimal places\n    // we add decimal places for USD to match WETH  decimals\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // x is always native token / WETH\n    // we use precision of 21\n    uint256 x = 1000000000000000000 * (10 ** 21);\n    // y is always USD token / USDC\n    // load token price ratio\n    uint256 tokenPriceRatio;\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n    // in our case, we use ratio for defining USD cost of 1 WETH\n    // we use precision of 21\n    uint256 y = tokenPriceRatio * (10 ** 21);\n\n    uint256 numerator = x * usdAmount;\n    uint256 denominator = y - usdAmount;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function getTokenPriceRatio() external view returns (uint256 tokenPriceRatio) {\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n  }\n\n  function setTokenPriceRatio(uint256 tokenPriceRatio) external onlyAdmin {\n    assembly {\n      sstore(_tokenPriceRatioSlot, tokenPriceRatio)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBaseTestnetGoerli.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleBaseTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.tokenPriceRatio')) - 1)\n   */\n  bytes32 constant _tokenPriceRatioSlot = 0x562ce994878444f1ca8bcf3afcea513b950965abed659462312e8fdd38c020a1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_tokenPriceRatioSlot, 0x0000000000000000000000000000000000000000000000d8d726b7177a800000)\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    // USD is with 6 decimal places\n    // WETH  is with 18 decimal places\n    // we add decimal places for USD to match WETH  decimals\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // x is always native token / WETH\n    // we use precision of 21\n    uint256 x = 1000000000000000000 * (10 ** 21);\n    // y is always USD token / USDC\n    // load token price ratio\n    uint256 tokenPriceRatio;\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n    // in our case, we use ratio for defining USD cost of 1 WETH\n    // we use precision of 21\n    uint256 y = tokenPriceRatio * (10 ** 21);\n\n    uint256 numerator = x * usdAmount;\n    uint256 denominator = y - usdAmount;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function getTokenPriceRatio() external view returns (uint256 tokenPriceRatio) {\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n  }\n\n  function setTokenPriceRatio(uint256 tokenPriceRatio) external onlyAdmin {\n    assembly {\n      sstore(_tokenPriceRatioSlot, tokenPriceRatio)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleBaseTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleBaseTestnetGoerli is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.tokenPriceRatio')) - 1)\n   */\n  bytes32 constant _tokenPriceRatioSlot = 0x562ce994878444f1ca8bcf3afcea513b950965abed659462312e8fdd38c020a1;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_tokenPriceRatioSlot, 0x0000000000000000000000000000000000000000000000d8d726b7177a800000)\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external view returns (uint256 weiAmount) {\n    // USD is with 6 decimal places\n    // WETH  is with 18 decimal places\n    // we add decimal places for USD to match WETH  decimals\n    usdAmount = usdAmount * (10 ** (18 - 6));\n    // x is always native token / WETH\n    // we use precision of 21\n    uint256 x = 1000000000000000000 * (10 ** 21);\n    // y is always USD token / USDC\n    // load token price ratio\n    uint256 tokenPriceRatio;\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n    // in our case, we use ratio for defining USD cost of 1 WETH\n    // we use precision of 21\n    uint256 y = tokenPriceRatio * (10 ** 21);\n\n    uint256 numerator = x * usdAmount;\n    uint256 denominator = y - usdAmount;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function getTokenPriceRatio() external view returns (uint256 tokenPriceRatio) {\n    assembly {\n      tokenPriceRatio := sload(_tokenPriceRatioSlot)\n    }\n  }\n\n  function setTokenPriceRatio(uint256 tokenPriceRatio) external onlyAdmin {\n    assembly {\n      sstore(_tokenPriceRatioSlot, tokenPriceRatio)\n    }\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleEthereumTestnetGoerli.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleEthereumTestnetGoerli is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n  address constant USDC = 0x07865c6E87B9F70255377e024ace6630C1Eaa37F; // 6 decimals\n  address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleEthereumTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleEthereumTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n// TODO: add correct addresses for Sepolia. These might not all be available at the moment so they're hardcoded values from Goerli\n//   address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n//   address constant USDC = 0x8267cF9254734C6Eb452a7bb9AAF97B392258b21; // 6 decimals\n//   address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n//   IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n//   IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n//   IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n//   IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleOptimismTestnetGoerli.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleOptimismTestnetGoerli is Admin, Initializable, IDropsPriceOracle {\n  address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n  address constant USDC = 0x07865c6E87B9F70255377e024ace6630C1Eaa37F; // 6 decimals\n  address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n  IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n  IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n  IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleOptimismTestnetSepolia.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {IUniswapV2Pair} from \"./interface/IUniswapV2Pair.sol\";\n\ncontract DropsPriceOracleOptimismTestnetSepolia is Admin, Initializable, IDropsPriceOracle {\n// TODO: add correct addresses for Sepolia. These might not all be available at the moment so they're hardcoded values from Goerli\n//   address constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // 18 decimals\n//   address constant USDC = 0x8267cF9254734C6Eb452a7bb9AAF97B392258b21; // 6 decimals\n//   address constant USDT = 0x0000000000000000000000000000000000000000; // 6 decimals\n\n//   IUniswapV2Pair constant SushiV2UsdcPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n//   IUniswapV2Pair constant SushiV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n//   IUniswapV2Pair constant UniV2UsdcPool = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n//   IUniswapV2Pair constant UniV2UsdtPool = IUniswapV2Pair(0x0000000000000000000000000000000000000000);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount =\n      (_getSushiUSDC(usdAmount) + _getSushiUSDT(usdAmount) + _getUniUSDC(usdAmount) + _getUniUSDT(usdAmount)) /\n      4;\n  }\n\n  function _getSushiUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 14248413024234;\n    uint112 _reserve1 = 8237558200010903232972;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getSushiUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 7190540826553156156218;\n    uint112 _reserve1 = 12394808861997;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdcPool.getReserves();\n    uint112 _reserve0 = 27969935741431;\n    uint112 _reserve1 = 16175569695347837629371;\n    // x is always native token / WETH\n    uint256 x = _reserve1;\n    // y is always USD token / USDC\n    uint256 y = _reserve0;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUniUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = UniV2UsdtPool.getReserves();\n    uint112 _reserve0 = 16492332449237327237450;\n    uint112 _reserve1 = 28443279643692;\n    // x is always native token / WETH\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/DropsPriceOracleZoraTestnetGoerli.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {Admin} from \"../../abstract/Admin.sol\";\nimport {Initializable} from \"../../abstract/Initializable.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\ncontract DropsPriceOracleZoraTestnetGoerli is Admin, Initializable, IDropsPriceOracle {\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   */\n  function init(bytes memory) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n    _setInitialized();\n    return Initializable.init.selector;\n  }\n\n  /**\n   * @notice Convert USD value to native gas token value\n   * @dev It is important to note that different USD stablecoins use different decimal places.\n   * @param usdAmount a 6 decimal places USD amount\n   */\n  function convertUsdToWei(uint256 usdAmount) external pure returns (uint256 weiAmount) {\n    weiAmount = (_getUSDC(usdAmount) + _getUSDT(usdAmount)) / 2;\n  }\n\n  function _getUSDC(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdcPool.getReserves();\n    uint112 _reserve0 = 185186616552407552407157;\n    uint112 _reserve1 = 207981749778;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDC\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n\n  function _getUSDT(uint256 usdAmount) internal pure returns (uint256 weiAmount) {\n    // add decimal places for amount IF decimals are above 6!\n    // usdAmount = usdAmount * (10**(18 - 6));\n    // (uint112 _reserve0, uint112 _reserve1,) = SushiV2UsdtPool.getReserves();\n    uint112 _reserve0 = 13799757434002573084810;\n    uint112 _reserve1 = 15484391886;\n    // x is always native token / WMATIC\n    uint256 x = _reserve0;\n    // y is always USD token / USDT\n    uint256 y = _reserve1;\n\n    uint256 numerator = (x * usdAmount) * 1000;\n    uint256 denominator = (y - usdAmount) * 997;\n\n    weiAmount = (numerator / denominator) + 1;\n  }\n}\n"
    },
    "src/drops/oracle/interface/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "src/drops/struct/AddressMintDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return type of specific mint counts and details per address\nstruct AddressMintDetails {\n  /// Number of total mints from the given address\n  uint256 totalMints;\n  /// Number of presale mints from the given address\n  uint256 presaleMints;\n  /// Number of public mints from the given address\n  uint256 publicMints;\n}\n"
    },
    "src/drops/struct/Configuration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\n\n/// @notice General configuration for NFT Minting and bookkeeping\nstruct Configuration {\n  /// @dev Metadata renderer (uint160)\n  IMetadataRenderer metadataRenderer;\n  /// @dev Total size of edition that can be minted (uint160+64 = 224)\n  uint64 editionSize;\n  /// @dev Royalty amount in bps (uint224+16 = 240)\n  uint16 royaltyBPS;\n  /// @dev Funds recipient for sale (new slot, uint160)\n  address payable fundsRecipient;\n}\n"
    },
    "src/drops/struct/DropsInitializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {SalesConfiguration} from \"./SalesConfiguration.sol\";\n\n/// @param erc721TransferHelper Transfer helper contract\n/// @param marketFilterAddress Market filter address - Manage subscription to the for marketplace filtering based off royalty payouts.\n/// @param initialOwner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\n/// @param fundsRecipient Wallet/user that receives funds from sale\n/// @param editionSize Number of editions that can be minted in total. If type(uint64).max, unlimited editions can be minted as an open edition.\n/// @param royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\n/// @param salesConfiguration The initial SalesConfiguration\n/// @param metadataRenderer Renderer contract to use\n/// @param metadataRendererInit Renderer data initial contract\nstruct DropsInitializer {\n  address erc721TransferHelper;\n  address marketFilterAddress;\n  address initialOwner;\n  address payable fundsRecipient;\n  uint64 editionSize;\n  uint16 royaltyBPS;\n  bool enableOpenSeaRoyaltyRegistry;\n  SalesConfiguration salesConfiguration;\n  address metadataRenderer;\n  bytes metadataRendererInit;\n}\n"
    },
    "src/drops/struct/DropsInitializerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport {SalesConfiguration} from \"./SalesConfiguration.sol\";\n\n/// @param initialOwner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\n/// @param fundsRecipient Wallet/user that receives funds from sale\n/// @param editionSize Number of editions that can be minted in total. If type(uint64).max, unlimited editions can be minted as an open edition.\n/// @param royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\n/// @param salesConfiguration The initial SalesConfiguration\n/// @param metadataRenderer Renderer contract to use\n/// @param metadataRendererInit Renderer data initial contract\nstruct DropsInitializerV2 {\n  address initialOwner;\n  address payable fundsRecipient;\n  uint64 editionSize;\n  uint16 royaltyBPS;\n  SalesConfiguration salesConfiguration;\n  address metadataRenderer;\n  bytes metadataRendererInit;\n}\n"
    },
    "src/drops/struct/SaleDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Return value for sales details to use with front-ends\nstruct SaleDetails {\n  // Synthesized status variables for sale and presale\n  bool publicSaleActive;\n  bool presaleActive;\n  // Price for public sale\n  uint256 publicSalePrice;\n  // Timed sale actions for public sale\n  uint64 publicSaleStart;\n  uint64 publicSaleEnd;\n  // Timed sale actions for presale\n  uint64 presaleStart;\n  uint64 presaleEnd;\n  // Merkle root (includes address, quantity, and price data for each entry)\n  bytes32 presaleMerkleRoot;\n  // Limit public sale to a specific number of mints per wallet\n  uint256 maxSalePurchasePerAddress;\n  // Information about the rest of the supply\n  // Total that have been minted\n  uint256 totalMinted;\n  // The total supply available\n  uint256 maxSupply;\n}\n"
    },
    "src/drops/struct/SalesConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/// @notice Sales states and configuration\n/// @dev Uses 3 storage slots\nstruct SalesConfiguration {\n  /// @dev Public sale price (max ether value > 1000 ether with this value)\n  uint104 publicSalePrice;\n  /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n  /// @dev Max purchase number per txn (90+32 = 122)\n  uint32 maxSalePurchasePerAddress;\n  /// @dev uint64 type allows for dates into 292 billion years\n  /// @notice Public sale start timestamp (136+64 = 186)\n  uint64 publicSaleStart;\n  /// @notice Public sale end timestamp (186+64 = 250)\n  uint64 publicSaleEnd;\n  /// @notice Presale start timestamp\n  /// @dev new storage slot\n  uint64 presaleStart;\n  /// @notice Presale end timestamp\n  uint64 presaleEnd;\n  /// @notice Presale merkle root\n  bytes32 presaleMerkleRoot;\n}\n"
    },
    "src/drops/token/HolographDropERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../../abstract/NonReentrant.sol\";\n\nimport {HolographERC721Interface} from \"../../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../../interface/HolographInterface.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {Configuration} from \"../struct/Configuration.sol\";\nimport {DropsInitializer} from \"../struct/DropsInitializer.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\nimport {SalesConfiguration} from \"../struct/SalesConfiguration.sol\";\n\nimport {Address} from \"../library/Address.sol\";\nimport {MerkleProof} from \"../library/MerkleProof.sol\";\n\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\nimport {IOperatorFilterRegistry} from \"../interface/IOperatorFilterRegistry.sol\";\nimport {IHolographDropERC721} from \"../interface/IHolographDropERC721.sol\";\n\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - beforeSafeTransfer\n *       - beforeTransfer\n *       - onIsApprovedForAll\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified your source code for them.\n */\ncontract HolographDropERC721 is NonReentrant, ERC721H, IHolographDropERC721 {\n  /**\n   * CONTRACT VARIABLES\n   * all variables, without custom storage slots, are defined here\n   */\n\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.osRegistryEnabled')) - 1)\n   */\n  bytes32 constant _osRegistryEnabledSlot = 0x5c835f3b6bd322d9a084ffdeac746df2b96cce308e7f0612f4ff4f9c490734cc;\n\n  /**\n   * @dev Address of the operator filter registry\n   */\n  IOperatorFilterRegistry public constant openseaOperatorFilterRegistry =\n    IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev HOLOGRAPH transfer helper address for auto-approval\n   */\n  address public erc721TransferHelper;\n\n  /**\n   * @dev Address of the market filter registry\n   */\n  address public marketFilterAddress;\n\n  /// @notice Holograph Mint Fee\n  uint256 public constant HOLOGRAPH_MINT_FEE = 1000000; // $1.00 USD (6 decimal places)\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Configuration for NFT minting contract storage\n   */\n  Configuration public config;\n\n  /**\n   * @notice Sales configuration\n   */\n  SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public presaleMintsByAddress;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /**\n   * CUSTOM ERRORS\n   */\n\n  /**\n   * @notice Thrown when there is no active market filter address supported for the current chain\n   * @dev Used for enabling and disabling filter for the given chain.\n   */\n  error MarketFilterAddressNotSupportedForChain();\n\n  /**\n   * MODIFIERS\n   */\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    if (config.editionSize != 0 && quantity + _currentTokenId > config.editionSize) {\n      revert Mint_SoldOut();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Presale active\n   */\n  modifier onlyPresaleActive() {\n    if (!_presaleActive()) {\n      revert Presale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * CONTRACT INITIALIZERS\n   * init function is used instead of constructor\n   */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    DropsInitializer memory initializer = abi.decode(initPayload, (DropsInitializer));\n\n    erc721TransferHelper = initializer.erc721TransferHelper;\n    if (initializer.marketFilterAddress != address(0)) {\n      marketFilterAddress = initializer.marketFilterAddress;\n    }\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // to enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Setup config variables\n    config = Configuration({\n      metadataRenderer: IMetadataRenderer(initializer.metadataRenderer),\n      editionSize: initializer.editionSize,\n      royaltyBPS: initializer.royaltyBPS,\n      fundsRecipient: initializer.fundsRecipient\n    });\n\n    salesConfig = initializer.salesConfiguration;\n\n    // TODO: Need to make sure to initialize the metadata renderer\n    if (initializer.metadataRenderer != address(0)) {\n      IMetadataRenderer(initializer.metadataRenderer).initializeWithData(initializer.metadataRendererInit);\n    }\n\n    if (initializer.enableOpenSeaRoyaltyRegistry && Address.isContract(address(openseaOperatorFilterRegistry))) {\n      if (marketFilterAddress == address(0)) {\n        // this is a default filter that can be used for OS royalty filtering\n        // marketFilterAddress = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\n        // we just register to OS royalties and let OS handle it for us with their default filter contract\n        HolographERC721Interface(holographer()).sourceExternalCall(\n          address(openseaOperatorFilterRegistry),\n          abi.encodeWithSelector(IOperatorFilterRegistry.register.selector, holographer())\n        );\n      } else {\n        // allow user to specify custom filtering contract address\n        HolographERC721Interface(holographer()).sourceExternalCall(\n          address(openseaOperatorFilterRegistry),\n          abi.encodeWithSelector(\n            IOperatorFilterRegistry.registerAndSubscribe.selector,\n            holographer(),\n            marketFilterAddress\n          )\n        );\n      }\n      assembly {\n        sstore(_osRegistryEnabledSlot, true)\n      }\n    }\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * static\n   */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version string representing the version of the contract\n   */\n  function version() external pure returns (string memory) {\n    return \"1.0.0\";\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(IHolographDropERC721).interfaceId;\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * dynamic\n   */\n\n  function owner() external view override(ERC721H, IHolographDropERC721) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  function beforeSafeTransfer(\n    address _from,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external view returns (bool) {\n    if (\n      _from != address(0) && // skip on mints\n      _from != msgSender() // skip on transfers from sender\n    ) {\n      bool osRegistryEnabled;\n      assembly {\n        osRegistryEnabled := sload(_osRegistryEnabledSlot)\n      }\n      if (osRegistryEnabled) {\n        try openseaOperatorFilterRegistry.isOperatorAllowed(address(this), msgSender()) returns (bool allowed) {\n          return allowed;\n        } catch {\n          revert OperatorNotAllowed(msgSender());\n        }\n      }\n    }\n    return true;\n  }\n\n  function beforeTransfer(\n    address _from,\n    address /* _to*/,\n    uint256 /* _tokenId*/,\n    bytes calldata /* _data*/\n  ) external view returns (bool) {\n    if (\n      _from != address(0) && // skip on mints\n      _from != msgSender() // skip on transfers from sender\n    ) {\n      bool osRegistryEnabled;\n      assembly {\n        osRegistryEnabled := sload(_osRegistryEnabledSlot)\n      }\n      if (osRegistryEnabled) {\n        try openseaOperatorFilterRegistry.isOperatorAllowed(address(this), msgSender()) returns (bool allowed) {\n          return allowed;\n        } catch {\n          revert OperatorNotAllowed(msgSender());\n        }\n      }\n    }\n    return true;\n  }\n\n  function onIsApprovedForAll(address /* _wallet*/, address _operator) external view returns (bool approved) {\n    approved = (erc721TransferHelper != address(0) && _operator == erc721TransferHelper);\n  }\n\n  /**\n   * @notice Sale details\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (SaleDetails memory) {\n    return\n      SaleDetails({\n        publicSaleActive: _publicSaleActive(),\n        presaleActive: _presaleActive(),\n        publicSalePrice: salesConfig.publicSalePrice,\n        publicSaleStart: salesConfig.publicSaleStart,\n        publicSaleEnd: salesConfig.publicSaleEnd,\n        presaleStart: salesConfig.presaleStart,\n        presaleEnd: salesConfig.presaleEnd,\n        presaleMerkleRoot: salesConfig.presaleMerkleRoot,\n        totalMinted: _currentTokenId,\n        maxSupply: config.editionSize,\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress\n      });\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD\n  /// @dev Gets the Holograph protocol fee for amount of mints in USD\n  function getHolographFeeUsd(uint256 quantity) public view returns (uint256 fee) {\n    fee = HOLOGRAPH_MINT_FEE * quantity;\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in wei after conversion\n  /// @dev Gets the Holograph protocol fee for amount of mints in wei\n  function getHolographFeeWei(uint256 quantity) public view returns (uint256) {\n    return _usdToWei(HOLOGRAPH_MINT_FEE * quantity);\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: presaleMintsByAddress[minter],\n        publicMints: totalMintsByAddress[minter] - presaleMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @notice Contract URI Getter, proxies to metadataRenderer\n   * @return Contract URI\n   */\n  function contractURI() external view returns (string memory) {\n    return config.metadataRenderer.contractURI();\n  }\n\n  /**\n   * @notice Getter for metadataRenderer contract\n   */\n  function metadataRenderer() external view returns (IMetadataRenderer) {\n    return IMetadataRenderer(config.metadataRenderer);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /**\n   * @notice Token URI Getter, proxies to metadataRenderer\n   * @param tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    require(H721.exists(tokenId), \"ERC721: token does not exist\");\n\n    return config.metadataRenderer.tokenURI(tokenId);\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * available to all\n   */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n    uint256 holographMintFeeInWei = _usdToWei(HOLOGRAPH_MINT_FEE);\n\n    if (msg.value < (salePrice + holographMintFeeInWei) * quantity) {\n      // The error will display the wrong price that was sent in USD\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice + HOLOGRAPH_MINT_FEE) * quantity);\n    }\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity - presaleMintsByAddress[msgSender()] >\n      salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * @notice Merkle-tree based presale purchase function\n   * @param quantity quantity to purchase\n   * @param maxQuantity max quantity that can be purchased via merkle proof #\n   * @param pricePerToken price that each token is purchased at\n   * @param merkleProof proof for presale mint\n   */\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] calldata merkleProof\n  ) external payable nonReentrant canMintTokens(quantity) onlyPresaleActive returns (uint256) {\n    if (\n      !MerkleProof.verify(\n        merkleProof,\n        salesConfig.presaleMerkleRoot,\n        keccak256(\n          // address, uint256, uint256\n          abi.encode(msgSender(), maxQuantity, pricePerToken)\n        )\n      )\n    ) {\n      revert Presale_MerkleNotApproved();\n    }\n\n    uint256 weiPricePerToken = _usdToWei(pricePerToken);\n    if (msg.value < weiPricePerToken * quantity) {\n      revert Purchase_WrongPrice(pricePerToken * quantity);\n    }\n    uint256 remainder = msg.value - (weiPricePerToken * quantity);\n\n    presaleMintsByAddress[msgSender()] += quantity;\n    if (presaleMintsByAddress[msgSender()] > maxQuantity) {\n      revert Presale_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: weiPricePerToken,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * admin only\n   */\n\n  /**\n   * @notice Proxy to update market filter settings in the main registry contracts\n   * @notice Requires admin permissions\n   * @param args Calldata args to pass to the registry\n   */\n  function updateMarketFilterSettings(bytes calldata args) external onlyOwner {\n    HolographERC721Interface(holographer()).sourceExternalCall(address(openseaOperatorFilterRegistry), args);\n    bool osRegistryEnabled = openseaOperatorFilterRegistry.isRegistered(holographer());\n    assembly {\n      sstore(_osRegistryEnabledSlot, osRegistryEnabled)\n    }\n  }\n\n  /**\n   * @notice Manage subscription for marketplace filtering based off royalty payouts.\n   * @param enable Enable filtering to non-royalty payout marketplaces\n   */\n  function manageMarketFilterSubscription(bool enable) external onlyOwner {\n    address self = holographer();\n    if (marketFilterAddress == address(0)) {\n      revert MarketFilterAddressNotSupportedForChain();\n    }\n    if (!openseaOperatorFilterRegistry.isRegistered(self) && enable) {\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.registerAndSubscribe.selector, self, marketFilterAddress)\n      );\n    } else if (enable) {\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.subscribe.selector, self, marketFilterAddress)\n      );\n    } else {\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.unsubscribe.selector, self, false)\n      );\n      HolographERC721Interface(self).sourceExternalCall(\n        address(openseaOperatorFilterRegistry),\n        abi.encodeWithSelector(IOperatorFilterRegistry.unregister.selector, self)\n      );\n    }\n    bool osRegistryEnabled = openseaOperatorFilterRegistry.isRegistered(self);\n    assembly {\n      sstore(_osRegistryEnabledSlot, osRegistryEnabled)\n    }\n  }\n\n  function modifyMarketFilterAddress(address newMarketFilterAddress) external onlyOwner {\n    marketFilterAddress = newMarketFilterAddress;\n  }\n\n  /**\n   * @notice Admin mint tokens to a recipient for free\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function adminMint(address recipient, uint256 quantity) external onlyOwner canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev Mints multiple editions to the given list of addresses.\n   * @param recipients list of addresses to send the newly minted editions to\n   */\n  function adminMintAirdrop(\n    address[] calldata recipients\n  ) external onlyOwner canMintTokens(recipients.length) returns (uint256) {\n    unchecked {\n      for (uint256 i = 0; i < recipients.length; i++) {\n        _mintNFTs(recipients[i], 1);\n      }\n    }\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @notice Set a new metadata renderer\n   * @param newRenderer new renderer address to use\n   * @param setupRenderer data to setup new renderer with\n   */\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external onlyOwner {\n    config.metadataRenderer = newRenderer;\n\n    if (setupRenderer.length > 0) {\n      newRenderer.initializeWithData(setupRenderer);\n    }\n\n    emit UpdatedMetadataRenderer({sender: msgSender(), renderer: newRenderer});\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   * @param publicSaleStart unix timestamp when the public sale starts\n   * @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n   * @param presaleStart unix timestamp when the presale starts\n   * @param presaleEnd unix timestamp when the presale ends\n   * @param presaleMerkleRoot merkle root for the presale information\n   */\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n    salesConfig.publicSaleStart = publicSaleStart;\n    salesConfig.publicSaleEnd = publicSaleEnd;\n    salesConfig.presaleStart = presaleStart;\n    salesConfig.presaleEnd = presaleEnd;\n    salesConfig.presaleMerkleRoot = presaleMerkleRoot;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    config.fundsRecipient = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (config.fundsRecipient == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != config.fundsRecipient && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = config.fundsRecipient.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, config.fundsRecipient, funds);\n  }\n\n  /**\n   * @notice Admin function to finalize and open edition sale\n   */\n  function finalizeOpenEdition() external onlyOwner {\n    if (config.editionSize != type(uint64).max) {\n      revert Admin_UnableToFinalizeNotOpenEdition();\n    }\n\n    config.editionSize = uint64(_currentTokenId);\n    emit OpenMintFinalized(msgSender(), config.editionSize);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * non state changing\n   */\n\n  function _presaleActive() internal view returns (bool) {\n    return salesConfig.presaleStart <= block.timestamp && salesConfig.presaleEnd > block.timestamp;\n  }\n\n  function _publicSaleActive() internal view returns (bool) {\n    return salesConfig.publicSaleStart <= block.timestamp && salesConfig.publicSaleEnd > block.timestamp;\n  }\n\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * state changing\n   */\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n    for (uint256 i = 0; i < quantity; i++) {\n      _currentTokenId += 1;\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n      // uint256 id = chainPrepend + uint256(tokenId);\n    }\n  }\n\n  function _payoutHolographFee(uint256 quantity) internal {\n    // Transfer protocol mint fee to recipient address\n    uint256 holographMintFeeWei = getHolographFeeWei(quantity);\n\n    // Payout Holograph fee\n    address payable holographFeeRecipient = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    (bool success, ) = holographFeeRecipient.call{value: holographMintFeeWei, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!success) {\n      revert FeePaymentFailed();\n    }\n    emit MintFeePayout(holographMintFeeWei, holographFeeRecipient, success);\n  }\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    },
    "src/drops/token/HolographDropERC721V2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport {ERC721H} from \"../../abstract/ERC721H.sol\";\nimport {NonReentrant} from \"../../abstract/NonReentrant.sol\";\n\nimport {HolographERC721Interface} from \"../../interface/HolographERC721Interface.sol\";\nimport {HolographerInterface} from \"../../interface/HolographerInterface.sol\";\nimport {HolographInterface} from \"../../interface/HolographInterface.sol\";\nimport {IMetadataRenderer} from \"../interface/IMetadataRenderer.sol\";\nimport {IHolographDropERC721V2} from \"../interface/IHolographDropERC721V2.sol\";\nimport {IDropsPriceOracle} from \"../interface/IDropsPriceOracle.sol\";\nimport {HolographTreasuryInterface} from \"../../interface/HolographTreasuryInterface.sol\";\n\nimport {AddressMintDetails} from \"../struct/AddressMintDetails.sol\";\nimport {Configuration} from \"../struct/Configuration.sol\";\nimport {DropsInitializerV2} from \"../struct/DropsInitializerV2.sol\";\nimport {SaleDetails} from \"../struct/SaleDetails.sol\";\nimport {SalesConfiguration} from \"../struct/SalesConfiguration.sol\";\n\nimport {Address} from \"../library/Address.sol\";\nimport {MerkleProof} from \"../library/MerkleProof.sol\";\n\n/**\n * @dev This contract subscribes to the following HolographERC721 events:\n *       - customContractURI\n *\n *       Do not enable or subscribe to any other events unless you modified the source code for them.\n */\ncontract HolographDropERC721V2 is NonReentrant, ERC721H, IHolographDropERC721V2 {\n  /**\n   * CONTRACT VARIABLES\n   * all variables, without custom storage slots, are defined here\n   */\n\n  /**\n   * @dev Address of the price oracle proxy\n   */\n  IDropsPriceOracle public constant dropsPriceOracle = IDropsPriceOracle(0xeA7f4C52cbD4CF1036CdCa8B16AcA11f5b09cF6E);\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /// @dev Gas limit for transferring funds\n  uint256 private constant STATIC_GAS_LIMIT = 210_000;\n\n  /**\n   * @notice Configuration for NFT minting contract storage\n   */\n  Configuration public config;\n\n  /**\n   * @notice Sales configuration\n   */\n  SalesConfiguration public salesConfig;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public presaleMintsByAddress;\n\n  /**\n   * @dev Mapping for presale mint counts by address to allow public mint limit\n   */\n  mapping(address => uint256) public totalMintsByAddress;\n\n  /**\n   * CUSTOM ERRORS\n   */\n\n  /**\n   * MODIFIERS\n   */\n\n  /**\n   * @notice Allows user to mint tokens at a quantity\n   */\n  modifier canMintTokens(uint256 quantity) {\n    if (config.editionSize != 0 && quantity + _currentTokenId > config.editionSize) {\n      revert Mint_SoldOut();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Presale active\n   */\n  modifier onlyPresaleActive() {\n    if (!_presaleActive()) {\n      revert Presale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * @notice Public sale active\n   */\n  modifier onlyPublicSaleActive() {\n    if (!_publicSaleActive()) {\n      revert Sale_Inactive();\n    }\n\n    _;\n  }\n\n  /**\n   * CONTRACT INITIALIZERS\n   * init function is used instead of constructor\n   */\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n\n    DropsInitializerV2 memory initializer = abi.decode(initPayload, (DropsInitializerV2));\n\n    // Setup the owner role\n    _setOwner(initializer.initialOwner);\n\n    // to enable sourceExternalCall to work on init, we set holographer here since it's only set after init\n    assembly {\n      sstore(_holographerSlot, caller())\n    }\n\n    // Setup config variables\n    config = Configuration({\n      metadataRenderer: IMetadataRenderer(initializer.metadataRenderer),\n      editionSize: initializer.editionSize,\n      royaltyBPS: initializer.royaltyBPS,\n      fundsRecipient: initializer.fundsRecipient\n    });\n\n    salesConfig = initializer.salesConfiguration;\n\n    // Initialize metadata renderer\n    if (initializer.metadataRenderer != address(0)) {\n      IMetadataRenderer(initializer.metadataRenderer).initializeWithData(initializer.metadataRendererInit);\n    }\n\n    setStatus(1);\n\n    return _init(initPayload);\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * static\n   */\n\n  /**\n   * @notice Returns the version of the contract\n   * @dev Used for contract versioning and validation\n   * @return version of the contract\n   */\n  function version() external pure returns (uint32) {\n    return 2;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n    return interfaceId == type(IHolographDropERC721V2).interfaceId;\n  }\n\n  /**\n   * PUBLIC NON STATE CHANGING FUNCTIONS\n   * dynamic\n   */\n\n  function owner() external view override(ERC721H, IHolographDropERC721V2) returns (address) {\n    return _getOwner();\n  }\n\n  function isAdmin(address user) external view returns (bool) {\n    return (_getOwner() == user);\n  }\n\n  /**\n   * @notice Sale details\n   * @return SaleDetails sale information details\n   */\n  function saleDetails() external view returns (SaleDetails memory) {\n    return\n      SaleDetails({\n        publicSaleActive: _publicSaleActive(),\n        presaleActive: _presaleActive(),\n        publicSalePrice: salesConfig.publicSalePrice,\n        publicSaleStart: salesConfig.publicSaleStart,\n        publicSaleEnd: salesConfig.publicSaleEnd,\n        presaleStart: salesConfig.presaleStart,\n        presaleEnd: salesConfig.presaleEnd,\n        presaleMerkleRoot: salesConfig.presaleMerkleRoot,\n        totalMinted: _currentTokenId,\n        maxSupply: config.editionSize,\n        maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress\n      });\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD and is controlled by the treasury\n  /// @dev Gets the flat Holograph protocol fee for a single mint in USD\n  function getHolographFeeFromTreasury() public view returns (uint256) {\n    address payable treasuryProxyAddress = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    HolographTreasuryInterface treasury = HolographTreasuryInterface(treasuryProxyAddress);\n    return treasury.getHolographMintFee();\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in USD\n  /// @dev Gets the Holograph protocol fee for amount of mints in USD\n  function getHolographFeeUsd(uint256 quantity) public view returns (uint256 fee) {\n    fee = getHolographFeeFromTreasury() * quantity;\n  }\n\n  /// @notice The Holograph fee is a flat fee for each mint in wei after conversion\n  /// @dev Gets the Holograph protocol fee for amount of mints in wei\n  function getHolographFeeWei(uint256 quantity) public view returns (uint256) {\n    return _usdToWei(getHolographFeeFromTreasury() * quantity);\n  }\n\n  /**\n   * @dev Number of NFTs the user has minted per address\n   * @param minter to get counts for\n   */\n  function mintedPerAddress(address minter) external view returns (AddressMintDetails memory) {\n    return\n      AddressMintDetails({\n        presaleMints: presaleMintsByAddress[minter],\n        publicMints: totalMintsByAddress[minter] - presaleMintsByAddress[minter],\n        totalMints: totalMintsByAddress[minter]\n      });\n  }\n\n  /**\n   * @notice Contract URI Getter, proxies to metadataRenderer\n   * @return Contract URI\n   */\n  function contractURI() external view returns (string memory) {\n    return config.metadataRenderer.contractURI();\n  }\n\n  /**\n   * @notice Getter for metadataRenderer contract\n   */\n  function metadataRenderer() external view returns (IMetadataRenderer) {\n    return IMetadataRenderer(config.metadataRenderer);\n  }\n\n  /**\n   * @notice Convert USD price to current price in native Ether units\n   */\n  function getNativePrice() external view returns (uint256) {\n    return _usdToWei(salesConfig.publicSalePrice);\n  }\n\n  /**\n   * @notice Returns the name of the token through the holographer entrypoint\n   */\n  function name() external view returns (string memory) {\n    return HolographERC721Interface(holographer()).name();\n  }\n\n  /**\n   * @notice Token URI Getter, proxies to metadataRenderer\n   * @param tokenId id of token to get URI for\n   * @return Token URI\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    require(H721.exists(tokenId), \"ERC721: token does not exist\");\n\n    return config.metadataRenderer.tokenURI(tokenId);\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * available to all\n   */\n\n  function multicall(bytes[] memory data) public returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], msgSender()));\n    }\n  }\n\n  /**\n   * @dev This allows the user to purchase/mint a edition at the given price in the contract.\n   */\n  function purchase(\n    uint256 quantity\n  ) external payable nonReentrant canMintTokens(quantity) onlyPublicSaleActive returns (uint256) {\n    uint256 salePrice = _usdToWei(salesConfig.publicSalePrice);\n    uint256 holographMintFeeUsd = getHolographFeeFromTreasury();\n    uint256 holographMintFeeWei = _usdToWei(holographMintFeeUsd);\n\n    if (msg.value < (salePrice + holographMintFeeWei) * quantity) {\n      // The error will display what the correct price should be\n      revert Purchase_WrongPrice((salesConfig.publicSalePrice + holographMintFeeUsd) * quantity);\n    }\n    uint256 remainder = msg.value - (salePrice * quantity);\n\n    // If max purchase per address == 0 there is no limit.\n    // Any other number, the per address mint limit is that.\n    if (\n      salesConfig.maxSalePurchasePerAddress != 0 &&\n      totalMintsByAddress[msgSender()] + quantity - presaleMintsByAddress[msgSender()] >\n      salesConfig.maxSalePurchasePerAddress\n    ) {\n      revert Purchase_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: salePrice,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * @notice Merkle-tree based presale purchase function\n   * @param quantity quantity to purchase\n   * @param maxQuantity max quantity that can be purchased via merkle proof #\n   * @param pricePerToken price that each token is purchased at\n   * @param merkleProof proof for presale mint\n   */\n  function purchasePresale(\n    uint256 quantity,\n    uint256 maxQuantity,\n    uint256 pricePerToken,\n    bytes32[] calldata merkleProof\n  ) external payable nonReentrant canMintTokens(quantity) onlyPresaleActive returns (uint256) {\n    if (\n      !MerkleProof.verify(\n        merkleProof,\n        salesConfig.presaleMerkleRoot,\n        keccak256(\n          // address, uint256, uint256\n          abi.encode(msgSender(), maxQuantity, pricePerToken)\n        )\n      )\n    ) {\n      revert Presale_MerkleNotApproved();\n    }\n\n    uint256 weiPricePerToken = _usdToWei(pricePerToken);\n    if (msg.value < weiPricePerToken * quantity) {\n      revert Purchase_WrongPrice(pricePerToken * quantity);\n    }\n    uint256 remainder = msg.value - (weiPricePerToken * quantity);\n\n    presaleMintsByAddress[msgSender()] += quantity;\n    if (presaleMintsByAddress[msgSender()] > maxQuantity) {\n      revert Presale_TooManyForAddress();\n    }\n\n    // First mint the NFTs\n    _mintNFTs(msgSender(), quantity);\n\n    // Then send the Holograph fee to the recipient (currently the Holograph Treasury)\n    _payoutHolographFee(quantity);\n\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint256 firstMintedTokenId = (chainPrepend + uint256(_currentTokenId - quantity)) + 1;\n\n    emit Sale({\n      to: msgSender(),\n      quantity: quantity,\n      pricePerToken: weiPricePerToken,\n      firstPurchasedTokenId: firstMintedTokenId\n    });\n\n    // Refund any overpayment\n    if (remainder > 0) {\n      msgSender().call{value: remainder, gas: gasleft() > STATIC_GAS_LIMIT ? STATIC_GAS_LIMIT : gasleft()}(\"\");\n    }\n\n    return firstMintedTokenId;\n  }\n\n  /**\n   * PUBLIC STATE CHANGING FUNCTIONS\n   * admin only\n   */\n\n  /**\n   * @notice Admin mint tokens to a recipient for free\n   * @param recipient recipient to mint to\n   * @param quantity quantity to mint\n   */\n  function adminMint(address recipient, uint256 quantity) external onlyOwner canMintTokens(quantity) returns (uint256) {\n    _mintNFTs(recipient, quantity);\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @dev Mints multiple editions to the given list of addresses.\n   * @param recipients list of addresses to send the newly minted editions to\n   */\n  function adminMintAirdrop(\n    address[] calldata recipients\n  ) external onlyOwner canMintTokens(recipients.length) returns (uint256) {\n    unchecked {\n      for (uint256 i = 0; i < recipients.length; i++) {\n        _mintNFTs(recipients[i], 1);\n      }\n    }\n\n    return _currentTokenId;\n  }\n\n  /**\n   * @notice Set a new metadata renderer\n   * @param newRenderer new renderer address to use\n   * @param setupRenderer data to setup new renderer with\n   */\n  function setMetadataRenderer(IMetadataRenderer newRenderer, bytes memory setupRenderer) external onlyOwner {\n    config.metadataRenderer = newRenderer;\n\n    if (setupRenderer.length > 0) {\n      newRenderer.initializeWithData(setupRenderer);\n    }\n\n    emit UpdatedMetadataRenderer({sender: msgSender(), renderer: newRenderer});\n  }\n\n  /**\n   * @dev This sets the sales configuration\n   * @param publicSalePrice New public sale price\n   * @param maxSalePurchasePerAddress Max # of purchases (public) per address allowed\n   * @param publicSaleStart unix timestamp when the public sale starts\n   * @param publicSaleEnd unix timestamp when the public sale ends (set to 0 to disable)\n   * @param presaleStart unix timestamp when the presale starts\n   * @param presaleEnd unix timestamp when the presale ends\n   * @param presaleMerkleRoot merkle root for the presale information\n   */\n  function setSaleConfiguration(\n    uint104 publicSalePrice,\n    uint32 maxSalePurchasePerAddress,\n    uint64 publicSaleStart,\n    uint64 publicSaleEnd,\n    uint64 presaleStart,\n    uint64 presaleEnd,\n    bytes32 presaleMerkleRoot\n  ) external onlyOwner {\n    salesConfig.publicSalePrice = publicSalePrice;\n    salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n    salesConfig.publicSaleStart = publicSaleStart;\n    salesConfig.publicSaleEnd = publicSaleEnd;\n    salesConfig.presaleStart = presaleStart;\n    salesConfig.presaleEnd = presaleEnd;\n    salesConfig.presaleMerkleRoot = presaleMerkleRoot;\n\n    emit SalesConfigChanged(msgSender());\n  }\n\n  /**\n   * @notice Set a different funds recipient\n   * @param newRecipientAddress new funds recipient address\n   */\n  function setFundsRecipient(address payable newRecipientAddress) external onlyOwner {\n    if (newRecipientAddress == address(0)) {\n      revert(\"Funds Recipient cannot be 0 address\");\n    }\n    config.fundsRecipient = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, msgSender());\n  }\n\n  /**\n   * @notice This withdraws native tokens from the contract to the contract owner.\n   */\n  function withdraw() external override nonReentrant {\n    if (config.fundsRecipient == address(0)) {\n      revert(\"Funds Recipient address not set\");\n    }\n    address sender = msgSender();\n\n    // Get the contract balance\n    uint256 funds = address(this).balance;\n\n    // Check if withdraw is allowed for sender\n    if (sender != config.fundsRecipient && sender != _getOwner()) {\n      revert Access_WithdrawNotAllowed();\n    }\n\n    // Payout recipient\n    (bool successFunds, ) = config.fundsRecipient.call{value: funds, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!successFunds) {\n      revert Withdraw_FundsSendFailure();\n    }\n\n    // Emit event for indexing\n    emit FundsWithdrawn(sender, config.fundsRecipient, funds);\n  }\n\n  /**\n   * @notice Admin function to finalize and open edition sale\n   */\n  function finalizeOpenEdition() external onlyOwner {\n    if (config.editionSize != type(uint64).max) {\n      revert Admin_UnableToFinalizeNotOpenEdition();\n    }\n\n    config.editionSize = uint64(_currentTokenId);\n    emit OpenMintFinalized(msgSender(), config.editionSize);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * non state changing\n   */\n\n  function _presaleActive() internal view returns (bool) {\n    return salesConfig.presaleStart <= block.timestamp && salesConfig.presaleEnd > block.timestamp;\n  }\n\n  function _publicSaleActive() internal view returns (bool) {\n    return salesConfig.publicSaleStart <= block.timestamp && salesConfig.publicSaleEnd > block.timestamp;\n  }\n\n  function _usdToWei(uint256 amount) internal view returns (uint256 weiAmount) {\n    if (amount == 0) {\n      return 0;\n    }\n    weiAmount = dropsPriceOracle.convertUsdToWei(amount);\n  }\n\n  /**\n   * INTERNAL FUNCTIONS\n   * state changing\n   */\n\n  function _mintNFTs(address recipient, uint256 quantity) internal {\n    HolographERC721Interface H721 = HolographERC721Interface(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    uint224 tokenId = 0;\n    for (uint256 i = 0; i < quantity; i++) {\n      _currentTokenId += 1;\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n      H721.sourceMint(recipient, tokenId);\n\n      uint256 id = chainPrepend + uint256(tokenId);\n      emit NFTMinted(recipient, tokenId, id);\n    }\n  }\n\n  function _payoutHolographFee(uint256 quantity) internal {\n    // Transfer protocol mint fee to recipient address\n    uint256 holographMintFeeWei = getHolographFeeWei(quantity);\n\n    // Payout Holograph fee\n    address payable holographFeeRecipient = payable(\n      HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury()\n    );\n\n    (bool success, ) = holographFeeRecipient.call{value: holographMintFeeWei, gas: STATIC_GAS_LIMIT}(\"\");\n    if (!success) {\n      revert FeePaymentFailed();\n    }\n    emit MintFeePayout(holographMintFeeWei, holographFeeRecipient, success);\n  }\n\n  fallback() external payable override {\n    assembly {\n      // Allocate memory for the error message\n      let errorMsg := mload(0x40)\n\n      // Error message: \"Function not found\", properly padded with zeroes\n      mstore(errorMsg, 0x46756e6374696f6e206e6f7420666f756e640000000000000000000000000000)\n\n      // Revert with the error message\n      revert(errorMsg, 20) // 20 is the length of the error message in bytes\n    }\n  }\n}\n"
    },
    "src/enum/ChainIdType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum ChainIdType {\n  UNDEFINED, //  0\n  EVM, //        1\n  HOLOGRAPH, //  2\n  LAYERZERO, //  3\n  HYPERLANE //   4\n}\n"
    },
    "src/enum/InterfaceType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum InterfaceType {\n  UNDEFINED, // 0\n  ERC20, //     1\n  ERC721, //    2\n  ERC1155, //   3\n  ROYALTIES, // 4\n  GENERIC //    5\n}\n"
    },
    "src/enum/TokenUriType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum TokenUriType {\n  UNDEFINED, //   0\n  IPFS, //        1\n  HTTPS, //       2\n  ARWEAVE //      3\n}\n"
    },
    "src/HolographGenesis.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./interface/InitializableInterface.sol\";\n\n/**\n * @title HOLOGRAPH GENESIS\n * @dev In the beginning there was a smart contract...\n */\ncontract HolographGenesis {\n  uint32 private immutable _version;\n\n  // Nonce to prevent replay attacks on deployer approvals\n  uint256 private _approveDeployerNonce;\n\n  // Immutable addresses of the initial deployers\n  address private immutable deployer1 = 0xBB566182f35B9E5Ae04dB02a5450CC156d2f89c1;\n  address private immutable deployer2 = 0x22ED36947DDd1ae317F7816c410D3c0c58Bb9b90;\n  address private immutable deployer3 = 0xFfCA0d6986099FbDb3b6AD9b6aa5DF5ed1d44f0C;\n  address private immutable deployer4 = 0xDF9013a9Af763b181EF8acFC0e3229494004e001;\n  address private immutable deployer5 = 0x00Ac9Fd50C63f176B49F05FfedA324bD68C7cD69;\n\n  // Mapping of addresses that are approved deployers\n  mapping(address => bool) private _approvedDeployers;\n\n  // Events\n  event Message(string message);\n  event ContractDeployed(address deployedContract);\n\n  // Modifier to restrict function calls to approved deployers\n  modifier onlyDeployer() {\n    require(_approvedDeployers[msg.sender], \"HOLOGRAPH: deployer not approved\");\n    _;\n  }\n\n  /**\n   * @dev Sets the initial deployers as approved upon contract creation.\n   */\n  constructor() {\n    _version = 2;\n\n    // Set the immutable deployers as approved\n    _approvedDeployers[deployer1] = true;\n    _approvedDeployers[deployer2] = true;\n    _approvedDeployers[deployer3] = true;\n    _approvedDeployers[deployer4] = true;\n    _approvedDeployers[deployer5] = true;\n\n    emit Message(\"The future is Holographic\");\n  }\n\n  /**\n   * @dev Deploy a contract using the EIP-1014 (create2) opcode for deterministic addresses.\n   * @param chainId The chain on which to deploy\n   * @param saltHash A unique salt for contract creation\n   * @param secret A secret part of the salt\n   * @param sourceCode The bytecode of the contract to deploy\n   * @param initCode The initialization code for the contract\n   */\n  function deploy(\n    uint256 chainId,\n    bytes12 saltHash,\n    bytes20 secret,\n    bytes memory sourceCode,\n    bytes memory initCode\n  ) external onlyDeployer {\n    require(chainId == block.chainid, \"HOLOGRAPH: incorrect chain id\");\n    bytes32 salt = bytes32(abi.encodePacked(secret, saltHash));\n    address contractAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(sourceCode)))))\n    );\n    require(!_isContract(contractAddress), \"HOLOGRAPH: already deployed\");\n    assembly {\n      contractAddress := create2(0, add(sourceCode, 0x20), mload(sourceCode), salt)\n    }\n    require(_isContract(contractAddress), \"HOLOGRAPH: deployment failed\");\n    require(\n      InitializableInterface(contractAddress).init(initCode) == InitializableInterface.init.selector,\n      \"HOLOGRAPH: initialization failed\"\n    );\n\n    emit ContractDeployed(contractAddress);\n  }\n\n  /**\n   * @dev Check if an address is an approved deployer.\n   * @param deployer Address to check\n   * @return bool representing approval status\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool) {\n    return _approvedDeployers[deployer];\n  }\n\n  /**\n   * @dev Internal function to determine if an address is a deployed contract.\n   * @param contractAddress The address to check\n   * @return bool representing if the address is a contract\n   */\n  function _isContract(address contractAddress) internal view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Approve or disapprove a deployer using multi-signature verification.\n   * @param nonce A unique nonce\n   * @param newDeployer The address of the deployer to approve or disapprove\n   * @param approve Boolean representing the approval status\n   * @param sig1 The first signature for multisig\n   * @param sig2 The second signature for multisig\n   */\n  function approveDeployer(\n    uint256 nonce,\n    address newDeployer,\n    bool approve,\n    bytes memory sig1,\n    bytes memory sig2\n  ) external onlyDeployer {\n    require(nonce > _approveDeployerNonce, \"HOLOGRAPH: invalid nonce\");\n    _approveDeployerNonce = nonce; // Update the nonce\n\n    // Recover signers\n    address signer1 = recoverSigner(nonce, newDeployer, approve, sig1);\n    address signer2 = recoverSigner(nonce, newDeployer, approve, sig2);\n\n    // Check that both signers are approved deployers\n    require(_approvedDeployers[signer1], \"HOLOGRAPH: signer 1 not approved\");\n    require(_approvedDeployers[signer2], \"HOLOGRAPH: signer 2 not approved\");\n\n    // Ensure signatures come from two different deployers\n    require(signer1 != signer2, \"HOLOGRAPH: signatures must be from different deployers\");\n\n    // All checks passed, update the deployer approval status\n    _approvedDeployers[newDeployer] = approve;\n\n    emit Message(approve ? \"HOLOGRAPH: deployer approved\" : \"HOLOGRAPH: deployer disapproved\");\n  }\n\n  /**\n   * @dev Generates a hash of the message containing nonce, deployer address, and approval status.\n   * @param nonce Nonce used in the message\n   * @param newDeployer Address of the deployer in the message\n   * @param approve Approval status in the message\n   * @return bytes32 Ethereum signed message hash\n   */\n  function getMessageHash(\n    uint256 nonce,\n    address newDeployer,\n    bool approve\n  ) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(nonce, newDeployer, approve));\n  }\n\n  /**\n   * @dev Recreates the Ethereum signed message hash from the plain message hash.\n   * @param _messageHash The hash of the original message\n   * @return bytes32 Ethereum signed message hash\n   */\n  function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n  }\n\n  /**\n   * @dev Recovers the signer from the signature.\n   * @param nonce Nonce used in the message\n   * @param newDeployer Address of the deployer in the message\n   * @param approve Approval status in the message\n   * @param signature The signature to recover\n   * @return address of the signer\n   */\n  function recoverSigner(\n    uint256 nonce,\n    address newDeployer,\n    bool approve,\n    bytes memory signature\n  ) public pure returns (address) {\n    bytes32 messageHash = getMessageHash(nonce, newDeployer, approve);\n    bytes32 prefixedHash = getEthSignedMessageHash(messageHash);\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n\n    return ecrecover(prefixedHash, v, r, s);\n  }\n\n  /**\n   * @dev Splits a signature into its r, s, and v components.\n   * @param sig The signature to split.\n   * @return r The r component of the signature.\n   * @return s The s component of the signature.\n   * @return v The recovery id component of the signature.\n   */\n  function splitSignature(bytes memory sig)\n    internal\n    pure\n    returns (\n      bytes32 r,\n      bytes32 s,\n      uint8 v\n    )\n  {\n    require(sig.length == 65, \"Invalid signature length\");\n\n    assembly {\n      // first 32 bytes, after the length prefix\n      r := mload(add(sig, 32))\n      // second 32 bytes\n      s := mload(add(sig, 64))\n      // final byte (first byte of the next 32 bytes)\n      v := byte(0, mload(add(sig, 96)))\n    }\n  }\n\n  /**\n   * @dev Returns the current nonce for deployer approvals.\n   * @return uint256 representing the current nonce\n   */\n  function getApproveDeployerNonce() external view onlyDeployer returns (uint256) {\n    return _approveDeployerNonce;\n  }\n\n  /**\n   * @dev Returns the version number of the Genesis contract\n   * @return uint32 representing the version number\n   */\n  function getVersion() external view returns (uint32) {\n    return _version;\n  }\n}\n"
    },
    "src/HolographOperator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/CrossChainMessageInterface.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\nimport \"./interface/HolographInterfacesInterface.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./struct/OperatorJob.sol\";\n\n/**\n * @title Holograph Operator\n * @author https://github.com/holographxyz\n * @notice Participate in the Holograph Protocol by becoming an Operator\n * @dev This contract allows operators to bond utility tokens and help execute operator jobs\n */\ncontract HolographOperator is Admin, Initializable, HolographOperatorInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.jobNonce')) - 1)\n   */\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.messagingModule')) - 1)\n   */\n  bytes32 constant _messagingModuleSlot = 0x54176250282e65985d205704ffce44a59efe61f7afd99e29fda50f55b48c061a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.minGasPrice')) - 1)\n   */\n  bytes32 constant _minGasPriceSlot = 0x264d744422f7427cd080572c35c848b6cd3a36da6b47519af89ef13098b12fc0;\n\n  /**\n   * @dev Internal number (in seconds), used for defining a window for operator to execute the job\n   */\n  uint256 private _blockTime;\n\n  /**\n   * @dev Minimum amount of tokens needed for bonding\n   */\n  uint256 private _baseBondAmount;\n\n  /**\n   * @dev The multiplier used for calculating bonding amount for pods\n   */\n  uint256 private _podMultiplier;\n\n  /**\n   * @dev The threshold used for limiting number of operators in a pod\n   */\n  uint256 private _operatorThreshold;\n\n  /**\n   * @dev The threshold step used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdStep;\n\n  /**\n   * @dev The threshold divisor used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdDivisor;\n\n  /**\n   * @dev Internal counter of all cross-chain messages received\n   */\n  uint256 private _inboundMessageCounter;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => uint256) private _operatorJobs;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => bool) private _failedJobs;\n\n  /**\n   * @dev Internal mapping of operator addresses, used for temp storage when defining an operator job\n   */\n  mapping(uint256 => address) private _operatorTempStorage;\n\n  /**\n   * @dev Internal index used for storing/referencing operator temp storage\n   */\n  uint32 private _operatorTempStorageCounter;\n\n  /**\n   * @dev Multi-dimensional array of available operators\n   */\n  address[][] private _operatorPods;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _bondedOperators;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _operatorPodIndex;\n\n  /**\n   * @dev Internal mapping of bonded operator amounts\n   */\n  mapping(address => uint256) private _bondedAmounts;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (\n      address bridge,\n      address holograph,\n      address interfaces,\n      address registry,\n      address utilityToken,\n      uint256 minGasPrice\n    ) = abi.decode(initPayload, (address, address, address, address, address, uint256));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_registrySlot, registry)\n      sstore(_utilityTokenSlot, utilityToken)\n      sstore(_minGasPriceSlot, minGasPrice)\n    }\n    _blockTime = 60; // 60 seconds allowed for execution\n    unchecked {\n      _baseBondAmount = 100 * (10 ** 18); // one single token unit * 100\n    }\n    // how much to increase bond amount per pod\n    _podMultiplier = 2; // 1, 4, 16, 64\n    // starting pod max amount\n    _operatorThreshold = 1000;\n    // how often to increase price per each operator\n    _operatorThresholdStep = 10;\n    // we want to multiply by decimals, but instead will have to divide\n    _operatorThresholdDivisor = 100; // == * 0.01\n    // set first operator for each pod as zero address\n    _operatorPods = [[address(0)]];\n    // mark zero address as bonded operator, to prevent abuse\n    _bondedOperators[address(0)] = 1;\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Recover failed job\n   * @dev If a job fails, it can be manually recovered\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function recoverJob(bytes calldata bridgeInRequestPayload) external payable {\n    bytes32 hash = keccak256(bridgeInRequestPayload);\n    require(_failedJobs[hash], \"HOLOGRAPH: invalid recovery job\");\n    (bool success, ) = _bridge().call{value: msg.value}(bridgeInRequestPayload);\n    require(success, \"HOLOGRAPH: recovery failed\");\n    delete (_failedJobs[hash]);\n  }\n\n  /**\n   * @notice Execute an available operator job\n   * @dev When making this call, if operating criteria is not met, the call will revert\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable {\n    /**\n     * @dev derive the payload hash for use in mappings\n     */\n    bytes32 hash = keccak256(bridgeInRequestPayload);\n    /**\n     * @dev check that job exists\n     */\n    require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n    uint256 gasLimit = 0;\n    uint256 gasPrice = 0;\n    assembly {\n      /**\n       * @dev extract gasLimit\n       */\n      gasLimit := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x40))\n      /**\n       * @dev extract gasPrice\n       */\n      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))\n    }\n    /**\n     * @dev unpack bitwise packed operator job details\n     */\n    OperatorJob memory job = getJobDetails(hash);\n    /**\n     * @dev to prevent replay attacks, remove job from mapping\n     */\n    delete _operatorJobs[hash];\n    /**\n     * @dev operators of last resort are allowed, but they will not receive HLG rewards of any sort\n     */\n    bool isBonded = _bondedAmounts[msg.sender] != 0;\n    /**\n     * @dev check that a specific operator was selected for the job\n     */\n    if (job.operator != address(0)) {\n      /**\n       * @dev switch pod to index based value\n       */\n      uint256 pod = job.pod - 1;\n      /**\n       * @dev check if sender is not the selected primary operator\n       */\n      if (job.operator != msg.sender) {\n        /**\n         * @dev sender is not selected operator, need to check if allowed to do job\n         */\n        uint256 elapsedTime = block.timestamp - uint256(job.startTimestamp);\n        uint256 timeDifference = elapsedTime / job.blockTimes;\n        /**\n         * @dev validate that initial selected operator time slot is still active\n         */\n        require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n        /**\n         * @dev check that the selected missed the time slot due to a gas spike\n         */\n        require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n        /**\n         * @dev check if time is within fallback operator slots\n         */\n        if (timeDifference < 6) {\n          uint256 podIndex = uint256(job.fallbackOperators[timeDifference - 1]);\n          /**\n           * @dev do a quick sanity check to make sure operator did not leave from index or is a zero address\n           */\n          if (podIndex > 0 && podIndex < _operatorPods[pod].length) {\n            address fallbackOperator = _operatorPods[pod][podIndex];\n            /**\n             * @dev ensure that sender is currently valid backup operator\n             */\n            require(fallbackOperator == msg.sender, \"HOLOGRAPH: invalid fallback\");\n          } else {\n            require(_bondedOperators[msg.sender] == job.pod, \"HOLOGRAPH: pod only fallback\");\n          }\n        }\n        /**\n         * @dev time to reward the current operator\n         */\n        uint256 amount = _getBaseBondAmount(pod);\n        /**\n         * @dev select operator that failed to do the job, is slashed the pod base fee\n         */\n        _bondedAmounts[job.operator] -= amount;\n        /**\n         * @dev only allow HLG rewards to go to bonded operators\n         *      if operator is bonded, the slashed amount is sent to current operator\n         *      otherwise it's sent to HolographTreasury, can be burned or distributed from there\n         */\n        _utilityToken().transfer((isBonded ? msg.sender : address(_holograph().getTreasury())), amount);\n        /**\n         * @dev check if slashed operator has enough tokens bonded to stay\n         */\n        if (_bondedAmounts[job.operator] >= amount) {\n          /**\n           * @dev enough bond amount leftover, put operator back in\n           */\n          _operatorPods[pod].push(job.operator);\n          _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n          _bondedOperators[job.operator] = job.pod;\n        } else {\n          /**\n           * @dev slashed operator does not have enough tokens bonded, return remaining tokens only\n           */\n          uint256 leftovers = _bondedAmounts[job.operator];\n          if (leftovers > 0) {\n            _bondedAmounts[job.operator] = 0;\n            _utilityToken().transfer(job.operator, leftovers);\n          }\n        }\n      } else {\n        /**\n         * @dev the selected operator is executing the job\n         */\n        _operatorPods[pod].push(msg.sender);\n        _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n        _bondedOperators[msg.sender] = job.pod;\n      }\n    }\n    /**\n     * @dev every executed job (even if failed) increments total message counter by one\n     */\n    ++_inboundMessageCounter;\n    /**\n     * @dev reward operator (with HLG) for executing the job\n     *      this is out of scope and is purposefully omitted from code\n     *      currently no rewards are issued\n     */\n    //_utilityToken().transfer((isBonded ? msg.sender : address(_utilityToken())), (10**18));\n    /**\n     * @dev always emit an event at end of job, this helps other operators keep track of job status\n     */\n    emit FinishedOperatorJob(hash, msg.sender);\n    /**\n     * @dev ensure that there is enough has left for the job\n     */\n    require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");\n    /**\n     * @dev execute the job\n     */\n    try\n      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n        msg.sender,\n        bridgeInRequestPayload\n      )\n    {\n      /// @dev do nothing\n    } catch {\n      /// @dev return any payed funds in case of revert\n      payable(msg.sender).transfer(msg.value);\n      _failedJobs[hash] = true;\n      emit FailedOperatorJob(hash);\n    }\n  }\n\n  /*\n   * @dev Purposefully made to be external so that Operator can call it during executeJob function\n   *      Check the executeJob function to understand it's implementation\n   */\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {\n    require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");\n    assembly {\n      /**\n       * @dev remove gas price from end\n       */\n      calldatacopy(0, payload.offset, sub(payload.length, 0x20))\n      /**\n       * @dev hToken recipient is injected right before making the call\n       */\n      mstore(0x84, msgSender)\n      /**\n       * @dev make non-reverting call\n       */\n      let result := call(\n        /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n        mload(sub(payload.length, 0x40)),\n        /// @dev destination is bridge contract\n        sload(_bridgeSlot),\n        /// @dev any value is passed along\n        callvalue(),\n        /// @dev data is retrieved from 0 index memory position\n        0,\n        /// @dev everything except for last 32 bytes (gas limit) is sent\n        sub(payload.length, 0x40),\n        0,\n        0\n      )\n      if eq(result, 0) {\n        revert(0, 0)\n      }\n      return(0, 0)\n    }\n  }\n\n  /**\n   * @notice Receive a cross-chain message\n   * @dev This function is restricted for use by Holograph Messaging Module only\n   */\n  function crossChainMessage(bytes calldata bridgeInRequestPayload) external payable {\n    require(msg.sender == address(_messagingModule()), \"HOLOGRAPH: messaging only call\");\n    uint256 gasPrice = 0;\n    assembly {\n      /**\n       * @dev extract gasPrice\n       */\n      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))\n    }\n    bool underpriced = gasPrice < _minGasPrice();\n    unchecked {\n      bytes32 jobHash = keccak256(bridgeInRequestPayload);\n      /**\n       * @dev load and increment operator temp storage in one call\n       */\n      ++_operatorTempStorageCounter;\n      /**\n       * @dev use job hash, job nonce, block number, and block timestamp for generating a random number\n       */\n      uint256 random = uint256(keccak256(abi.encodePacked(jobHash, _jobNonce(), block.number, block.timestamp)));\n      // use the left 128 bits of random number\n      uint256 random1 = uint256(random >> 128);\n      // use the right 128 bits of random number\n      uint256 random2 = uint256(uint128(random));\n      // combine the two new random numbers for use in additional pod operator selection logic\n      random = uint256(keccak256(abi.encodePacked(random1 + random2)));\n      /**\n       * @dev divide by total number of pods, use modulus/remainder\n       */\n      uint256 pod = random1 % _operatorPods.length;\n      /**\n       * @dev identify the total number of available operators in pod\n       */\n      uint256 podSize = _operatorPods[pod].length;\n      /**\n       * @dev select a primary operator\n       */\n      uint256 operatorIndex = underpriced ? 0 : random2 % podSize;\n      /**\n       * @dev If operator index is 0, then it's open season! Anyone can execute this job. First come first serve\n       *      pop operator to ensure that they cannot be selected for any other job until this one completes\n       *      decrease pod size to accomodate popped operator\n       */\n      _operatorTempStorage[_operatorTempStorageCounter] = _operatorPods[pod][operatorIndex];\n      _popOperator(pod, operatorIndex);\n      if (podSize > 1) {\n        podSize--;\n      }\n      _operatorJobs[jobHash] = uint256(\n        ((pod + 1) << 248) |\n          (uint256(_operatorTempStorageCounter) << 216) |\n          (block.number << 176) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 1)) << 160) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 2)) << 144) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 3)) << 128) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 4)) << 112) |\n          ((underpriced ? 0 : _randomBlockHash(random, podSize, 5)) << 96) |\n          (block.timestamp << 16) |\n          0\n      ); // 80 next available bit position && so far 176 bits used with only 128 left\n      /**\n       * @dev emit event to signal to operators that a job has become available\n       */\n      emit AvailableOperatorJob(jobHash, bridgeInRequestPayload);\n    }\n  }\n\n  /**\n   * @notice Calculate the amount of gas needed to execute a bridgeInRequest\n   * @dev Use this function to estimate the amount of gas that will be used by the bridgeInRequest function\n   *      Set a specific gas limit when making this call, subtract return value, to get total gas used\n   *      Only use this with a static call\n   * @param bridgeInRequestPayload abi encoded bytes making up the bridgeInRequest payload\n   * @return the gas amount remaining after the static call is returned\n   */\n  function jobEstimator(bytes calldata bridgeInRequestPayload) external payable returns (uint256) {\n    assembly {\n      calldatacopy(0, bridgeInRequestPayload.offset, sub(bridgeInRequestPayload.length, 0x40))\n      /**\n       * @dev bridgeInRequest doNotRevert is purposefully set to false so a rever would happen\n       */\n      mstore8(0xE3, 0x00)\n      let result := call(gas(), sload(_bridgeSlot), callvalue(), 0, sub(bridgeInRequestPayload.length, 0x40), 0, 0)\n      /**\n       * @dev if for some reason the call does not revert, it is force reverted\n       */\n      if eq(result, 1) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      /**\n       * @dev remaining gas is set as the return value\n       */\n      mstore(0x00, gas())\n      return(0x00, 0x20)\n    }\n  }\n\n  /**\n   * @notice Send cross chain bridge request message\n   * @dev This function is restricted to only be callable by Holograph Bridge\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param nonce incremented number used to ensure job hashes are unique\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload bytes made up of the bridgeOutRequest payload\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 nonce,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external payable {\n    require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");\n    CrossChainMessageInterface messagingModule = _messagingModule();\n    uint256 hlgFee = messagingModule.getHlgFee(toChain, gasLimit, gasPrice, bridgeOutPayload);\n    address hToken = _registry().getHToken(_holograph().getHolographChainId());\n    require(hlgFee < msg.value, \"HOLOGRAPH: not enough value\");\n    payable(hToken).transfer(hlgFee);\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographBridgeInterface.bridgeInRequest.selector,\n      /**\n       * @dev job nonce is an incremented value that is assigned to each bridge request to guarantee unique hashes\n       */\n      nonce,\n      /**\n       * @dev including the current holograph chain id (origin chain)\n       */\n      _holograph().getHolographChainId(),\n      /**\n       * @dev holographable contract have the same address across all chains, so our destination address will be the same\n       */\n      holographableContract,\n      /**\n       * @dev get the current chain's hToken for native gas token\n       */\n      hToken,\n      /**\n       * @dev recipient will be defined when operator picks up the job\n       */\n      address(0),\n      /**\n       * @dev value is set to zero for now\n       */\n      hlgFee,\n      /**\n       * @dev specify that function call should not revert\n       */\n      true,\n      /**\n       * @dev attach actual holographableContract function call\n       */\n      bridgeOutPayload\n    );\n    /**\n     * @dev add gas variables to the back for later extraction\n     */\n    encodedData = abi.encodePacked(encodedData, gasLimit, gasPrice);\n    /**\n     * @dev Send the data to the current Holograph Messaging Module\n     *      This will be changed to dynamically select which messaging module to use based on destination network\n     */\n    messagingModule.send{value: msg.value - hlgFee}(\n      gasLimit,\n      gasPrice,\n      toChain,\n      msgSender,\n      msg.value - hlgFee,\n      encodedData\n    );\n    /**\n     * @dev for easy indexing, an event is emitted with the payload hash for status tracking\n     */\n    emit CrossChainMessageSent(keccak256(encodedData));\n  }\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @dev @param toChain holograph chain id of destination chain for payload\n   * @dev @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @dev @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @dev @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(uint32, uint256, uint256, bytes calldata) external view returns (uint256, uint256, uint256) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := staticcall(gas(), sload(_messagingModuleSlot), 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Get the details for an available operator job\n   * @dev The job hash is a keccak256 hash of the entire job payload\n   * @param jobHash keccak256 hash of the job\n   * @return an OperatorJob struct with details about a specific job\n   */\n  function getJobDetails(bytes32 jobHash) public view returns (OperatorJob memory) {\n    uint256 packed = _operatorJobs[jobHash];\n    /**\n     * @dev The job is bitwise packed into a single 32 byte slot, this unpacks it before returning the struct\n     */\n    return\n      OperatorJob(\n        uint8(packed >> 248),\n        uint16(_blockTime),\n        _operatorTempStorage[uint32(packed >> 216)],\n        uint40(packed >> 176),\n        // TODO: move the bit-shifting around to have it be sequential\n        uint64(packed >> 16),\n        [\n          uint16(packed >> 160),\n          uint16(packed >> 144),\n          uint16(packed >> 128),\n          uint16(packed >> 112),\n          uint16(packed >> 96)\n        ]\n      );\n  }\n\n  /**\n   * @notice Get number of pods available\n   * @dev This returns number of pods that have been opened via bonding\n   */\n  function getTotalPods() external view returns (uint256 totalPods) {\n    return _operatorPods.length;\n  }\n\n  /**\n   * @notice Get total number of operators in a pod\n   * @dev Use in conjunction with paginated getPodOperators function\n   * @param pod the pod to query\n   * @return total operators in a pod\n   */\n  function getPodOperatorsLength(uint256 pod) external view returns (uint256) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    return _operatorPods[pod - 1].length;\n  }\n\n  /**\n   * @notice Get list of operators in a pod\n   * @dev Use paginated getPodOperators function instead if list gets too long\n   * @param pod the pod to query\n   * @return operators array list of operators in a pod\n   */\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    operators = _operatorPods[pod - 1];\n  }\n\n  /**\n   * @notice Get paginated list of operators in a pod\n   * @dev Use in conjunction with getPodOperatorsLength to know the total length of results\n   * @param pod the pod to query\n   * @param index the array index to start from\n   * @param length the length of result set to be (will be shorter if reached end of array)\n   * @return operators a paginated array of operators\n   */\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    /**\n     * @dev if pod 0 is selected, this will create a revert\n     */\n    pod--;\n    /**\n     * @dev get total length of pod operators\n     */\n    uint256 supply = _operatorPods[pod].length;\n    /**\n     * @dev check if length is out of bounds for this result set\n     */\n    if (index + length > supply) {\n      /**\n       * @dev adjust length to return remainder of the results\n       */\n      length = supply - index;\n    }\n    /**\n     * @dev create in-memory array\n     */\n    operators = new address[](length);\n    /**\n     * @dev add operators to result set\n     */\n    for (uint256 i = 0; i < length; i++) {\n      operators[i] = _operatorPods[pod][index + i];\n    }\n  }\n\n  /**\n   * @notice Check the base and current price for bonding to a particular pod\n   * @dev Useful for understanding what is required for bonding to a pod\n   * @param pod the pod to get bonding amounts for\n   * @return base the base bond amount required for a pod\n   * @return current the current bond amount required for a pod\n   */\n  function getPodBondAmounts(uint256 pod) external view returns (uint256 base, uint256 current) {\n    base = _getBaseBondAmount(pod - 1);\n    current = _getCurrentBondAmount(pod - 1);\n  }\n\n  /**\n   * @notice Get an operator's currently bonded amount\n   * @dev Useful for checking how much an operator has bonded\n   * @param operator address of operator to check\n   * @return amount total number of utility token bonded\n   */\n  function getBondedAmount(address operator) external view returns (uint256 amount) {\n    return _bondedAmounts[operator];\n  }\n\n  /**\n   * @notice Get an operator's currently bonded pod\n   * @dev Useful for checking if an operator is currently bonded\n   * @param operator address of operator to check\n   * @return pod number that operator is bonded on, returns zero if not bonded or selected for job\n   */\n  function getBondedPod(address operator) external view returns (uint256 pod) {\n    return _bondedOperators[operator];\n  }\n\n  /**\n   * @notice Get an operator's currently bonded pod index\n   * @dev Useful for checking if an operator is a fallback for active job\n   * @param operator address of operator to check\n   * @return index currently bonded pod's operator index, returns zero if not in pod or moved out for active job\n   */\n  function getBondedPodIndex(address operator) external view returns (uint256 index) {\n    return _operatorPodIndex[operator];\n  }\n\n  /**\n   * @notice Topup a bonded operator with more utility tokens\n   * @dev Useful function if an operator got slashed and wants to add a safety buffer to not get unbonded\n   *      This function will not work if operator has currently been selected for a job\n   * @param operator address of operator to topup\n   * @param amount utility token amount to add\n   */\n  function topupUtilityToken(address operator, uint256 amount) external {\n    /**\n     * @dev check that an operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    unchecked {\n      /**\n       * @dev add the additional amount to operator\n       */\n      _bondedAmounts[operator] += amount;\n    }\n    /**\n     * @dev transfer tokens last, to prevent reentrancy attacks\n     */\n    require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Bond utility tokens and become an operator\n   * @dev An operator can only bond to one pod at a time, per network\n   * @param operator address of operator to bond (can be an ownable smart contract)\n   * @param amount utility token amount to bond (can be greater than minimum)\n   * @param pod number of pod to bond to (can be for one that does not exist yet)\n   */\n  function bondUtilityToken(address operator, uint256 amount, uint256 pod) external {\n    /**\n     * @dev an operator can only bond to one pod at any give time per network\n     */\n    require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n    if (_isContract(operator)) {\n      require(Ownable(operator).owner() != address(0), \"HOLOGRAPH: contract not ownable\");\n    }\n    unchecked {\n      /**\n       * @dev get the current bonding minimum for selected pod\n       */\n      uint256 current = _getCurrentBondAmount(pod - 1);\n      require(current <= amount, \"HOLOGRAPH: bond amount too small\");\n      /**\n       * @dev check if selected pod is greater than currently existing pods\n       */\n      if (_operatorPods.length < pod) {\n        /**\n         * @dev activate pod(s) up until the selected pod\n         */\n        for (uint256 i = _operatorPods.length; i < pod; i++) {\n          /**\n           * @dev add zero address into pod to mitigate empty pod issues\n           */\n          _operatorPods.push([address(0)]);\n        }\n      }\n      /**\n       * @dev prevent bonding to a pod with more than uint16 max value\n       */\n      require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");\n      _operatorPods[pod - 1].push(operator);\n      _operatorPodIndex[operator] = _operatorPods[pod - 1].length - 1;\n      _bondedOperators[operator] = pod;\n      _bondedAmounts[operator] = amount;\n      /**\n       * @dev transfer tokens last, to prevent reentrancy attacks\n       */\n      require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n    }\n  }\n\n  /**\n   * @notice Unbond HLG utility tokens and stop being an operator\n   * @dev A bonded operator selected for a job cannot unbond until they complete the job, or are slashed\n   * @param operator address of operator to unbond\n   * @param recipient address where to send the bonded tokens\n   */\n  function unbondUtilityToken(address operator, address recipient) external {\n    /**\n     * @dev validate that operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    /**\n     * @dev check if sender is not actual operator\n     */\n    if (msg.sender != operator) {\n      /**\n       * @dev check if operator is a smart contract\n       */\n      require(_isContract(operator), \"HOLOGRAPH: operator not contract\");\n      /**\n       * @dev check if smart contract is owned by sender\n       */\n      require(Ownable(operator).owner() == msg.sender, \"HOLOGRAPH: sender not owner\");\n    }\n    /**\n     * @dev get current bonded amount by operator\n     */\n    uint256 amount = _bondedAmounts[operator];\n    /**\n     * @dev unset operator bond amount before making a transfer\n     */\n    _bondedAmounts[operator] = 0;\n    /**\n     * @dev remove all operator references\n     */\n    _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);\n    /**\n     * @dev transfer tokens to recipient\n     */\n    require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Messaging Module\n   * @dev All cross-chain message requests will get forwarded to this adress\n   */\n  function getMessagingModule() external view returns (address messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Messaging Module address\n   * @param messagingModule address of the LayerZero Endpoint to use\n   */\n  function setMessagingModule(address messagingModule) external onlyAdmin {\n    assembly {\n      sstore(_messagingModuleSlot, messagingModule)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n  }\n\n  /**\n   * @notice Get the Minimum Gas Price\n   * @dev The minimum value required to execute a job without it being marked as under priced\n   */\n  function getMinGasPrice() external view returns (uint256 minGasPrice) {\n    assembly {\n      minGasPrice := sload(_minGasPriceSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Minimum Gas Price\n   * @param minGasPrice amount to set for minimum gas price\n   */\n  function setMinGasPrice(uint256 minGasPrice) external onlyAdmin {\n    assembly {\n      sstore(_minGasPriceSlot, minGasPrice)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interface\n   */\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Messaging Module Interface\n   */\n  function _messagingModule() private view returns (CrossChainMessageInterface messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Registry Interface\n   */\n  function _registry() private view returns (HolographRegistryInterface registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Utility Token Interface\n   */\n  function _utilityToken() private view returns (HolographERC20Interface utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the minimum gas price allowed\n   */\n  function _minGasPrice() private view returns (uint256 minGasPrice) {\n    assembly {\n      minGasPrice := sload(_minGasPriceSlot)\n    }\n  }\n\n  /**\n   * @dev Internal nonce, that increments on each call, used for randomness\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  /**\n   * @dev Internal function used to remove an operator from a particular pod\n   */\n  function _popOperator(uint256 pod, uint256 operatorIndex) private {\n    /**\n     * @dev only pop the operator if it's not a zero address\n     */\n    if (operatorIndex > 0) {\n      unchecked {\n        address operator = _operatorPods[pod][operatorIndex];\n        /**\n         * @dev mark operator as no longer bonded\n         */\n        _bondedOperators[operator] = 0;\n        /**\n         * @dev remove pod reference for operator\n         */\n        _operatorPodIndex[operator] = 0;\n        uint256 lastIndex = _operatorPods[pod].length - 1;\n        if (lastIndex != operatorIndex) {\n          /**\n           * @dev if operator is not last index, move last index to operator's current index\n           */\n          _operatorPods[pod][operatorIndex] = _operatorPods[pod][lastIndex];\n          _operatorPodIndex[_operatorPods[pod][operatorIndex]] = operatorIndex;\n        }\n        /**\n         * @dev delete last index\n         */\n        delete _operatorPods[pod][lastIndex];\n        /**\n         * @dev shorten array length\n         */\n        _operatorPods[pod].pop();\n      }\n    }\n  }\n\n  /**\n   * @dev Internal function used for calculating the base bonding amount for a pod\n   */\n  function _getBaseBondAmount(uint256 pod) private view returns (uint256) {\n    return (_podMultiplier ** pod) * _baseBondAmount;\n  }\n\n  /**\n   * @dev Internal function used for calculating the current bonding amount for a pod\n   */\n  function _getCurrentBondAmount(uint256 pod) private view returns (uint256) {\n    uint256 current = (_podMultiplier ** pod) * _baseBondAmount;\n    if (pod >= _operatorPods.length) {\n      return current;\n    }\n    uint256 threshold = _operatorThreshold / (2 ** pod);\n    uint256 position = _operatorPods[pod].length;\n    if (position > threshold) {\n      position -= threshold;\n      //       current += (current / _operatorThresholdDivisor) * position;\n      current += (current / _operatorThresholdDivisor) * (position / _operatorThresholdStep);\n    }\n    return current;\n  }\n\n  /**\n   * @dev Internal function used for generating a random pod operator selection by using previously mined blocks\n   */\n  function _randomBlockHash(uint256 random, uint256 podSize, uint256 n) private view returns (uint256) {\n    unchecked {\n      return (random + uint256(blockhash(block.number - n))) % podSize;\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Purposefully left empty to ensure ether transfers use least amount of gas possible\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "src/interface/CollectionURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CollectionURI {\n  function contractURI() external view returns (string memory);\n}\n"
    },
    "src/interface/CrossChainMessageInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CrossChainMessageInterface {\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 msgValue,\n    bytes calldata crossChainPayload\n  ) external payable;\n\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice);\n\n  function getHlgFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee);\n}\n"
    },
    "src/interface/ERC165.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/interface/ERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256 balance);\n\n  function transfer(address _to, uint256 _value) external returns (bool success);\n\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n  function approve(address _spender, uint256 _value) external returns (bool success);\n\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"
    },
    "src/interface/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Burnable {\n  function burn(uint256 amount) external;\n\n  function burnFrom(address account, uint256 amount) external returns (bool);\n}\n"
    },
    "src/interface/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Metadata {\n  function decimals() external view returns (uint8);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "src/interface/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity 0.8.13;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface ERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``account``'s tokens,\n   * given ``account``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `account`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``account``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address account,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `account`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``account``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/interface/ERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Receiver {\n  function onERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bytes4);\n}\n"
    },
    "src/interface/ERC20Safer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Safer {\n  function safeTransfer(address recipient, uint256 amount) external returns (bool);\n\n  function safeTransfer(address recipient, uint256 amount, bytes memory data) external returns (bool);\n\n  function safeTransferFrom(address account, address recipient, uint256 amount) external returns (bool);\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n}\n"
    },
    "src/interface/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n/* is ERC165 */\ninterface ERC721 {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param _owner An address for whom to query the balance\n  /// @return The number of NFTs owned by `_owner`, possibly zero\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param _tokenId The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf(uint256 _tokenId) external view returns (address);\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `_to` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  /// @param data Additional data with no specified format, sent in call to `_to`\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param _approved The new approved NFT controller\n  /// @param _tokenId The NFT to approve\n  function approve(address _approved, uint256 _tokenId) external payable;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param _operator Address to add to the set of authorized operators\n  /// @param _approved True if the operator is approved, false to revoke approval\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `_tokenId` is not a valid NFT.\n  /// @param _tokenId The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved(uint256 _tokenId) external view returns (address);\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param _owner The address that owns the NFTs\n  /// @param _operator The address that acts on behalf of the owner\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "src/interface/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n/* is ERC721 */\ninterface ERC721Enumerable {\n  /// @notice Count NFTs tracked by this contract\n  /// @return A count of valid NFTs tracked by this contract, where each one of\n  ///  them has an assigned and queryable owner not equal to the zero address\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Enumerate valid NFTs\n  /// @dev Throws if `_index` >= `totalSupply()`.\n  /// @param _index A counter less than `totalSupply()`\n  /// @return The token identifier for the `_index`th NFT,\n  ///  (sort order not specified)\n  function tokenByIndex(uint256 _index) external view returns (uint256);\n\n  /// @notice Enumerate NFTs assigned to an owner\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n  ///  `_owner` is the zero address, representing invalid NFTs.\n  /// @param _owner An address where we are interested in NFTs owned by them\n  /// @param _index A counter less than `balanceOf(_owner)`\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n  ///   (sort order not specified)\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "src/interface/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface ERC721Metadata {\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n\n  /// @notice An abbreviated name for NFTs in this contract\n  function symbol() external view returns (string memory _symbol);\n\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n  ///  Metadata JSON Schema\".\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "src/interface/ERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n  /// @notice Handle the receipt of an NFT\n  /// @dev The ERC721 smart contract calls this function on the recipient\n  ///  after a `transfer`. This function MAY throw to revert and reject the\n  ///  transfer. Return of other than the magic value MUST result in the\n  ///  transaction being reverted.\n  ///  Note: the contract address is always the message sender.\n  /// @param _operator The address which called `safeTransferFrom` function\n  /// @param _from The address which previously owned the token\n  /// @param _tokenId The NFT identifier which is being transferred\n  /// @param _data Additional data with no specified format\n  /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  ///  unless throwing\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4);\n}\n"
    },
    "src/interface/Holographable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Holographable {\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external returns (bytes4);\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external returns (bytes4 selector, bytes memory data);\n}\n"
    },
    "src/interface/HolographBridgeInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Holograph Bridge\n * @author https://github.com/holographxyz\n * @notice Beam any holographable contracts and assets across blockchains\n * @dev The contract abstracts all the complexities of making bridge requests and uses a universal interface to bridge any type of holographable assets\n */\ninterface HolographBridgeInterface {\n  /**\n   * @notice Receive a beam from another chain\n   * @dev This function can only be called by the Holograph Operator module\n   * @param fromChain Holograph Chain ID where the brigeOutRequest was created\n   * @param holographableContract address of the destination contract that the bridgeInRequest is targeted for\n   * @param hToken address of the hToken contract that wrapped the origin chain native gas token\n   * @param hTokenRecipient address of recipient for the hToken reward\n   * @param hTokenValue exact amount of hToken reward in wei\n   * @param doNotRevert boolean used to specify if the call should revert\n   * @param bridgeInPayload actual abi encoded bytes of the data that the holographable contract bridgeIn function will receive\n   */\n  function bridgeInRequest(\n    uint256 nonce,\n    uint32 fromChain,\n    address holographableContract,\n    address hToken,\n    address hTokenRecipient,\n    uint256 hTokenValue,\n    bool doNotRevert,\n    bytes calldata bridgeInPayload\n  ) external payable;\n\n  /**\n   * @notice Create a beam request for a destination chain\n   * @dev This function works for deploying contracts and beaming supported holographable assets across chains\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   */\n  function bridgeOutRequest(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata bridgeOutPayload\n  ) external payable;\n\n  /**\n   * @notice Do not call this function, it will always revert\n   * @dev Used by getBridgeOutRequestPayload function\n   *      It is purposefully inverted to always revert on a successful call\n   *      Marked as external and not private to allow use inside try/catch of getBridgeOutRequestPayload function\n   *      If this function does not revert and returns a string, it is the actual revert reason\n   * @param sender address of actual sender that is planning to make a bridgeOutRequest call\n   * @param toChain holograph chain id of destination chain\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   */\n  function revertedBridgeOutRequest(\n    address sender,\n    uint32 toChain,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external returns (string memory revertReason);\n\n  /**\n   * @notice Get the payload created by the bridgeOutRequest function\n   * @dev Use this function to get the payload that will be generated by a bridgeOutRequest\n   *      Only use this with a static call\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param bridgeOutPayload actual abi encoded bytes of the data that the holographable contract bridgeOut function will receive\n   * @return samplePayload bytes made up of the bridgeOutRequest payload\n   */\n  function getBridgeOutRequestPayload(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata bridgeOutPayload\n  ) external returns (bytes memory samplePayload);\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @param toChain holograph chain id of destination chain for payload\n   * @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice);\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory);\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external;\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph);\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external;\n\n  /**\n   * @notice Get the latest job nonce\n   * @dev You can use the job nonce as a way to calculate total amount of bridge requests that have been made\n   */\n  function getJobNonce() external view returns (uint256 jobNonce);\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator);\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n}\n"
    },
    "src/interface/HolographERC20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./ERC20.sol\";\nimport \"./ERC20Burnable.sol\";\nimport \"./ERC20Metadata.sol\";\nimport \"./ERC20Permit.sol\";\nimport \"./ERC20Receiver.sol\";\nimport \"./ERC20Safer.sol\";\nimport \"./ERC165.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographERC20Interface is\n  ERC165,\n  ERC20,\n  ERC20Burnable,\n  ERC20Metadata,\n  ERC20Receiver,\n  ERC20Safer,\n  ERC20Permit,\n  Holographable\n{\n  function holographBridgeMint(address to, uint256 amount) external returns (bytes4);\n\n  function sourceBurn(address from, uint256 amount) external;\n\n  function sourceMint(address to, uint256 amount) external;\n\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external;\n\n  function sourceTransfer(address from, address to, uint256 amount) external;\n\n  function sourceTransfer(address payable destination, uint256 amount) external;\n\n  function sourceExternalCall(address target, bytes calldata data) external;\n}\n"
    },
    "src/interface/HolographERC721Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./CollectionURI.sol\";\nimport \"./ERC165.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\nimport \"./ERC721TokenReceiver.sol\";\nimport \"./Holographable.sol\";\n\ninterface HolographERC721Interface is\n  ERC165,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Metadata,\n  ERC721TokenReceiver,\n  CollectionURI,\n  Holographable\n{\n  function approve(address to, uint256 tokenId) external payable;\n\n  function burn(uint256 tokenId) external;\n\n  function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n\n  function setApprovalForAll(address to, bool approved) external;\n\n  function sourceBurn(uint256 tokenId) external;\n\n  function sourceMint(address to, uint224 tokenId) external;\n\n  function sourceGetChainPrepend() external view returns (uint256);\n\n  function sourceTransfer(address to, uint256 tokenId) external;\n\n  function sourceExternalCall(address target, bytes calldata data) external;\n\n  function transfer(address to, uint256 tokenId) external payable;\n\n  function contractURI() external view returns (string memory);\n\n  function getApproved(uint256 tokenId) external view returns (address);\n\n  function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function burned(uint256 tokenId) external view returns (bool);\n\n  function decimals() external pure returns (uint256);\n\n  function exists(uint256 tokenId) external view returns (bool);\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256);\n\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "src/interface/HolographerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographerInterface {\n  function getContractType() external view returns (bytes32 contractType);\n\n  function getDeploymentBlock() external view returns (uint256 deploymentBlock);\n\n  function getHolograph() external view returns (address holograph);\n\n  function getHolographEnforcer() external view returns (address);\n\n  function getOriginChain() external view returns (uint32 originChain);\n\n  function getSourceContract() external view returns (address sourceContract);\n}\n"
    },
    "src/interface/HolographInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Holograph Protocol\n * @author https://github.com/holographxyz\n * @notice This is the primary Holograph Protocol smart contract\n * @dev This contract stores a reference to all the primary modules and variables of the protocol\n */\ninterface HolographInterface {\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge);\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external;\n\n  /**\n   * @notice Get the chain ID that the Protocol was deployed on\n   * @dev Useful for checking if/when a hard fork occurs\n   */\n  function getChainId() external view returns (uint256 chainId);\n\n  /**\n   * @notice Update the chain ID\n   * @dev Useful for updating once a hard fork has been mitigated\n   * @param chainId EVM chain ID to use\n   */\n  function setChainId(uint256 chainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Factory module\n   * @dev Used for deploying holographable smart contracts\n   */\n  function getFactory() external view returns (address factory);\n\n  /**\n   * @notice Update the Holograph Factory module address\n   * @param factory address of the Holograph Factory smart contract to use\n   */\n  function setFactory(address factory) external;\n\n  /**\n   * @notice Get the Holograph chain Id\n   * @dev Holograph uses an internal chain id mapping\n   */\n  function getHolographChainId() external view returns (uint32 holographChainId);\n\n  /**\n   * @notice Update the Holograph chain ID\n   * @dev Useful for updating once a hard fork was mitigated\n   * @param holographChainId Holograph chain ID to use\n   */\n  function setHolographChainId(uint32 holographChainId) external;\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces);\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external;\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator);\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n\n  /**\n   * @notice Get the Holograph Treasury module\n   * @dev All of the Holograph Protocol assets are stored and managed by this module\n   */\n  function getTreasury() external view returns (address treasury);\n\n  /**\n   * @notice Update the Holograph Treasury module address\n   * @param treasury address of the Holograph Treasury smart contract to use\n   */\n  function setTreasury(address treasury) external;\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken);\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external;\n}\n"
    },
    "src/interface/HolographInterfacesInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../enum/ChainIdType.sol\";\nimport \"../enum/InterfaceType.sol\";\nimport \"../enum/TokenUriType.sol\";\n\ninterface HolographInterfacesInterface {\n  function contractURI(\n    string calldata name,\n    string calldata imageURL,\n    string calldata externalLink,\n    uint16 bps,\n    address contractAddress\n  ) external pure returns (string memory);\n\n  function getUriPrepend(TokenUriType uriType) external view returns (string memory prepend);\n\n  function updateUriPrepend(TokenUriType uriType, string calldata prepend) external;\n\n  function updateUriPrepends(TokenUriType[] calldata uriTypes, string[] calldata prepends) external;\n\n  function getChainId(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType\n  ) external view returns (uint256 toChainId);\n\n  function updateChainIdMap(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType,\n    uint256 toChainId\n  ) external;\n\n  function updateChainIdMaps(\n    ChainIdType[] calldata fromChainType,\n    uint256[] calldata fromChainId,\n    ChainIdType[] calldata toChainType,\n    uint256[] calldata toChainId\n  ) external;\n\n  function supportsInterface(InterfaceType interfaceType, bytes4 interfaceId) external view returns (bool);\n\n  function updateInterface(InterfaceType interfaceType, bytes4 interfaceId, bool supported) external;\n\n  function updateInterfaces(InterfaceType interfaceType, bytes4[] calldata interfaceIds, bool supported) external;\n}\n"
    },
    "src/interface/HolographOperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../struct/OperatorJob.sol\";\n\ninterface HolographOperatorInterface {\n  /**\n   * @dev Event is emitted for every time that a valid job is available.\n   */\n  event AvailableOperatorJob(bytes32 jobHash, bytes payload);\n\n  /**\n   * @dev Event is emitted for every time that a job is completed.\n   */\n  event FinishedOperatorJob(bytes32 jobHash, address operator);\n\n  /**\n   * @dev Event is emitted every time a cross-chain message is sent\n   */\n  event CrossChainMessageSent(bytes32 messageHash);\n\n  /**\n   * @dev Event is emitted if an operator job execution fails\n   */\n  event FailedOperatorJob(bytes32 jobHash);\n\n  /**\n   * @notice Execute an available operator job\n   * @dev When making this call, if operating criteria is not met, the call will revert\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable;\n\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable;\n\n  /**\n   * @notice Receive a cross-chain message\n   * @dev This function is restricted for use by Holograph Messaging Module only\n   */\n  function crossChainMessage(bytes calldata bridgeInRequestPayload) external payable;\n\n  /**\n   * @notice Calculate the amount of gas needed to execute a bridgeInRequest\n   * @dev Use this function to estimate the amount of gas that will be used by the bridgeInRequest function\n   *      Set a specific gas limit when making this call, subtract return value, to get total gas used\n   *      Only use this with a static call\n   * @param bridgeInRequestPayload abi encoded bytes making up the bridgeInRequest payload\n   * @return the gas amount remaining after the static call is returned\n   */\n  function jobEstimator(bytes calldata bridgeInRequestPayload) external payable returns (uint256);\n\n  /**\n   * @notice Send cross chain bridge request message\n   * @dev This function is restricted to only be callable by Holograph Bridge\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param nonce incremented number used to ensure job hashes are unique\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload bytes made up of the bridgeOutRequest payload\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 nonce,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external payable;\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @param toChain holograph chain id of destination chain for payload\n   * @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   * @return dstGasPrice the amount (in wei) that destination message maximum gas price will be\n   */\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee, uint256 dstGasPrice);\n\n  /**\n   * @notice Get the details for an available operator job\n   * @dev The job hash is a keccak256 hash of the entire job payload\n   * @param jobHash keccak256 hash of the job\n   * @return an OperatorJob struct with details about a specific job\n   */\n  function getJobDetails(bytes32 jobHash) external view returns (OperatorJob memory);\n\n  /**\n   * @notice Get number of pods available\n   * @dev This returns number of pods that have been opened via bonding\n   */\n  function getTotalPods() external view returns (uint256 totalPods);\n\n  /**\n   * @notice Get total number of operators in a pod\n   * @dev Use in conjunction with paginated getPodOperators function\n   * @param pod the pod to query\n   * @return total operators in a pod\n   */\n  function getPodOperatorsLength(uint256 pod) external view returns (uint256);\n\n  /**\n   * @notice Get list of operators in a pod\n   * @dev Use paginated getPodOperators function instead if list gets too long\n   * @param pod the pod to query\n   * @return operators array list of operators in a pod\n   */\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators);\n\n  /**\n   * @notice Get paginated list of operators in a pod\n   * @dev Use in conjunction with getPodOperatorsLength to know the total length of results\n   * @param pod the pod to query\n   * @param index the array index to start from\n   * @param length the length of result set to be (will be shorter if reached end of array)\n   * @return operators a paginated array of operators\n   */\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators);\n\n  /**\n   * @notice Check the base and current price for bonding to a particular pod\n   * @dev Useful for understanding what is required for bonding to a pod\n   * @param pod the pod to get bonding amounts for\n   * @return base the base bond amount required for a pod\n   * @return current the current bond amount required for a pod\n   */\n  function getPodBondAmounts(uint256 pod) external view returns (uint256 base, uint256 current);\n\n  /**\n   * @notice Get an operator's currently bonded amount\n   * @dev Useful for checking how much an operator has bonded\n   * @param operator address of operator to check\n   * @return amount total number of utility token bonded\n   */\n  function getBondedAmount(address operator) external view returns (uint256 amount);\n\n  /**\n   * @notice Get an operator's currently bonded pod\n   * @dev Useful for checking if an operator is currently bonded\n   * @param operator address of operator to check\n   * @return pod number that operator is bonded on, returns zero if not bonded or selected for job\n   */\n  function getBondedPod(address operator) external view returns (uint256 pod);\n\n  /**\n   * @notice Get an operator's currently bonded pod index\n   * @dev Useful for checking if an operator is a fallback for active job\n   * @param operator address of operator to check\n   * @return index currently bonded pod's operator index, returns zero if not in pod or moved out for active job\n   */\n  function getBondedPodIndex(address operator) external view returns (uint256 index);\n\n  /**\n   * @notice Topup a bonded operator with more utility tokens\n   * @dev Useful function if an operator got slashed and wants to add a safety buffer to not get unbonded\n   * @param operator address of operator to topup\n   * @param amount utility token amount to add\n   */\n  function topupUtilityToken(address operator, uint256 amount) external;\n\n  /**\n   * @notice Bond utility tokens and become an operator\n   * @dev An operator can only bond to one pod at a time, per network\n   * @param operator address of operator to bond (can be an ownable smart contract)\n   * @param amount utility token amount to bond (can be greater than minimum)\n   * @param pod number of pod to bond to (can be for one that does not exist yet)\n   */\n  function bondUtilityToken(address operator, uint256 amount, uint256 pod) external;\n\n  /**\n   * @notice Unbond HLG utility tokens and stop being an operator\n   * @dev A bonded operator selected for a job cannot unbond until they complete the job, or are slashed\n   * @param operator address of operator to unbond\n   * @param recipient address where to send the bonded tokens\n   */\n  function unbondUtilityToken(address operator, address recipient) external;\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge);\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external;\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph);\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external;\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces);\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external;\n\n  /**\n   * @notice Get the address of the Holograph Messaging Module\n   * @dev All cross-chain message requests will get forwarded to this adress\n   */\n  function getMessagingModule() external view returns (address messagingModule);\n\n  /**\n   * @notice Update the Holograph Messaging Module address\n   * @param messagingModule address of the LayerZero Endpoint to use\n   */\n  function setMessagingModule(address messagingModule) external;\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry);\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external;\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken);\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external;\n\n  /**\n   * @notice Get the Minimum Gas Price\n   * @dev This amount is used as the value that will define a job as underpriced is lower than\n   */\n  function getMinGasPrice() external view returns (uint256 minGasPrice);\n\n  /**\n   * @notice Update the Minimum Gas Price\n   * @param minGasPrice amount to set for minimum gas price\n   */\n  function setMinGasPrice(uint256 minGasPrice) external;\n}\n"
    },
    "src/interface/HolographRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographRegistryInterface {\n  event HolographableContractEvent(address indexed _holographableContract, bytes _payload);\n\n  function isHolographedContract(address smartContract) external view returns (bool);\n\n  function isHolographedHashDeployed(bytes32 hash) external view returns (bool);\n\n  function referenceContractTypeAddress(address contractAddress) external returns (bytes32);\n\n  function getContractTypeAddress(bytes32 contractType) external view returns (address);\n\n  function setContractTypeAddress(bytes32 contractType, address contractAddress) external;\n\n  function getHolograph() external view returns (address holograph);\n\n  function setHolograph(address holograph) external;\n\n  function getHolographableContracts(uint256 index, uint256 length) external view returns (address[] memory contracts);\n\n  function getHolographableContractsLength() external view returns (uint256);\n\n  function getHolographedHashAddress(bytes32 hash) external view returns (address);\n\n  function setHolographedHashAddress(bytes32 hash, address contractAddress) external;\n\n  function getHToken(uint32 chainId) external view returns (address);\n\n  function setHToken(uint32 chainId, address hToken) external;\n\n  function getReservedContractTypeAddress(bytes32 contractType) external view returns (address contractTypeAddress);\n\n  function setReservedContractTypeAddress(bytes32 hash, bool reserved) external;\n\n  function setReservedContractTypeAddresses(bytes32[] calldata hashes, bool[] calldata reserved) external;\n\n  function getUtilityToken() external view returns (address utilityToken);\n\n  function setUtilityToken(address utilityToken) external;\n\n  function holographableEvent(bytes calldata payload) external;\n}\n"
    },
    "src/interface/HolographTreasuryInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographTreasuryInterface {\n  /**\n   * @notice Update the Holograph Mint Fee\n   * @param fee new fee to charge for minting holographable assets\n   */\n  function setHolographMintFee(uint256 fee) external;\n\n  /**\n   * @notice Withdraws native tokens from the contract\n   * @dev Can only be called by the admin\n   */\n  function withdraw() external;\n\n  /**\n   * @notice Withdraws native tokens from the contract to a specified address\n   * @dev Can only be called by the admin\n   * @param recipient The address to send the withdrawn funds to\n   */\n  function withdrawTo(address payable recipient) external;\n\n  /**\n   * @notice Get the Holograph Mint Fee\n   * @dev This fee is charged to mint holographable assets\n   * @return The current holograph mint fee\n   */\n  function getHolographMintFee() external view returns (uint256);\n}\n"
    },
    "src/interface/InitializableInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/**\n * @title Initializable\n * @author https://github.com/holographxyz\n * @notice Use init instead of constructor\n * @dev This allows for use of init function to make one time initializations without the need of a constructor\n */\ninterface InitializableInterface {\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external returns (bytes4);\n}\n"
    },
    "src/interface/Ownable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Ownable {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function owner() external view returns (address);\n\n  function transferOwnership(address _newOwner) external;\n\n  function isOwner() external view returns (bool);\n\n  function isOwner(address wallet) external view returns (bool);\n}\n"
    },
    "src/mock/MockHolographGenesisChild.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../HolographGenesis.sol\";\n\ncontract MockHolographGenesisChild is HolographGenesis {\n  constructor() {}\n\n  function approveDeployerMock(address newDeployer, bool approve) external onlyDeployer {\n    // TODO: Implement mock signature recovery\n    bytes memory sig1 = new bytes(0);\n    bytes memory sig2 = new bytes(0);\n\n    return this.approveDeployer(1, newDeployer, approve, sig1, sig2);\n  }\n\n  function isApprovedDeployerMock(address deployer) external view returns (bool) {\n    return this.isApprovedDeployer(deployer);\n  }\n}\n"
    },
    "src/struct/OperatorJob.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct OperatorJob {\n  uint8 pod;\n  uint16 blockTimes;\n  address operator;\n  uint40 startBlock;\n  uint64 startTimestamp;\n  uint16[5] fallbackOperators;\n}\n\n/*\n\nuint\t\tDigits\tMax value\n-----------------------------\nuint8\t\t3\t\t255\nuint16\t\t5\t\t65,535\nuint24\t\t8\t\t16,777,215\nuint32\t\t10\t\t4,294,967,295\nuint40\t\t13\t\t1,099,511,627,775\nuint48\t\t15\t\t281,474,976,710,655\nuint56\t\t17\t\t72,057,594,037,927,935\nuint64\t\t20\t\t18,446,744,073,709,551,615\nuint72\t\t22\t\t4,722,366,482,869,645,213,695\nuint80\t\t25\t\t1,208,925,819,614,629,174,706,175\nuint88\t\t27\t\t309,485,009,821,345,068,724,781,055\nuint96\t\t29\t\t79,228,162,514,264,337,593,543,950,335\n...\nuint128\t\t39\t\t340,282,366,920,938,463,463,374,607,431,768,211,455\n...\nuint256\t\t78\t\t115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,935\n\n*/\n"
    },
    "src/token/hToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/ERC20H.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\n\n/**\n * @title Holograph token (aka hToken), used to wrap and bridge native tokens across blockchains.\n * @author Holograph Foundation\n * @notice A smart contract for minting and managing Holograph's Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract hToken is ERC20H {\n  /**\n   * @dev Sample fee for unwrapping.\n   */\n  uint16 private _feeBp; // 10000 == 100.00%\n\n  /**\n   * @dev List of supported Wrapped Tokens (equivalent), on current-chain.\n   */\n  mapping(address => bool) private _supportedWrappers;\n\n  /**\n   * @dev List of supported chains.\n   */\n  mapping(uint256 => bool) private _supportedChains;\n\n  /**\n   * @dev Event that is triggered when native token is converted into hToken.\n   */\n  event Deposit(address indexed from, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when ERC20 token is converted into hToken.\n   */\n  event TokenDeposit(address indexed token, address indexed from, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when hToken is converted into native token.\n   */\n  event Withdrawal(address indexed to, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when hToken is converted into ERC20 token.\n   */\n  event TokenWithdrawal(address indexed token, address indexed to, uint256 amount);\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    (address contractOwner, uint16 fee) = abi.decode(initPayload, (address, uint16));\n    assembly {\n      /**\n       * @dev bytes32(uint256(keccak256('eip1967.Holograph.admin')) - 1)\n       */\n      sstore(0x3f106594dc74eeef980dae234cde8324dc2497b13d27a0c59e55bd2ca10a07c9, contractOwner)\n    }\n    _setOwner(contractOwner);\n    _feeBp = fee;\n    // run underlying initializer logic\n    return _init(initPayload);\n  }\n\n  /**\n   * @dev Send native token value, get back hToken equivalent.\n   * @param recipient Address of where to send the hToken(s) to.\n   */\n  function holographNativeToken(address recipient) external payable {\n    require(_supportedChains[block.chainid], \"hToken: unsupported chain\");\n    require(msg.value > 0, \"hToken: no value received\");\n    address sender = msgSender();\n    if (recipient == address(0)) {\n      recipient = sender;\n    }\n    payable(holographer()).transfer(msg.value);\n    HolographERC20Interface(holographer()).sourceMint(recipient, msg.value);\n    emit Deposit(sender, msg.value);\n  }\n\n  /**\n   * @dev Send hToken, get back native token value equivalent.\n   * @param recipient Address of where to send the native token(s) to.\n   */\n  function extractNativeToken(address payable recipient, uint256 amount) external {\n    require(_supportedChains[block.chainid], \"hToken: unsupported chain\");\n    address sender = msgSender();\n    /// @dev Known operators\n    require(\n      sender == 0x43A730286D9aCf418a474Df26522004C75ac8660 ||\n        sender == 0xa1459B8370EB4491541f52E00ca1c2CAb38E0031 ||\n        sender == 0xFD405C0Aa70e6238971D8a0De6FE9C52C1facfC1 ||\n        sender == 0xC63620F6213F368A42704fbb818a9D9DbCb0ec9a ||\n        sender == 0xe3Aa495A00EC834Db027774bc7fCD1D992E387F4 ||\n        sender == 0x8c8e7838F88633A7fd7924530f6248597178a344,\n      \"hToken: unauthorized\"\n    );\n\n    require(ERC20(holographer()).balanceOf(sender) >= amount, \"hToken: not enough hToken(s)\");\n    require(holographer().balance >= amount, \"hToken: not enough native tokens\");\n    HolographERC20Interface(holographer()).sourceBurn(sender, amount);\n    uint256 fee = _feeBp == 0 ? 0 : (amount / 10000) * _feeBp;\n    if (fee > 0) {\n      HolographERC20Interface(HolographInterface(HolographerInterface(holographer()).getHolograph()).getTreasury())\n        .sourceTransfer(recipient, fee);\n    }\n    amount = amount - fee;\n    HolographERC20Interface(holographer()).sourceTransfer(recipient, amount);\n    emit Withdrawal(recipient, amount);\n  }\n\n  function isSupportedChain(uint256 chain) external view returns (bool) {\n    return _supportedChains[chain];\n  }\n\n  function isSupportedWrapper(address token) external view returns (bool) {\n    return _supportedWrappers[token];\n  }\n\n  function updateSupportedWrapper(address token, bool supported) external onlyOwner {\n    _supportedWrappers[token] = supported;\n  }\n\n  function updateSupportedChain(uint256 chain, bool supported) external onlyOwner {\n    _supportedChains[chain] = supported;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc721a-upgradeable/=erc721a-upgradeable/",
      "forge-std/=lib/forge-std/src/"
    ]
  }
}